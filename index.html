<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OmnI: Tomorrow</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon"/>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: white; cursor: none; }
        
        /* Layout */
        #canvas-container { 
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; 
            overflow: hidden;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlays */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; backdrop-filter: blur(10px);
            cursor: default;
        }

        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 140px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 40px; box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,1), transparent);
            z-index: 50;
            transition: opacity 1s ease-in-out;
            opacity: 1;
        }

        /* Center Control Group */
        .center-controls {
            display: flex; align-items: center; justify-content: center; gap: 20px;
        }

        /* Interactive Elements */
        .interactive { pointer-events: auto; cursor: pointer; }

        h1 { font-weight: 200; letter-spacing: 8px; text-transform: uppercase; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.2); text-align: center; }

        .control-group {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;
        }

        .btn-main {
            padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 13px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            border-radius: 4px; min-width: 150px;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); border-color: #fff; }

        /* Secondary Icon Buttons (Fullscreen / Skip) */
        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            font-size: 24px; padding: 10px; transition: 0.2s; display: flex; align-items: center;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.2); text-shadow: 0 0 10px #fff; }

        .radio-input {
            padding: 15px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #0f0; 
            width: 320px; font-family: monospace;
        }

        /* Navigation Arrows */
        .nav-btn {
            font-size: 50px; opacity: 0.3; transition: 0.3s; user-select: none; padding: 20px;
        }
        .nav-btn:hover { opacity: 1; text-shadow: 0 0 15px #fff; transform: scale(1.1); }

        #mode-info { text-align: center; min-width: 250px; }
        #mode-title { font-size: 24px; font-weight: 600; display: block; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #mode-sub { font-size: 12px; color: #aaa; font-family: monospace; letter-spacing: 1px; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; margin: 0 auto;}

        .hidden { opacity: 0 !important; pointer-events: none; }
        .display-none { display: none !important; }
        
        #loading-status { color: #0ff; margin-top: 20px; font-family: monospace; font-size: 12px; height: 20px; }

        /* Quick Radio Button (Top-right) */
        #radio-quick {
            position: absolute; top: 14px; right: 14px;
            z-index: 80;
            width: 40px; height: 40px;
            background: transparent url('radio.png') center center / contain no-repeat;
            border: none;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(6px);
            transition: opacity 1s ease-in-out;
        }
        #radio-quick:hover {
            filter: brightness(1.15);
        }

        /* Radio Panel */
        #radio-panel {
            position: absolute; top: 54px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 1s ease-in-out;
        }
        #radio-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #radio-list { padding: 8px; }
        .radio-item {
            padding: 10px 12px; margin: 6px 0; border-radius: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.12);
            cursor: pointer; transition: 0.15s;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 13px;
        }
        .radio-item:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.08) inset;
        }
        .radio-item.active {
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212,175,55,0.3) inset, 0 0 16px rgba(212,175,55,0.15);
            background: rgba(212,175,55,0.08);
        }

        /* Station Banner (Top-left) */
        #station-banner {
            position: absolute; top: 14px; left: 14px;
            z-index: 80;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-size: 13px;
            letter-spacing: 0.5px;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
            max-width: min(60vw, 720px);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        
        /* Settings Panel */
        #settings-panel {
            position: absolute; bottom: 160px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #settings-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #settings-content { padding: 12px; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 10px 0; }
        .settings-row label { font-size: 12px; color: #ccc; }
        .settings-row input[type="number"] { width: 96px; padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); color: #fff; border-radius: 4px; }
        .settings-row input[type="range"] { flex: 1; }
        .settings-note { font-size: 11px; color: #8aa; margin-top: 8px; line-height: 1.35; }
        .settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .btn-small {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
            font-size: 12px; letter-spacing: 1px; border-radius: 4px;
        }
        .btn-small:hover { background: #fff; color: #000; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "butterchurn": "https://esm.sh/butterchurn@2.6.0",
                "butterchurn-presets": "https://esm.sh/butterchurn-presets@2.4.7",
                "lodash": "https://esm.sh/lodash@4.17.21"
            }
        }
    </script>
</head>
<body>

    <!-- START SCREEN -->
    <div id="overlay">
        <h1>OmnI</h1>
        
        <div class="control-group">
            <!-- DEFAULT RADIO URL: BigFM Tomorrowland -->
            <input type="text" id="radio-url" class="radio-input interactive" value="https://stream.bigfm.de/tomorrowland/mp3-128/" placeholder="Paste Stream URL">
            <button class="btn-main interactive" id="btn-radio">▶ Start Radio</button>
        </div>

        <div class="control-group">
            <button class="btn-main interactive" id="btn-mic">Use Microphone</button>
            <button class="btn-main interactive" onclick="document.getElementById('file-input').click()">Load Local MP3</button>
            <input type="file" id="file-input" accept="audio/*" style="display:none">
        </div>

        <div id="loading-status">Select a source to begin</div>
    </div>

    <!-- HUD (Fades out when idle) -->
    <div id="ui-layer" class="hidden">
        <div class="nav-btn interactive" id="btn-prev">❮</div>

        <div class="center-controls">
            <!-- SKIP PRESET BUTTON (Only for ProjectM) -->
            <button class="icon-btn interactive display-none" id="btn-skip-preset" title="Next Visual Preset">⏭</button>

            <!-- TITLE INFO -->
            <div id="mode-info">
                <span id="mode-title">INIT</span>
                <span id="mode-sub">Engine Ready</span>
            </div>

            <!-- FULLSCREEN BUTTON -->
            <button class="icon-btn interactive" id="btn-fullscreen" title="Toggle Fullscreen">⛶</button>
            
            <!-- SETTINGS BUTTON -->
            <button class="icon-btn interactive" id="btn-settings" title="Visualizer Settings">⚙︎</button>
        </div>

        <div class="nav-btn interactive" id="btn-next">❯</div>
    </div>

    <div id="canvas-container"></div>
    <audio id="radio-element" crossorigin="anonymous"></audio>
    <!-- Quick Radio Button and Panel -->
    <div id="radio-quick" class="interactive" role="button" aria-label="Radio control" title="Left-click: random station • Right-click: choose"></div>
    <div id="radio-panel" class="display-none">
        <h3>Radio Stations</h3>
        <div id="radio-list"></div>
    </div>
    <div id="station-banner" class="display-none"></div>
    
    <!-- Settings Panel -->
    <div id="settings-panel" class="display-none">
        <h3>Visualizer Settings</h3>
        <div id="settings-content">
            <div class="settings-row">
                <label for="inp-shuffle-min">Shuffle min (s)</label>
                <input id="inp-shuffle-min" type="number" min="3" max="120" step="1" value="30">
            </div>
            <div class="settings-row">
                <label for="inp-shuffle-max">Shuffle max (s)</label>
                <input id="inp-shuffle-max" type="number" min="5" max="180" step="1" value="60">
            </div>
            <div class="settings-row">
                <label for="inp-transition">Transition (s)</label>
                <input id="inp-transition" type="number" min="0" max="10" step="0.1" value="2.7">
            </div>
            <div class="settings-row">
                <label for="inp-pixelratio">Pixel Ratio</label>
                <input id="inp-pixelratio" type="number" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="settings-note">Settings apply to ProjectM v2. Shuffle times are randomized between min and max. Transition affects preset morph duration. Pixel ratio applies on next init.</div>
            <div class="settings-actions">
                <button class="btn-small" id="btn-settings-apply">Apply</button>
                <button class="btn-small" id="btn-settings-close">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        import butterchurn from 'butterchurn';
        import butterchurnPresets from 'butterchurn-presets';

        // --- GLOBAL STATE ---
        const state = {
            audioCtx: null,
            sourceNode: null,
            analyserNode: null,
            isPlaying: false,
            currentModeIdx: 0,
            activeVisualizer: null,
            idleTimer: null
        };

        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('loading-status');
        const uiLayer = document.getElementById('ui-layer');
        const radioQuickBtn = document.getElementById('radio-quick');
        const radioPanel = document.getElementById('radio-panel');
        const radioListEl = document.getElementById('radio-list');
        const radioInputEl = document.getElementById('radio-url');
        const audioEl = document.getElementById('radio-element');
        const stationBanner = document.getElementById('station-banner');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsBtn = document.getElementById('btn-settings');
        const settingsApplyBtn = document.getElementById('btn-settings-apply');
        const settingsCloseBtn = document.getElementById('btn-settings-close');
        const inpShuffleMin = document.getElementById('inp-shuffle-min');
        const inpShuffleMax = document.getElementById('inp-shuffle-max');
        const inpTransition = document.getElementById('inp-transition');
        const inpPixelRatio = document.getElementById('inp-pixelratio');
        const stations = [];
        let currentStationIndex = -1;
        let panelIdleTimer = null;
        
        // Settings state (for ProjectM v2)
        const visualSettings = {
            shuffleMinSec: 30,
            shuffleMaxSec: 60,
            transitionSec: 2.7,
            pixelRatio: 1
        };

        // --- UI UTILS ---
        function resetIdleTimer() {
            uiLayer.style.opacity = '1';
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            if(!stationBanner.classList.contains('display-none')) {
                stationBanner.style.opacity = '1';
            }
            if(!radioPanel.classList.contains('display-none')) {
                radioPanel.style.opacity = '1';
                radioPanel.style.pointerEvents = 'auto';
            }
            document.body.style.cursor = 'default';
            if (state.idleTimer) clearTimeout(state.idleTimer);
            if (panelIdleTimer) clearTimeout(panelIdleTimer);
            if(state.isPlaying) {
                state.idleTimer = setTimeout(() => {
                    uiLayer.style.opacity = '0';
                    radioQuickBtn.style.opacity = '0';
                    radioQuickBtn.style.pointerEvents = 'none';
                    if(!stationBanner.classList.contains('display-none')) {
                        stationBanner.style.opacity = '0';
                    }
                    document.body.style.cursor = 'none';
                }, 3000);
                // Radio panel fades out after double time (6s) if open
                if(!radioPanel.classList.contains('display-none')) {
                    panelIdleTimer = setTimeout(() => {
                        radioPanel.style.opacity = '0';
                        radioPanel.style.pointerEvents = 'none';
                    }, 6000);
                }
            }
        }
        window.addEventListener('mousemove', resetIdleTimer);
        window.addEventListener('click', resetIdleTimer);

        // Updated Fullscreen Logic with forced Resize Trigger
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => forceResize(), 200);
                }).catch(err => console.log(err));
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().then(() => {
                        setTimeout(() => forceResize(), 200);
                    });
                }
            }
        }

        function forceResize() {
            if(state.activeVisualizer && state.activeVisualizer.onResize) {
                state.activeVisualizer.onResize();
            }
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyserNode = state.audioCtx.createAnalyser();
                state.analyserNode.fftSize = 2048; 
            }
            if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
        }

        function playRadio() {
            initAudio();
            const url = radioInputEl.value;
            
            statusEl.innerText = "Connecting to Stream...";
            // Update banner title
            if(currentStationIndex >= 0 && stations[currentStationIndex] && stations[currentStationIndex].url === url) {
                showStationBanner(stations[currentStationIndex].name);
            } else {
                showStationBanner(deriveTitleFromUrl(url));
            }
            
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaElementSource(audioEl);
                state.sourceNode.connect(state.analyserNode);
                state.analyserNode.connect(state.audioCtx.destination);
                if(!state.isPlaying) startGame();
            }).catch(e => {
                statusEl.innerText = "Stream Error: CORS or Format.";
                alert("Stream failed to play. The radio station might be blocking browser visualizers.");
            });
        }

        async function useMic() {
            initAudio();
            statusEl.innerText = "Requesting Mic Access...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaStreamSource(stream);
                state.sourceNode.connect(state.analyserNode);
                startGame();
            } catch(e) { statusEl.innerText = "Error: " + e.message; }
        }

        function useFile(e) {
            initAudio();
            const file = e.target.files[0];
            if(!file) return;
            statusEl.innerText = "Decoding...";
            const reader = new FileReader();
            reader.onload = (ev) => {
                state.audioCtx.decodeAudioData(ev.target.result, (buffer) => {
                    if(state.sourceNode) state.sourceNode.stop();
                    state.sourceNode = state.audioCtx.createBufferSource();
                    state.sourceNode.buffer = buffer;
                    state.sourceNode.loop = true;
                    state.sourceNode.connect(state.analyserNode);
                    state.analyserNode.connect(state.audioCtx.destination);
                    state.sourceNode.start(0);
                    startGame();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function startGame() {
            state.isPlaying = true;
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            loadMode(0); // Start with ProjectM
            resetIdleTimer();
        }

        // --- ENGINE: BUTTERCHURN ---
        class MilkdropEngine {
            constructor() {
                this.name = "ProjectM / Milkdrop";
                this.presets = butterchurnPresets.getPresets();
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null; // Track canvas reference
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                
                // FIX: Explicitly set canvas attributes to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                container.appendChild(this.canvas);

                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                const key = this.presetKeys[idx];
                this.visualizer.loadPreset(this.presets[key], 2.7); 
                document.getElementById('mode-sub').innerText = key;
            }

            nextPreset() {
                // Pick a random preset different from current
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 30;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 60;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }
            
            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                } catch(e) { alert("Invalid JSON"); }
            }

            onResize() { 
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    // FIX: Update attributes AND renderer
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: BUTTERCHURN v2 (Enhanced) ---
        class MilkdropEngineV2 {
            constructor() {
                this.name = "ProjectM v2";
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null;
                this.transitionSec = visualSettings.transitionSec;
                // Use global preset map directly (largest available pack)
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                container.appendChild(this.canvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if(this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                document.getElementById('mode-sub').innerText = key;
            }

            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, Number(visualSettings.transitionSec) || 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                } catch(e) { alert("Invalid JSON"); }
            }

            nextPreset() {
                if(this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            applySettings() {
                // Restart scheduling with new shuffle window
                this.restartCycle();
                // Transition seconds will be used on next loadPreset call automatically
            }

            onResize() {
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: THREE.JS ---
        class ThreeEngine {
            constructor(name, sceneFn) {
                this.name = name;
                this.sceneFn = sceneFn;
                this.resizeHandler = this.onResize.bind(this);
            }

            init() {
                container.innerHTML = '';
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 4;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio); // Sharpness
                container.appendChild(this.renderer.domElement);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);
                this.updateFn = this.sceneFn(this.scene, this.camera, this.composer);
                
                window.addEventListener('resize', this.resizeHandler);
                this.animate();
            }

            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                state.analyserNode.getByteFrequencyData(this.dataArray);
                if(this.updateFn) this.updateFn(this.dataArray, performance.now());
                this.composer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                window.removeEventListener('resize', this.resizeHandler);
                this.renderer.dispose();
                container.innerHTML = '';
            }
        }

        // --- SCENES ---
        const sceneSphere = (scene) => {
            const geo = new THREE.IcosahedronGeometry(1.8, 30);
            const mat = new THREE.MeshPhysicalMaterial({ wireframe: true, color: 0x00ff00, emissive: 0x004400 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            return (data, time) => {
                const bass = data[20]/255; 
                const t = time*0.0005;
                mesh.rotation.y += 0.005; 
                mesh.scale.setScalar(1 + bass*0.5); 
                mesh.material.color.setHSL(t%1, 1, 0.5);
            };
        };

        const sceneTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const count = 40;
            const meshes = [];
            for(let i=0; i<count; i++){
                const geo = new THREE.TorusGeometry(1+(i*0.5), 0.05, 8, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);
                meshes.push(mesh);
            }
            scene.add(group);
            return (data, time) => {
                const step = Math.floor(data.length/count);
                for(let i=0; i<count; i++){
                    const val = data[i*step]/255;
                    meshes[i].scale.setScalar(1 + val);
                    meshes[i].material.color.setHSL(val + (time*0.0002), 1, 0.5);
                    meshes[i].rotation.z += 0.01 * (i%2?1:-1);
                }
                camera.position.z = 25 + Math.sin(time*0.001)*5;
                camera.rotation.z = time * 0.0005;
            };
        };

        const sceneBars = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const numBars = 64;
            const spacing = 0.25;
            for(let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = (i - numBars/2) * spacing;
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0x00ffff, 1.2, 50);
            point.position.set(0, 5, 5);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / numBars);
                const t = time * 0.0008;
                for(let i = 0; i < numBars; i++) {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 3.0;
                    bars[i].scale.y = h;
                    bars[i].position.y = h * 0.25;
                    const hue = (i / numBars + t) % 1;
                    bars[i].material.color.setHSL(hue, 1, 0.5);
                    bars[i].material.emissive.setHSL(hue, 1, 0.2);
                }
                group.rotation.y = Math.sin(t * 0.5) * 0.2;
            };
        };

        // New scenes
        const sceneStarfield = (scene, camera) => {
            const stars = [];
            const geo = new THREE.SphereGeometry(0.02, 6, 6);
            for(let i=0;i<1200;i++){
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: Math.random()*0.8+0.2 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                scene.add(m); stars.push(m);
            }
            camera.position.z = 6;
            return (data, time) => {
                const bass = data[8]/255;
                const t = time*0.0002;
                stars.forEach((s, i) => {
                    s.position.z += 0.02 + bass*0.3;
                    if(s.position.z > 40) s.position.z = -40;
                    const hue = (i/1200 + t) % 1;
                    s.material.color.setHSL(hue, 0.7, 0.6);
                });
                camera.rotation.z = Math.sin(t*2)*0.1;
            };
        };

        const sceneWaveGrid = (scene, camera) => {
            const gridSize = 64;
            const spacing = 0.2;
            const group = new THREE.Group();
            const planes = [];
            for(let x=0;x<gridSize;x++){
                for(let y=0;y<gridSize;y++){
                    const geo = new THREE.PlaneGeometry(0.18, 0.18);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set((x - gridSize/2)*spacing, (y - gridSize/2)*spacing, 0);
                    group.add(p);
                    planes.push(p);
                }
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / gridSize);
                const t = time * 0.0015;
                planes.forEach((p, idx) => {
                    const i = idx % gridSize;
                    const j = Math.floor(idx / gridSize);
                    const v = data[(i*step) % data.length]/255;
                    p.position.z = Math.sin(i*0.2 + j*0.25 + t*4) * (0.1 + v*0.8);
                    const hue = (v + (i+j)/ (gridSize*2) + t*0.2)%1;
                    p.material.color.setHSL(hue, 1, 0.5);
                    p.material.opacity = 0.35 + v*0.65;
                });
                group.rotation.x = Math.sin(t*0.2)*0.4;
                group.rotation.y = Math.cos(t*0.25)*0.4;
            };
        };

        const sceneParticles = (scene, camera) => {
            const num = 1500;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                positions[i*3+0] = (Math.random()-0.5)*40;
                positions[i*3+1] = (Math.random()-0.5)*40;
                positions[i*3+2] = (Math.random()-0.5)*40;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 10;
            return (data, time) => {
                const bass = data[4]/255;
                points.rotation.y += 0.001 + bass*0.01;
                points.rotation.x += 0.0006;
                const hue = (time*0.0001)%1;
                points.material.color.setHSL(hue, 1, 0.6);
                points.material.size = 0.05 + bass*0.25;
            };
        };

        // --- Additional Tunnel Variants ---
        const sceneNeonTunnel = (scene, camera) => {
            const rings = [];
            const count = 36;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(2.5, 0.08, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.4;
                rings.push(m);
                scene.add(m);
            }
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[8]/255;
                rings.forEach((r, i) => {
                    r.position.z += 0.12 + bass*0.6;
                    if(r.position.z > 3.5) r.position.z -= count*1.4;
                    const hue = ((i/count) + time*0.0002) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.rotation.x = time*0.0006 + i*0.03;
                });
                camera.rotation.z = Math.sin(time*0.0006)*0.15;
            };
        };

        const sceneTwistTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const segs = [];
            for(let i=0;i<90;i++){
                const geo = new THREE.CylinderGeometry(2.2, 2.2, 0.4, 60, 1, true);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff66ff, wireframe: true, transparent: true, opacity: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*0.9;
                m.rotation.z = i*0.1;
                group.add(m);
                segs.push(m);
            }
            scene.add(group);
            camera.position.z = 3.5;
            return (data, time) => {
                const mid = data[24]/255;
                segs.forEach((s, i) => {
                    s.position.z += 0.08 + mid*0.5;
                    if(s.position.z > 2.5) s.position.z -= 90*0.9;
                    s.rotation.z += 0.003 + mid*0.03;
                    const hue = ((i/90) + time*0.00015) % 1;
                    s.material.color.setHSL(hue, 1, 0.6);
                    s.material.opacity = 0.25 + mid*0.75;
                });
                group.rotation.y = Math.sin(time*0.0005)*0.3;
            };
        };

        const sceneParticleTunnel = (scene, camera) => {
            const num = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const r = 2 + Math.random()*2.5;
                const a = Math.random()*Math.PI*2;
                const z = -Math.random()*60;
                positions[i*3+0] = Math.cos(a)*r;
                positions[i*3+1] = Math.sin(a)*r;
                positions[i*3+2] = z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 3;
            return (data, time) => {
                const bass = data[6]/255;
                const arr = geo.attributes.position.array;
                for(let i=0;i<arr.length;i+=3){
                    arr[i+2] += 0.22 + bass*1.6;
                    if(arr[i+2] > 2.5) arr[i+2] -= 62.5;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0002)%1;
                mat.color.setHSL(hue, 1, 0.7);
                points.rotation.z += 0.001 + bass*0.02;
            };
        };

        const sceneGalaxy = (scene, camera) => {
            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            for(let i=0;i<count;i++){
                const r = Math.random() * 20;
                const angle = Math.random()*Math.PI*2;
                const arm = ((i%2) * 2 - 1) * (r*0.1);
                const x = Math.cos(angle + arm) * r;
                const y = (Math.random()-0.5) * 2;
                const z = Math.sin(angle + arm) * r;
                positions[i*3+0] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                const c = new THREE.Color().setHSL((r/20)*0.6 + 0.2, 1, 0.6);
                colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 16;
            return (data, time) => {
                const bass = data[10]/255;
                points.rotation.z = time*0.0001 + bass*0.2;
                mat.size = 0.04 + bass*0.18;
            };
        };

        const sceneKaleidoRings = (scene, camera) => {
            const group = new THREE.Group();
            const rings = [];
            for(let i=0;i<14;i++){
                const geo = new THREE.TorusGeometry(0.8 + i*0.35, 0.04, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const torus = new THREE.Mesh(geo, mat);
                group.add(torus);
                rings.push(torus);
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / rings.length);
                const t = time*0.0006;
                rings.forEach((r, i) => {
                    const v = data[i*step]/255;
                    r.rotation.x = t*(i%3+1);
                    r.rotation.y = -t*(i%2+1);
                    r.material.color.setHSL(((i/rings.length)+t)%1, 1, 0.55);
                    r.material.opacity = 0.3 + v*0.7;
                    r.scale.setScalar(1 + v*0.4);
                });
                group.rotation.z = Math.sin(t*2)*0.3;
            };
        };

        const sceneTerrain = (scene, camera) => {
            const size = 80;
            const segments = 120;
            const geo = new THREE.PlaneGeometry(size, size, segments, segments);
            const mat = new THREE.MeshStandardMaterial({ color: 0x4444ff, wireframe: false, metalness: 0.2, roughness: 0.9, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2.5;
            scene.add(mesh);
            const light = new THREE.PointLight(0x88ccff, 2, 120);
            light.position.set(0, 20, 20);
            scene.add(light, new THREE.AmbientLight(0xffffff, 0.35));
            const noise = new SimplexNoise();
            camera.position.set(0, 10, 22);
            return (data, time) => {
                const arr = geo.attributes.position.array;
                const t = time*0.0003;
                const bass = data[20]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = arr[i+0];
                    const y = arr[i+1];
                    const n = noise.noise3d(x*0.05, y*0.05, t)*2.0;
                    arr[i+2] = n + bass*3.0;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.material.color.setHSL((t*0.2 + bass*0.3)%1, 0.8, 0.5);
                light.intensity = 1.5 + bass*2.5;
            };
        };

        const sceneHexGrid = (scene, camera) => {
            const group = new THREE.Group();
            const hexes = [];
            const radius = 0.25;
            const rows = 22, cols = 22;
            for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                    const x = (c + (r%2?0.5:0)) * radius*1.8 - cols*radius*0.9;
                    const y = r * radius*1.6 - rows*radius*0.8;
                    const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 6, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, metalness: 0.1, roughness: 0.7 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x, y, 0);
                    m.rotation.x = Math.PI/2;
                    group.add(m);
                    hexes.push(m);
                }
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xff66ff, 1.6, 60);
            light.position.set(0, 0, 10);
            scene.add(light, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / hexes.length) || 1;
                const t = time*0.001;
                hexes.forEach((h, i) => {
                    const v = data[(i*step)%data.length]/255;
                    h.scale.z = 0.4 + v*2.8;
                    const hue = (v*0.6 + ((i%cols)/cols) + t*0.1)%1;
                    h.material.color.setHSL(hue, 1, 0.5);
                    h.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z = Math.sin(t*0.5)*0.2;
            };
        };

        const sceneRibbons = (scene, camera) => {
            const group = new THREE.Group();
            const ribbons = [];
            const createRibbon = (color) => {
                const points = [];
                for(let i=0;i<80;i++){
                    points.push(new THREE.Vector3(i*0.08, Math.sin(i*0.2)*0.4, 0));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tube = new THREE.TubeGeometry(curve, 200, 0.03, 8, false);
                const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.2, emissive: 0x000000 });
                const mesh = new THREE.Mesh(tube, mat);
                return mesh;
            };
            for(let i=0;i<6;i++){
                const hue = i/6;
                const col = new THREE.Color().setHSL(hue, 1, 0.6);
                const m = createRibbon(col);
                m.position.y = (i-3)*0.4;
                m.position.x = -3;
                group.add(m);
                ribbons.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.6), group);
            const light = new THREE.PointLight(0x66ffff, 2, 40);
            light.position.set(0, 2, 8);
            scene.add(light);
            camera.position.set(0, 2, 10);
            return (data, time) => {
                const bass = data[12]/255;
                const t = time*0.0012;
                ribbons.forEach((m, i) => {
                    m.rotation.y = t*(i%3+1);
                    m.rotation.x = Math.sin(t + i)*0.3;
                    m.position.x = -3 + Math.sin(t*0.7 + i)*2.5 + bass*2.0;
                });
                group.rotation.z = Math.sin(t*0.6)*0.2;
                light.intensity = 1.2 + bass*2.0;
            };
        };

        // --- Infinity Pattern Tunnels ---
        const sceneInfinityTunnel = (scene, camera, composer) => {
            const rings = [];
            const count = 64;
            const baseRadius = 2.2;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(baseRadius, 0.06, 12, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.0;
                rings.push(m);
                scene.add(m);
            }
            const after = new AfterimagePass(0.88);
            composer.addPass(after);
            camera.position.z = 4;
            return (data, time) => {
                const t = time * 0.001;
                const bass = data[10]/255;
                rings.forEach((r, i) => {
                    // Figure-eight cross-section via Lissajous pattern
                    const phase = (i*0.22) + t*1.2;
                    r.position.x = Math.sin(phase) * (baseRadius * 0.6);
                    r.position.y = Math.sin(phase*2.0) * (baseRadius * 0.35);
                    r.position.z += 0.18 + bass*0.8;
                    if(r.position.z > 2.5) r.position.z -= count*1.0;
                    const hue = ((i/count) + t*0.05) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.material.opacity = 0.35 + bass*0.6;
                    r.rotation.x = phase*0.2;
                    r.rotation.y = -phase*0.15;
                });
                camera.rotation.z = Math.sin(t*0.8)*0.2;
            };
        };

        const sceneInfinityMirror = (scene, camera, composer) => {
            const frames = [];
            const count = 40;
            for(let i=0;i<count;i++){
                const geo = new THREE.RingGeometry(0.8, 3.0, 6, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.z = -i*1.4;
                frames.push(ring);
                scene.add(ring);
            }
            const after = new AfterimagePass(0.9);
            composer.addPass(after);
            camera.position.z = 3.8;
            return (data, time) => {
                const t = time*0.001;
                const mid = data[24]/255;
                frames.forEach((f, i) => {
                    f.position.z += 0.14 + mid*0.7;
                    if(f.position.z > 2.5) f.position.z -= count*1.4;
                    const s = 0.9 + Math.sin(i*0.2 + t*2.0)*0.08 + mid*0.2;
                    f.scale.set(s, s, s);
                    f.rotation.z = t*0.7 + i*0.05;
                    const hue = ((i/count) + t*0.1) % 1;
                    f.material.color.setHSL(hue, 1, 0.65);
                    f.material.opacity = 0.3 + mid*0.7;
                });
            };
        };
        // --- Kaleidoscope Shader ---
        const KaleidoShader = {
            uniforms: {
                tDiffuse: { value: null },
                sides: { value: 6.0 },
                angle: { value: 0.0 },
                rotation: { value: 0.0 },
                time: { value: 0.0 },
                gain: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float sides;
                uniform float angle;
                uniform float rotation;
                uniform float time;
                uniform float gain;
                varying vec2 vUv;
                
                float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
                float noise(vec2 p){
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f*f*(3.0-2.0*f);
                    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
                }
                float fbm(vec2 p){
                    float v = 0.0;
                    float a = 0.5;
                    for(int i=0;i<5;i++){
                        v += a * noise(p);
                        p = p * 2.0 + vec2(23.1, 17.7);
                        a *= 0.5;
                    }
                    return v;
                }
                vec3 palette(float t){
                    return 0.5 + 0.5*cos(6.2831853*(vec3(0.0,0.33,0.67) + t));
                }
                vec4 fractalColor(vec2 uv){
                    // Centered uv for fractal evolution
                    vec2 q = uv - 0.5;
                    float r = length(q);
                    float ang = atan(q.y, q.x);
                    vec2 p = vec2(cos(ang), sin(ang)) * (r * 2.2);
                    float f = fbm(p * 1.8 + vec2(time*0.15, -time*0.11 + gain*0.3));
                    vec3 col = palette(f + r*0.25 + gain*0.2);
                    // Radial darkening to avoid bright center
                    float vign = smoothstep(0.95, 0.3, r);
                    return vec4(col * vign, 1.0);
                }
                void main() {
                    vec2 uv = vUv - 0.5;
                    float r = length(uv);
                    float a = atan(uv.y, uv.x) + rotation;
                    float sector = 6.28318530718 / max(1.0, sides);
                    a = mod(a, sector);
                    a = abs(a - sector * 0.5);
                    a += angle;
                    vec2 pos = vec2(cos(a), sin(a)) * r;
                    vec2 sampleUv = pos + 0.5;
                    bool inBounds = all(greaterThanEqual(sampleUv, vec2(0.0))) && all(lessThanEqual(sampleUv, vec2(1.0)));
                    vec4 src = texture2D(tDiffuse, clamp(sampleUv, 0.0, 1.0));
                    vec4 fractCol = fractalColor(sampleUv);
                    // Blend: use fractal when out-of-bounds, otherwise softly mix by radial factor to eliminate white cores
                    float mixAmt = smoothstep(0.0, 0.35, r) * 0.7 + gain*0.2;
                    vec4 col = mix(src, fractCol, mixAmt);
                    if(!inBounds){
                        col = fractCol;
                    }
                    gl_FragColor = col;
                }
            `
        };

        const RadialZoomShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    vec2 toCenter = center - vUv;
                    float offset = strength * 0.02;
                    for (float t = 0.0; t <= 1.0; t += 0.1) {
                        vec2 sampleUv = vUv + toCenter * t * offset;
                        color += texture2D(tDiffuse, sampleUv);
                        total += 1.0;
                    }
                    gl_FragColor = color / total;
                }
            `
        };

        // Helper: build a simple colorful source for kaleidoscope
        function buildKaleidoSource(scene) {
            const group = new THREE.Group();
            const num = 24;
            for(let i=0;i<num;i++){
                const hue = i/num;
                const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6) });
                const geo = new THREE.TorusKnotGeometry(0.5 + (i%6)*0.05, 0.12, 90, 18, 2 + (i%3), 3 + (i%4));
                const m = new THREE.Mesh(geo, mat);
                m.position.set(Math.cos(i)*2.2, Math.sin(i*1.3)*1.2, -1 - (i%5)*0.2);
                m.rotation.x = i*0.2;
                m.rotation.y = i*0.15;
                group.add(m);
            }
            scene.add(group);
            return group;
        }

        const sceneKaleido = (sides) => (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            pass.uniforms.sides.value = sides;
            composer.addPass(pass);
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[12]/255;
                group.rotation.y = time*0.0006 + bass*0.2;
                group.rotation.x = Math.sin(time*0.0004)*0.3;
                pass.uniforms.rotation.value = time*0.0002 + bass*0.6;
                pass.uniforms.angle.value = Math.sin(time*0.0005)*0.5;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = bass;
            };
        };

        const sceneKaleidoSpiral = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            composer.addPass(pass);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[6]/255;
                pass.uniforms.sides.value = 5.0 + Math.floor((Math.sin(time*0.0007)+1.0)*3.5); // 5..12
                pass.uniforms.rotation.value = time*0.00035 + bass*0.8;
                pass.uniforms.angle.value = Math.cos(time*0.0006)*0.8;
                group.rotation.y += 0.002 + bass*0.02;
                group.rotation.z = Math.sin(time*0.0003)*0.4;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = (data[12]+data[24])/(2.0*255.0);
            };
        };

        const sceneKaleidoLayered = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const k1 = new ShaderPass(KaleidoShader);
            const k2 = new ShaderPass(KaleidoShader);
            k1.uniforms.sides.value = 7.0;
            k2.uniforms.sides.value = 11.0;
            composer.addPass(k1);
            composer.addPass(k2);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[10]/255;
                group.rotation.x = time*0.0005;
                group.rotation.y = Math.sin(time*0.0003)*0.4;
                k1.uniforms.rotation.value = time*0.0002 + bass*0.5;
                k2.uniforms.rotation.value = -time*0.00025 + bass*0.7;
                k1.uniforms.angle.value = Math.sin(time*0.0004)*0.6;
                k2.uniforms.angle.value = Math.cos(time*0.00045)*0.6;
                k1.uniforms.time.value = time*0.001;
                k2.uniforms.time.value = time*0.001;
                const g = (data[6]+data[12]+data[24])/(3.0*255.0);
                k1.uniforms.gain.value = g;
                k2.uniforms.gain.value = g*0.8;
            };
        };

        const sceneKaleidoZoom = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const kaleido = new ShaderPass(KaleidoShader);
            const zoom = new ShaderPass(RadialZoomShader);
            composer.addPass(kaleido);
            composer.addPass(zoom);
            camera.position.z = 4.5;
            return (data, time) => {
                const bass = data[14]/255;
                group.rotation.y = time*0.0005 + bass*0.3;
                kaleido.uniforms.sides.value = 10.0;
                kaleido.uniforms.rotation.value = time*0.00025;
                zoom.uniforms.center.value.set(0.5, 0.5);
                zoom.uniforms.strength.value = 0.1 + bass*0.6;
                kaleido.uniforms.time.value = time*0.001;
                kaleido.uniforms.gain.value = (data[10]+data[14]+data[18])/(3.0*255.0);
            };
        };

        // --- Self-Replicating / Fractal Scenes ---
        const sceneMengerSponge = (scene, camera) => {
            const depth = 2; // keep counts reasonable
            const positions = [];
            function addLevel(center, size, d){
                if(d === 0){
                    positions.push({ center, size });
                    return;
                }
                const step = size / 3;
                for(let x=0;x<3;x++){
                    for(let y=0;y<3;y++){
                        for(let z=0;z<3;z++){
                            // Skip the center cross sections
                            const mid = (x===1) + (y===1) + (z===1);
                            if(mid >= 2) continue;
                            const nx = center.x + (x-1)*step;
                            const ny = center.y + (y-1)*step;
                            const nz = center.z + (z-1)*step;
                            addLevel(new THREE.Vector3(nx, ny, nz), step, d-1);
                        }
                    }
                }
            }
            addLevel(new THREE.Vector3(0,0,0), 6, depth);
            const count = positions.length;
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.3, roughness: 0.6, emissive: 0x000000 });
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            const dummy = new THREE.Object3D();
            positions.forEach((p, i) => {
                dummy.position.copy(p.center);
                dummy.scale.setScalar(p.size * 0.95);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            });
            mesh.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(6, 8, 10);
            scene.add(light, mesh);
            camera.position.set(0, 0, 14);
            return (data, time) => {
                const g = (data[6]+data[12]+data[24])/(3*255);
                mesh.rotation.x = time*0.0003 + g*0.4;
                mesh.rotation.y = time*0.0004 + g*0.5;
                mat.emissiveIntensity = 0.2 + g*2.0;
                const hue = (time*0.00008 + g*0.3) % 1;
                mat.color.setHSL(hue, 0.7, 0.6);
            };
        };

        const sceneSierpinskiTetra = (scene, camera) => {
            // Base tetra geometry
            const r = 1;
            const v = [
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1),
                new THREE.Vector3(1, -1, -1)
            ];
            const base = new THREE.TetrahedronGeometry(r, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff88aa, metalness: 0.2, roughness: 0.7 });
            const depth = 4;
            const transforms = [];
            function add(level, center, scale){
                if(level === 0){
                    transforms.push({ center, scale });
                    return;
                }
                const s = scale * 0.5;
                for(let i=0;i<4;i++){
                    add(level-1, new THREE.Vector3(
                        center.x + v[i].x * s,
                        center.y + v[i].y * s,
                        center.z + v[i].z * s
                    ), s);
                }
            }
            add(depth, new THREE.Vector3(0,0,0), 3.0);
            const inst = new THREE.InstancedMesh(base, mat, transforms.length);
            const dummy = new THREE.Object3D();
            transforms.forEach((t, i) => {
                dummy.position.copy(t.center);
                dummy.scale.setScalar(t.scale);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.PointLight(0xff66ff, 2.4, 100);
            light.position.set(6, 6, 12);
            scene.add(light, inst);
            camera.position.set(0, 0, 16);
            return (data, time) => {
                const bass = data[8]/255;
                inst.rotation.y = time*0.00035 + bass*0.6;
                inst.rotation.x = time*0.0002;
                const hue = (time*0.00012) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                light.intensity = 1.4 + bass*3.0;
            };
        };

        const sceneGameOfLife = (scene, camera) => {
            const W = 128, H = 128;
            const cells = new Uint8Array(W*H);
            const nextCells = new Uint8Array(W*H);
            // random init
            for(let i=0;i<W*H;i++){ cells[i] = Math.random() < 0.15 ? 1 : 0; }
            const data = new Uint8Array(W*H*3);
            const tex = new THREE.DataTexture(data, W, H, THREE.RGBFormat);
            tex.needsUpdate = true;
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.95 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), mat);
            scene.add(plane);
            camera.position.z = 10;
            function step() {
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        let n = 0;
                        for(let dy=-1;dy<=1;dy++){
                            for(let dx=-1;dx<=1;dx++){
                                if(dx===0 && dy===0) continue;
                                const nx = (x+dx+W)%W;
                                const ny = (y+dy+H)%H;
                                n += cells[ny*W + nx];
                            }
                        }
                        const c = cells[idx];
                        nextCells[idx] = (c===1 && (n===2 || n===3)) || (c===0 && n===3) ? 1 : 0;
                    }
                }
                cells.set(nextCells);
            }
            let acc = 0;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3*255);
                // step a few times per second + boost with audio
                acc += 0.016 + g*0.05;
                while(acc > 0.1){ step(); acc -= 0.1; }
                // write texture
                const t = time*0.0002;
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        const alive = cells[idx];
                        const i3 = idx*3;
                        const hue = (t + x/W*0.3 + y/H*0.2) % 1;
                        const c = alive ? hue : 0.0;
                        // hsv to rgb approx via palette
                        const r = 0.5 + 0.5*Math.cos(6.2831*(c + 0.0));
                        const gch = 0.5 + 0.5*Math.cos(6.2831*(c + 0.33));
                        const b = 0.5 + 0.5*Math.cos(6.2831*(c + 0.67));
                        data[i3+0] = Math.floor(r*255);
                        data[i3+1] = Math.floor(gch*255);
                        data[i3+2] = Math.floor(b*255);
                    }
                }
                tex.needsUpdate = true;
                plane.rotation.z = Math.sin(time*0.0003)*0.2;
                plane.scale.setScalar(1.0 + g*0.3);
            };
        };

        // --- Emoji Helpers and Scenes ---
        function createEmojiTexture(char) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '200px Apple Color Emoji, Noto Color Emoji, Segoe UI Emoji, EmojiOne Mozilla, Twemoji Mozilla, Segoe UI Symbol, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(char, size/2, size/2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const EMOJIS = ['🎵','✨','🔥','💫','🌈','💥','❤️','🌀','🌟','🤖','🎧','🎉','🎇','🛰️','🪐','⚡️'];

        const sceneEmojiSwarm = (scene, camera) => {
            const sprites = [];
            const velocities = [];
            const count = 240;
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            for(let i=0;i<count;i++){
                const tex = textures[i % textures.length];
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                const spr = new THREE.Sprite(mat);
                spr.position.set((Math.random()-0.5)*18, (Math.random()-0.5)*10, (Math.random()-0.5)*12);
                const s = Math.random()*0.7 + 0.3;
                spr.scale.set(s, s, 1);
                sprites.push(spr);
                velocities.push(new THREE.Vector3((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03));
                scene.add(spr);
            }
            camera.position.z = 8;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                sprites.forEach((s, i) => {
                    const v = velocities[i];
                    // Simple cohesion toward origin + slight orbit
                    const toCenter = s.position.clone().multiplyScalar(-0.002);
                    v.add(toCenter);
                    v.x += Math.sin(t + i*0.1)*0.001;
                    v.y += Math.cos(t*0.8 + i*0.07)*0.001;
                    s.position.add(v);
                    // Wrap bounds
                    if(s.position.x > 10) s.position.x = -10;
                    if(s.position.x < -10) s.position.x = 10;
                    if(s.position.y > 6) s.position.y = -6;
                    if(s.position.y < -6) s.position.y = 6;
                    if(s.position.z > 8) s.position.z = -8;
                    if(s.position.z < -8) s.position.z = 8;
                    // Pulse size with bass
                    const base = 0.3 + (i%5)*0.04;
                    const pulse = base + bass*0.8;
                    s.scale.set(pulse, pulse, 1);
                    s.material.opacity = 0.6 + bass*0.4;
                });
                camera.rotation.z = Math.sin(t*0.4)*0.1;
            };
        };

        const sceneEmojiOrbits = (scene, camera) => {
            const group = new THREE.Group();
            scene.add(group);
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            const rings = [];
            for(let r=0;r<5;r++){
                const ringGroup = new THREE.Group();
                const num = 18 + r*6;
                const radius = 2.0 + r*1.2;
                for(let i=0;i<num;i++){
                    const tex = textures[(i+r) % textures.length];
                    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                    const spr = new THREE.Sprite(mat);
                    const a = (i/num)*Math.PI*2;
                    spr.position.set(Math.cos(a)*radius, Math.sin(a)*radius, -r*0.4);
                    const s = 0.25 + r*0.08;
                    spr.scale.set(s, s, 1);
                    ringGroup.add(spr);
                }
                group.add(ringGroup);
                rings.push({ group: ringGroup, radius });
            }
            camera.position.z = 8;
            return (data, time) => {
                const bass = data[8]/255;
                const mid = data[24]/255;
                rings.forEach((r, i) => {
                    r.group.rotation.z += 0.002 + bass*0.02 + i*0.0005;
                    r.group.position.z = Math.sin(time*0.0006 + i)*0.6;
                    r.group.children.forEach((spr, j) => {
                        spr.material.rotation = time*0.0004 + j*0.05;
                        const s = spr.scale.x;
                        const pulse = s * (1.0 + mid*0.8*Math.sin(time*0.004 + j));
                        spr.scale.set(pulse, pulse, 1);
                    });
                });
                group.rotation.x = Math.sin(time*0.0004)*0.2;
                group.rotation.y = Math.cos(time*0.0003)*0.2;
            };
        };

        // --- MASTER CONTROL ---
        const modes = [
            new MilkdropEngine(),
            new MilkdropEngineV2(),
            new ThreeEngine("Neon Sphere", sceneSphere),
            new ThreeEngine("Cyber Tunnel", sceneTunnel),
            new ThreeEngine("Audio Bars", sceneBars),
            new ThreeEngine("Starfield", sceneStarfield),
            new ThreeEngine("Wave Grid", sceneWaveGrid),
            new ThreeEngine("Particles", sceneParticles),
            new ThreeEngine("Infinity Tunnel", sceneInfinityTunnel),
            new ThreeEngine("Infinity Mirror", sceneInfinityMirror),
            new ThreeEngine("Neon Tunnel", sceneNeonTunnel),
            new ThreeEngine("Twist Tunnel", sceneTwistTunnel),
            new ThreeEngine("Particle Tunnel", sceneParticleTunnel),
            new ThreeEngine("Galaxy", sceneGalaxy),
            new ThreeEngine("Kaleido Rings", sceneKaleidoRings),
            new ThreeEngine("Terrain", sceneTerrain),
            new ThreeEngine("Hex Grid", sceneHexGrid),
            new ThreeEngine("Ribbons", sceneRibbons),
            new ThreeEngine("Emoji Swarm", sceneEmojiSwarm),
            new ThreeEngine("Emoji Orbits", sceneEmojiOrbits),
            new ThreeEngine("Kaleidoscope 6", sceneKaleido(6)),
            new ThreeEngine("Kaleidoscope 8", sceneKaleido(8)),
            new ThreeEngine("Kaleidoscope 12", sceneKaleido(12)),
            new ThreeEngine("Kaleidoscope Spiral", sceneKaleidoSpiral),
            new ThreeEngine("Kaleidoscope Layered", sceneKaleidoLayered),
            new ThreeEngine("Kaleidoscope Zoom", sceneKaleidoZoom)
        ];

        function loadMode(index) {
            if(state.activeVisualizer) state.activeVisualizer.destroy();
            let idx = index;
            if(idx < 0) idx = modes.length - 1;
            if(idx >= modes.length) idx = 0;
            state.currentModeIdx = idx;
            state.activeVisualizer = modes[idx];
            
            // UI Updates
            document.getElementById('mode-title').innerText = state.activeVisualizer.name;
            if(!(state.activeVisualizer && state.activeVisualizer.loadPreset)) {
                document.getElementById('mode-sub').innerText = "3D Interactive";
            }
            
            // Show/Hide Skip Button
            const skipBtn = document.getElementById('btn-skip-preset');
            if(state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') skipBtn.classList.remove('display-none');
            else skipBtn.classList.add('display-none');

            state.activeVisualizer.init();
        }

        // --- BINDINGS ---
        document.getElementById('btn-prev').addEventListener('click', () => { loadMode(state.currentModeIdx - 1); resetIdleTimer(); });
        document.getElementById('btn-next').addEventListener('click', () => { loadMode(state.currentModeIdx + 1); resetIdleTimer(); });
        document.getElementById('btn-radio').addEventListener('click', playRadio);
        document.getElementById('btn-mic').addEventListener('click', useMic);
        document.getElementById('file-input').addEventListener('change', useFile);
        document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
        settingsBtn.addEventListener('click', () => {
            if(settingsPanel.classList.contains('display-none')) {
                settingsPanel.classList.remove('display-none');
            } else {
                settingsPanel.classList.add('display-none');
            }
        });
        settingsCloseBtn.addEventListener('click', () => settingsPanel.classList.add('display-none'));
        settingsApplyBtn.addEventListener('click', () => {
            // Read and clamp settings
            const minS = Math.max(3, Math.min(120, Number(inpShuffleMin.value) || 12));
            const maxS = Math.max(5, Math.min(180, Number(inpShuffleMax.value) || 25));
            const trans = Math.max(0, Math.min(10, Number(inpTransition.value) || 2.7));
            const px = Math.max(0.5, Math.min(3, Number(inpPixelRatio.value) || 1));
            visualSettings.shuffleMinSec = minS;
            visualSettings.shuffleMaxSec = maxS;
            visualSettings.transitionSec = trans;
            visualSettings.pixelRatio = px;
            // Apply if active is v2
            if(state.activeVisualizer && state.activeVisualizer instanceof MilkdropEngineV2) {
                state.activeVisualizer.applySettings?.();
            }
        });
        
        // Skip Preset Button Logic
        document.getElementById('btn-skip-preset').addEventListener('click', () => {
            if(state.activeVisualizer && state.activeVisualizer.nextPreset) {
                state.activeVisualizer.nextPreset();
            }
        });

        // --- RADIO: Load stations and UI ---
        async function loadStations() {
            try {
                const resp = await fetch('radio.txt');
                const txt = await resp.text();
                stations.length = 0;
                txt.split('\n').forEach((line) => {
                    const raw = line.trim();
                    if(!raw) return;
                    const parts = raw.split('|');
                    if(parts.length >= 2) {
                        const name = parts[0].trim();
                        const url = parts.slice(1).join('|').trim();
                        stations.push({ name, url });
                    }
                });
                renderStationList();
            } catch(e) {
                console.warn('Failed to load radio.txt', e);
            }
        }

        function renderStationList() {
            radioListEl.innerHTML = '';
            stations.forEach((s, i) => {
                const item = document.createElement('div');
                item.className = 'radio-item';
                item.dataset.index = String(i);
                if(i === currentStationIndex) item.classList.add('active');
                const nameEl = document.createElement('div');
                nameEl.textContent = s.name;
                const goEl = document.createElement('div');
                goEl.textContent = '➤';
                item.appendChild(nameEl);
                item.appendChild(goEl);
                item.addEventListener('click', () => {
                    setStation(i);
                });
                radioListEl.appendChild(item);
            });
        }

        function setStation(index) {
            if(index < 0 || index >= stations.length) return;
            currentStationIndex = index;
            const s = stations[index];
            radioInputEl.value = s.url;
            showStationBanner(s.name);
            updateStationActiveHighlight();
            playRadio();
        }

        function updateStationActiveHighlight() {
            const children = Array.from(radioListEl.children);
            children.forEach((el) => {
                const idx = Number(el.dataset.index || -1);
                if(idx === currentStationIndex) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function pickRandomStation() {
            if(stations.length === 0) return;
            let idx = currentStationIndex;
            if(stations.length === 1) idx = 0;
            else {
                while(idx === currentStationIndex) {
                    idx = Math.floor(Math.random() * stations.length);
                }
            }
            setStation(idx);
        }

        function showRadioPanel() { radioPanel.classList.remove('display-none'); }
        function hideRadioPanel() { radioPanel.classList.add('display-none'); }
        function toggleRadioPanel() {
            if(radioPanel.classList.contains('display-none')) showRadioPanel();
            else hideRadioPanel();
        }

        function showStationBanner(text) {
            stationBanner.textContent = text || '';
            if(!text) return;
            stationBanner.classList.remove('display-none');
            stationBanner.style.opacity = '1';
        }

        function deriveTitleFromUrl(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch {
                return url;
            }
        }

        // Swap: left-click now opens panel; right-click picks random
        radioQuickBtn.title = "Left-click: choose • Right-click: random station";
        radioQuickBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleRadioPanel();
        });
        radioQuickBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pickRandomStation();
        });
        document.addEventListener('click', (e) => {
            if(!radioPanel.classList.contains('display-none')) {
                if(!radioPanel.contains(e.target) && e.target !== radioQuickBtn) {
                    hideRadioPanel();
                }
            }
        });

        // Drag Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            // Accept only for ProjectM (either version)
            const active = state.activeVisualizer;
            if(!(active instanceof MilkdropEngine) && !(active instanceof MilkdropEngineV2)) {
                return alert("Switch to ProjectM (v1 or v2) first");
            }
            const file = e.dataTransfer.files[0];
            if(!file) return;
            const lower = file.name.toLowerCase();
            if(lower.endsWith('.milk')) {
                alert("Raw .milk files are not directly supported. Please convert to butterchurn JSON first.");
                return;
            }
            const reader = new FileReader();
            reader.onload = (ev) => active.loadCustomMilk?.(ev.target.result);
            reader.readAsText(file);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if(e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            } else if(e.key === 's' || e.key === 'S') {
                if(state.activeVisualizer?.nextPreset) {
                    state.activeVisualizer.nextPreset();
                }
            }
        });

        // Bootstrap station list
        loadStations();

    </script>
</body>
</html>