<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Omniâ–·ðŸ“¡</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon"/>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Oswald:wght@400;700&family=Montserrat:wght@400;700&family=Raleway:wght@400;700&family=Poppins:wght@400;700&family=Orbitron:wght@400;700&family=Playfair+Display:wght@400;700&family=Lobster&family=Open+Sans:wght@400;700&family=Nunito:wght@400;700&family=Merriweather:wght@400;700&family=Rubik:wght@400;700&family=Inter:wght@400;700&family=Fira+Sans:wght@400;700&family=Fira+Mono:wght@400;700&family=Inconsolata:wght@400;700&family=Source+Code+Pro:wght@400;700&family=Press+Start+2P&family=Audiowide&family=Share+Tech+Mono&family=VT323&family=Rajdhani:wght@400;700&family=Electrolize&family=Oxanium:wght@400;700&family=Quantico:wght@400;700&family=Syncopate:wght@400;700&family=Exo+2:wght@400;700&family=Chakra+Petch:wght@400;700&family=Teko:wght@400;700&family=Sarpanch:wght@400;700&family=Major+Mono+Display&family=Monoton&family=Quicksilver&display=swap" rel="stylesheet">
		<link rel="preload" href="pta.gif" as="image">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <style>
		body { margin: 0; overflow: hidden; background-color: #000; background-image: url('pta.gif'); background-repeat: repeat; background-position: top left; background-size: auto; font-family: 'Quicksand', sans-serif; color: white; cursor: none; }
		/* Ensure Quicksand applies across the UI */
		*, *::before, *::after { font-family: 'Quicksand', sans-serif !important; }
        
        /* Layout */
        #canvas-container { 
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; 
            overflow: hidden;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlays */
        #overlay {
			position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; backdrop-filter: blur(10px);
            cursor: default;
        }
		/* Lighter overlay when background GIF is present so it doesn't look too dark */
		#overlay.bg-lite {
			background: rgba(0,0,0,0.4);
		}
		/* Disable backdrop blur when tiling pta.gif to keep it crisp */
		#overlay.no-blur {
			backdrop-filter: none !important;
			-webkit-backdrop-filter: none !important;
		}
		/* Overlay border glow (random color set via --glowColor) */
		#overlay.glow-on {
			box-shadow: inset 0 0 60px var(--glowColor, #66ccff), 0 0 120px var(--glowColor, #66ccff);
			animation: borderGlow 2400ms ease-in-out infinite alternate;
			position: relative; /* allow border frame layering */
			border-radius: 70px; /* more rounded corners as requested */
		}
		/* Volume slider (top-center, fades like other overlays) */
		#volume-slider-container {
			position: fixed; top: 14px; left: 50%; transform: translateX(-50%);
			width: 80vw; height: 32px;
			display: none; /* hidden on start overlay; shown after playback starts */
			align-items: center; justify-content: center; z-index: 80;
			pointer-events: auto; opacity: 1; transition: opacity 1s ease-in-out;
		}
		#volume-slider {
			-webkit-appearance: none; appearance: none; width: 100%; height: 14px;
			background: rgba(255,255,255,0.08); /* almost transparent track */
			cursor: pointer; border-radius: 7px;
		}
		/* Thumb */
		#volume-slider::-webkit-slider-thumb {
			-webkit-appearance: none; appearance: none;
			width: 56px; height: 56px; border-radius: 50%;
			background: transparent url('vol.png') center center / 100% 100% no-repeat;
			border: none;
			margin-top: -21px;
		}
		#volume-slider::-moz-range-thumb {
			width: 56px; height: 56px; border-radius: 50%;
			background: transparent url('vol.png') center center / 100% 100% no-repeat;
			border: none;
		}
		/* Full-screen rounded border frame over everything */
		#border-frame {
			/* Offset by half the stroke so it extends inside and outside evenly */
			/* Push slightly further to ensure full edge coverage */
			position: fixed; top: -22.5px; left: -22.5px; right: -22.5px; bottom: -22.5px;
			/* Use a repeating GIF around the edge instead of solid black */
			border: 45px solid transparent;
			border-image-source: url('tap.gif');
			border-image-slice: 45;
			border-image-repeat: round;
			border-radius: 55px;
			/* variables for curved dissolve */
			--frameOuter: 55px;       /* matches border-radius */
			--frameStroke: 45px;      /* matches border width */
			--dissolve: 10px;         /* inner fade thickness */
			--innerR: calc(var(--frameOuter) - var(--frameStroke)); /* inner corner radius */
			--overlap: 10px;          /* push dissolve outward by a few more pixels */
			--cornerSpan: calc(var(--innerR) + var(--dissolve) + var(--overlap)); /* span consumed by corner */
			box-sizing: border-box;
			pointer-events: none;
			z-index: 100000; /* ensure frame sits above overlay glow */
			opacity: 0;
			transition: opacity 600ms ease;
		}
		#border-frame.visible { opacity: 1; }
		/* Curved inner dissolve at the inside edge of the frame */
		#border-frame::after {
			content: none; /* remove dissolve overlay */
		}
		/* Corner seam cover: solid black caps to guarantee no color gap shows */
		#border-frame::before {
			content: none; /* remove seam caps when dissolve is disabled */
		}
		@keyframes borderGlow {
			0% { box-shadow: inset 0 0 24px var(--glowColor, #66ccff), 0 0 40px var(--glowColor, #66ccff); }
			100% { box-shadow: inset 0 0 90px var(--glowColor, #66ccff), 0 0 160px var(--glowColor, #66ccff); }
		}
		/* OMNI logo shimmer */
		#logo-omni {
			color: transparent !important; /* ensure background-clip shows through */
			position: relative; display: inline-block;
			font-weight: 700;
			letter-spacing: 10px;
			text-transform: uppercase;
			margin-bottom: 0px; /* minimal gap below title */
			font-size: clamp(96px, 18vw, 280px); /* doubled size */
			text-shadow: 0 0 20px rgba(255,255,255,0.15), 0 0 24px var(--glowColor, rgba(102,204,255,0.6)), 0 0 48px var(--glowColor, rgba(102,204,255,0.35));
		}
		/* Per-letter pattern fill */
		#logo-omni .logo-letter {
			display: inline-block;
			color: transparent;
			-webkit-text-fill-color: transparent;
			-webkit-background-clip: text;
			background-clip: text;
			background-image: url('pat.gif');
			background-repeat: no-repeat; /* reuse but do not tile */
			background-position: center center;
			background-size: cover; /* fill the glyph area */
		}
		#logo-omni.logo-animate {
			animation: omniShimmer 1400ms ease forwards;
		}
		/* Persistent glow pulse around OMNI */
		#logo-omni.logo-glow {
			animation: logoGlow 2400ms ease-in-out infinite alternate;
		}
		@keyframes logoGlow {
			0% { text-shadow: 0 0 3px rgba(255,255,255,0.2), 0 0 8px var(--glowColor, #66ccff), 0 0 16px var(--glowColor, #66ccff); }
			100% { text-shadow: 0 0 16px rgba(255,255,255,0.4), 0 0 36px var(--glowColor, #66ccff), 0 0 76px var(--glowColor, #66ccff); }
		}
		@keyframes omniShimmer {
			0% { opacity: 0; transform: translateY(8px) scale(0.98); color: var(--omniColor, #66ccff); text-shadow: 0 0 0 var(--omniColor, #66ccff); }
			35% { opacity: 1; transform: translateY(0) scale(1.0); color: var(--omniColor, #66ccff); text-shadow: 0 0 16px var(--omniColor, #66ccff), 0 0 28px var(--omniColor, #66ccff); }
			70% { color: #dfefff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
			100% { color: #ffffff; text-shadow: 0 0 0 rgba(255,255,255,0); }
		}
        /* Digital transition when starting visuals */
        #overlay.digital-out {
            animation: digitalOut 520ms ease forwards;
        }
        @keyframes digitalOut {
            0% { opacity: 1; transform: none; filter: none; }
            15% { transform: translateY(-2px) skewX(-2deg); filter: contrast(120%) saturate(110%); }
            30% { transform: translateY(1px) skewX(2deg); filter: contrast(140%) saturate(120%); }
            55% { opacity: 0.6; transform: translateY(-1px) skewX(-1deg); }
            75% { opacity: 0.25; transform: translateY(0) skewX(0deg); filter: contrast(160%) saturate(130%); }
            100% { opacity: 0; transform: none; filter: none; }
        }

        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            min-height: clamp(88px, 12vh, 160px);
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 clamp(12px, 3vw, 40px); box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,1), transparent);
            z-index: 50;
            transition: opacity 1s ease-in-out;
            opacity: 1;
        }

        /* Center Control Group */
        .center-controls {
            display: flex; align-items: center; justify-content: center;
            gap: clamp(8px, 2vw, 24px); 
            flex-wrap: nowrap;
            flex: 1 1 auto;
            min-width: 0; /* allow shrinking */
        }

        /* Interactive Elements */
        .interactive { pointer-events: auto; cursor: pointer; }

        h1 { font-weight: 200; letter-spacing: 8px; text-transform: uppercase; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.2); text-align: center; }

        .control-group {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;
        }

        .btn-main {
            padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 13px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            border-radius: 4px; min-width: 150px;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); border-color: #fff; }

        /* Secondary Icon Buttons (Fullscreen / Skip) */
        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            font-size: clamp(18px, 2.5vw, 28px); padding: 10px; transition: 0.2s; display: flex; align-items: center;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.2); text-shadow: 0 0 10px #fff; }
        /* Precise hitbox for the WebM close (âœ•) button */
        #btn-webm-close {
            width: 32px; height: 32px;
            display: inline-flex; align-items: center; justify-content: center;
            padding: 0; line-height: 1; font-size: 20px;
            cursor: pointer; user-select: none;
        }

        .radio-input {
			padding: 15px; background: rgba(0,0,0,0.5); border: 2px solid rgba(255,20,147,1.0); color: #0f0; 
			width: 320px; border-radius: 14px; box-shadow: 0 0 18px rgba(255,20,147,0.9), 0 0 3px rgba(255,20,147,0.85);
			transition: box-shadow 220ms ease, border-color 220ms ease;
		}
		.radio-input:focus {
			outline: none; border-color: rgba(255,20,147,1.0);
			box-shadow: 0 0 24px rgba(255,20,147,0.95), 0 0 6px rgba(255,20,147,0.9);
        }

        /* Navigation Arrows */
        .nav-btn {
            font-size: clamp(36px, 6vw, 64px); opacity: 0.3; transition: 0.3s; user-select: none; padding: clamp(10px, 2vh, 20px);
        }
        .nav-btn:hover { opacity: 1; text-shadow: 0 0 15px #fff; transform: scale(1.1); }

        #mode-info { 
            text-align: center; 
            min-width: 0; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            flex: 1 1 auto; 
        }
        #mode-title { 
            font-size: clamp(16px, 2vw, 26px); 
            font-weight: 600; 
            display: inline; 
            letter-spacing: 2px; 
            margin-right: 8px; 
            text-shadow: 0 0 10px rgba(0,0,0,0.5); 
        }
		#mode-sub { 
			font-size: clamp(10px, 1.2vw, 14px); 
			color: #aaa; 
			letter-spacing: 1px; 
			display: inline; 
		}

        .hidden { opacity: 0 !important; pointer-events: none; }
        .display-none { display: none !important; }
        
		#loading-status { color: #39ff14; margin-top: 6px; font-size: 12px; height: 20px; transition: opacity 0.6s ease; }
		#shortcuts-status { 
			color: #ff1493; margin-top: 8px; font-size: 12px; min-height: 18px; 
			white-space: pre-line; text-align: center;
			position: absolute; left: 50%; transform: translateX(-50%);
			pointer-events: none; width: 86vw; max-width: 1200px; line-height: 1.35;
			overflow: hidden; /* ensure at most 3 lines visible */
			transition: opacity 0.6s ease;
		}
		/* Toggleable URL input (now sits below the title, reserves space) */
		#url-flyover {
			position: static; left: auto; transform: none;
			z-index: auto;
			margin-top: 8px;
			display: flex; align-items: center; justify-content: center;
			min-height: 56px; /* reserve space so title stays centered */
			opacity: 1; transition: opacity 260ms ease;
		}
		#url-flyover.is-hidden {
			opacity: 0; pointer-events: none;
		}

        /* Quick Radio Button (Top-right) */
        #radio-quick {
            position: absolute; 
            top: 14px; 
            right: 14px;
            z-index: 80;
            width: 80px; height: 80px;
            background-color: transparent;
            background-image: url('radio.png');
            background-repeat: no-repeat;
            background-position: center center;
            background-size: contain;
            border: none;
            cursor: pointer;
            user-select: none;
            transition: opacity 1s ease-in-out;
        }
        #radio-quick:hover {
            filter: brightness(1.15);
        }
		/* Hide the radio quick button whenever the start overlay is visible */
		#overlay:not(.hidden) ~ #radio-quick { 
			display: none !important; 
		}
		/* Top bar container to align volume and radio buttons */
		#top-bar {
			position: fixed; top: 10px; left: 14px; right: 14px;
			display: none; z-index: 80;
			display: flex; align-items: center; justify-content: center;
			pointer-events: auto; opacity: 1; transition: opacity 1s ease-in-out;
		}
		/* Radio quick - large top-right button */
		#top-bar #radio-quick {
			position: absolute !important; right: 14px; top: 0;
			width: 80px !important; height: 80px !important;
			background-size: contain !important;
		}
		/* Center the volume slider and ensure it doesn't overlap the right button */
		#top-bar #volume-slider-container {
			position: absolute; left: 50%; transform: translateX(-50%);
			width: calc(100% - 140px); max-width: 80vw; height: 64px;
			display: flex; align-items: center; justify-content: center;
			min-width: 360px;
		}
        
        /* Shuffle Toggle (Top-left) */
        #shuffle-toggle {
            position: absolute; 
            top: clamp(24px, 12vh, 140px); 
            left: 14px;
            z-index: 80;
            width: 80px; height: 80px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.9);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(6px);
            transition: opacity 1s ease-in-out, filter 0.2s;
            font-size: 36px;
        }
        #shuffle-toggle:hover { filter: brightness(1.15); }
        #shuffle-toggle.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }

        /* Radio Panel */
        #radio-panel {
            position: absolute; top: 54px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 1s ease-in-out;
        }
        #radio-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #radio-list { padding: 8px; }
        .radio-item {
            padding: 10px 12px; margin: 6px 0; border-radius: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.12);
            cursor: pointer; transition: 0.15s;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 13px;
        }
        .radio-item:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.08) inset;
        }
        .radio-item.active {
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212,175,55,0.3) inset, 0 0 16px rgba(212,175,55,0.15);
            background: rgba(212,175,55,0.08);
        }

        /* Text-In sliding panel (left) */
        #textin-panel {
            position: absolute; top: 0; left: 0;
            width: 50vw; max-width: 50vw; height: 100vh; overflow: hidden;
            z-index: 90;
            background: rgba(0,0,0,0.85);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 0 10px 10px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transform: translateX(-110%);
            transition: transform 0.35s ease, opacity 0.4s ease;
            opacity: 0;
            display: flex; flex-direction: column;
        }
        #textin-panel.open {
            transform: translateX(0);
            opacity: 1;
        }
        #textin-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
            display:flex; align-items:center; justify-content:space-between;
        }
        #textin-content { padding: 12px 12px 36px; display: grid; grid-template-columns: 1fr; gap: 12px; flex: 1; overflow: auto; box-sizing: border-box; }
        .textin-row { display:flex; gap:10px; align-items:center; }
        .textin-col { display:flex; gap:10px; }
        .textin-label { width: 88px; font-size:12px; color:#bbb; }
        .textin-input, .textin-select, .textin-color, .textin-range {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff; border-radius: 6px; padding: 10px 12px; font-size: 13px;
        }
        .textin-input { width: 100%; font-family: inherit; }
        .textin-select { min-width: 160px; }
        .textin-color { padding: 4px; height: 36px; width: 48px; }
        .textin-range { width: 100%; height: 36px; }
        .textin-btn {
            padding: 10px 16px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 12px; text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
            border-radius: 6px;
        }
        .textin-btn:hover { background: #fff; color: #000; }
        .textin-num {
            width: 72px; padding: 6px 8px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.06);
            color: #fff; border-radius: 6px; font-size: 12px;
        }
        .slider-col { position: relative; flex: 1; height: 22px; }
        /* All three handles (min, current, max) share the same visual track line */
        .slider-col .main-range { position: absolute; inset: 0; height: 16px; z-index: 2; }
        .slider-col .range-sub { position: absolute; inset: 0; pointer-events: auto; display: none; }
        .slider-col .range-sub .sub-range { position: absolute; inset: 0; height: 16px; background: transparent; z-index: 3; }
        .btn-mini {
            padding: 4px 8px; border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.06); color: #fff; border-radius: 6px;
            font-size: 11px; line-height: 1; cursor: pointer;
        }
        .btn-mini:hover { background: rgba(255,255,255,0.18); }
        #textin-preview-wrap {
            border: 1px dashed rgba(255,255,255,0.2);
            border-radius: 8px; padding: 14px; min-height: 80px;
            display:flex; align-items:center; justify-content:center;
            background: rgba(0,0,0,0.3);
            margin-bottom: 18px;
        }
        #textin-preview {
            pointer-events: none; user-select: none;
            white-space: pre-wrap; text-align: center;
        }
        /* FORCE CROSSFADER IMAGE HANDLE */
/* Updated to target #mix-panel so it works in the header too */

#mix-panel #mix-crossfader {
    -webkit-appearance: none;
    appearance: none;
    height: 14px !important; /* Match volume track height */
    background: rgba(255,255,255,0.08) !important;
    border-radius: 7px;
    border: none;
    opacity: 1;
}

/* Chrome / Edge / Safari */
#mix-panel #mix-crossfader::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none !important;
    width: 56px !important;
    height: 56px !important;
    background: transparent url('vol.png') center center / 100% 100% no-repeat !important;
    border: none !important;
    border-radius: 50%;
    margin-top: -21px !important; /* Centers the 56px thumb on the 14px track */
    box-shadow: none !important;
}

/* Firefox */
#mix-panel #mix-crossfader::-moz-range-thumb {
    width: 56px !important;
    height: 56px !important;
    background: transparent url('vol.png') center center / 100% 100% no-repeat !important;
    border: none !important;
    border-radius: 50%;
    box-shadow: none !important;
}

/* Remove the "filled" progress bar effect on Firefox */
#mix-panel #mix-crossfader::-moz-range-progress {
    background: transparent !important;
}
        /* Overlay layer for rising texts */
        #text-overlay-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 45; pointer-events: none;
        }
        .rising-text {
            position: absolute; left: 50%; transform: translate(-50%, 0);
            will-change: transform, opacity, text-shadow, filter;
            white-space: pre;
        }
        /* Mic confirm modal */
        #mic-confirm {
            position: fixed; inset: 0; z-index: 140;
            background: rgba(0,0,0,0.6);
            display: none;
            align-items: center; justify-content: center;
            backdrop-filter: blur(6px);
        }
        #mic-confirm .panel {
            background: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            min-width: 320px; max-width: 90vw;
            padding: 18px;
            color: #fff;
            text-align: center;
        }
        #mic-confirm .title {
            font-size: 16px; margin-bottom: 10px; letter-spacing: 1px;
        }
        #mic-confirm .desc {
            font-size: 12px; color: #bbb; margin-bottom: 14px;
        }
        #mic-confirm .actions { display: flex; gap: 10px; justify-content: center; }
        #mic-confirm .btn {
            padding: 10px 16px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 12px; text-transform: uppercase; letter-spacing: 1px; transition: 0.2s;
            border-radius: 6px; cursor: pointer;
        }
        #mic-confirm .btn:hover { background: #fff; color: #000; }

        /* Mix Settings Panel (Moved to Bottom) */
#mix-panel {
    position: fixed; bottom: 0; left: 0; right: 0;
    width: 100%; max-width: 100%; height: 50vh; overflow: hidden;
    z-index: 120;
    background: rgba(0,0,0,0.85);
    border-top: 1px solid rgba(255,255,255,0.2);
    border-radius: 10px 10px 0 0;
    box-shadow: 0 -10px 30px rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    transform: translateY(100%);
    transition: transform 0.35s ease, opacity 0.4s ease;
    opacity: 0; display:flex; flex-direction:column;
}
#mix-panel.open { transform: translateY(0); opacity: 1; }
        #mix-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
            display:flex; align-items:center; justify-content:space-between;
        }
        #mix-content { 
            padding: 12px; 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            flex: 1; 
            overflow: auto; 
            justify-content: flex-start; /* Stacks items at the top */
        }
        #mix-effects { display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap: 8px; }
        /* Generic Button Style for Mix Panel */
        #mix-panel .btn {
            padding: 6px 12px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.08);
            color: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s ease;
            background-image: url('btn.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        #mix-panel .btn:hover {
            /* Make background slightly lighter transparent white, keep text white */
            background: rgba(217,2,45,0.1); 
            color: #f5d20f;
            box-shadow: 0 0 10px rgba(255,255,255,0.15);
            border-color: rgba(245,210,15,0.3);
            background-image: url('btn.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
        #mix-effects .btn {
            position: relative;
            padding: 10px;
            border: 1px solid rgba(255,0,0,0.25);
            background-color: rgba(0,0,0,0.25);
            background-image: url('btn.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: 100% 100%; /* stretch to fill entire button */
            color: #fff;
            border-radius: 6px;
            font-size: 14px;
            text-shadow: 0 0 4px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.6);
        }
        #mix-effects .btn.on {
            border-color: rgba(212,175,55,0.8);
            box-shadow: 0 0 12px rgba(212,175,55,0.25) inset;
            background-color: rgba(212,175,55,0.12);
            background-image: url('btn.png');
            background-position: center;
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }
       
        /* Optional: Hover effect to brighten the image */
        #mix-b-play:hover,
        #mix-b-stop:hover {
            filter: brightness(1.2);
            border-color: rgba(217,2,45,0.2);
            cursor: pointer;
        }
        .status-row { display:flex; align-items:center; gap:8px; font-size:12px; color:#bbb; }
        .status-dot {
            width: 10px; height: 10px; border-radius: 50%;
            background: rgba(255,255,255,0.3);
            box-shadow: 0 0 0 0 rgba(0,0,0,0);
            transition: background 0.2s, box-shadow 0.2s;
        }
        .status-dot.on {
            background: #22cc66;
            box-shadow: 0 0 10px rgba(34,204,102,0.8);
        }
        .vertical-range {
            writing-mode: bt-lr; /* IE/Edge */
            -webkit-appearance: slider-vertical; /* WebKit */
            appearance: slider-vertical;
            width: 26px; height: 220px;
        }
        /* Station Banner (Top-left) */
        #station-banner {
            position: absolute; top: 14px; left: 14px;
            z-index: 80;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-size: 18px;
            letter-spacing: 0.5px;
            pointer-events: auto;
            transition: opacity 1s ease-in-out;
            max-width: min(60vw, 720px);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        #station-banner.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }
        
        /* Settings Panel */
        #settings-panel {
            position: absolute; bottom: 160px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #settings-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #settings-content { padding: 12px; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 10px 0; }
        .settings-row label { font-size: 12px; color: #ccc; }
        .settings-row input[type="number"] { width: 96px; padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); color: #fff; border-radius: 4px; }
        .settings-row input[type="range"] { flex: 1; }
        
        /* Unified slider styling (transparent tracks) */
        #settings-panel input[type="range"],
        #webm-settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            background: transparent;
            cursor: pointer;
        }
        /* ROTARY KNOB STYLES (Final Layout Fix) */
        .eq-strip {
            display: flex;
            align-items: stretch;   /* Ensures divider line stretches full height */
            justify-content: space-between; 
            margin-top: 12px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .eq-group {
            display: flex;
            flex: 1;                /* Force groups to take up equal width */
            justify-content: space-between; /* Spread knobs evenly inside the group */
        }
        .eq-divider {
            width: 1px;
            background: rgba(255,255,255,0.15);
            margin: 0 24px;         /* Adds 24px space on both sides (48px total gap) */
            flex-shrink: 0;         /* Prevents line from disappearing if squeezed */
        }
        .eq-col {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            width: 32px; 
        }
        .knob-wrap {
            position: relative;
            width: 32px; height: 32px;
            border-radius: 50%;
            background: radial-gradient(100% 100% at 50% 20%, #444 0%, #111 100%);
            border: 1px solid #555;
            box-shadow: 0 4px 6px rgba(0,0,0,0.5), inset 0 1px 1px rgba(255,255,255,0.2);
            cursor: ns-resize; /* Indicates drag up/down */
        }
        /* The colored line on the knob */
        .knob-indicator {
            position: absolute;
            top: 50%; left: 50%;
            width: 2px; height: 45%;
            background: var(--knob-color, #fff);
            transform-origin: 50% 0; /* Pivot from center */
            transform: translate(-50%, 0) rotate(180deg); /* Point down by default */
            border-radius: 2px;
            pointer-events: none;
            box-shadow: 0 0 4px var(--knob-color, #fff);
        }
        .eq-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            text-align: center;
        }
        /* Tooltip for value while dragging */
        .knob-value {
            position: absolute;
            top: -18px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #fff;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            white-space: nowrap;
        }
        .knob-wrap:active .knob-value, .knob-wrap:hover .knob-value {
            opacity: 1;
        }
        /* WebKit track */
        #settings-panel input[type="range"]::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* WebKit thumb */
        #settings-panel input[type="range"]::-webkit-slider-thumb,
        #webm-settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            margin-top: -4px;
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Firefox track */
        #settings-panel input[type="range"]::-moz-range-track,
        #webm-settings-panel input[type="range"]::-moz-range-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* Firefox progress (filled portion) */
        #settings-panel input[type="range"]::-moz-range-progress,
        #webm-settings-panel input[type="range"]::-moz-range-progress {
            height: 6px;
            background: rgba(212,175,55,0.28); /* subtle gold on filled part */
            border-radius: 6px 0 0 6px;
        }
        /* Firefox thumb */
        #settings-panel input[type="range"]::-moz-range-thumb,
        #webm-settings-panel input[type="range"]::-moz-range-thumb {
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Hover/active states to increase opacity */
        #settings-panel input[type="range"]:hover::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:hover::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:active::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.28);
        }
        #settings-panel input[type="range"]:hover::-moz-range-track,
        #webm-settings-panel input[type="range"]:hover::-moz-range-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-moz-range-track,
        #webm-settings-panel input[type="range"]:active::-moz-range-track {
            background: rgba(255,255,255,0.28);
        }
        .settings-note { font-size: 11px; color: #8aa; margin-top: 8px; line-height: 1.35; }
        .settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .btn-small {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
            font-size: 12px; letter-spacing: 1px; border-radius: 4px;
        }
        .btn-small:hover { background: #fff; color: #000; }
        
        /* WebM Overlay */
        #webm-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 45;
            pointer-events: none;
        }
        #webm-overlay video {
            width: 50vw; height: auto; display: block;
            pointer-events: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        .webm-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            z-index: 60;
            font-size: 56px; color: rgba(255,255,255,0.7);
            background: transparent; border: none; padding: 12px; cursor: pointer;
            transition: opacity 1s ease-in-out, transform 0.2s;
            opacity: 1;
        }
        .webm-nav:hover { color: #fff; text-shadow: 0 0 15px #fff; transform: translateY(-50%) scale(1.1); }
        #webm-prev { left: 14px; }
        #webm-next { right: 14px; }
        
        /* WebM Settings Panel (mirror of settings-panel) */
        #webm-settings-panel {
            position: absolute; bottom: 160px; left: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #webm-settings-panel h3 {
            margin: 0; font-weight: 500; font-size: 14px;
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #webm-settings-panel .panel-head {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.12);
        }
        #webm-settings-content { padding: 12px; }
        .settings-row input[type="range"] { flex: 1; }

		/* Top Menu Panel (slides from top, 50vh) */
		#top-menu-panel {
			position: fixed; top: 0; left: 0; right: 0; height: 50vh;
			z-index: 95;
			background: rgba(0,0,0,0.8);
			border-bottom: 1px solid rgba(255,255,255,0.2);
			backdrop-filter: blur(10px);
			box-shadow: 0 10px 30px rgba(0,0,0,0.6);
			transform: translateY(-100%);
			transition: transform 0.35s ease-in-out, opacity 0.2s ease-in-out;
			opacity: 0; pointer-events: none;
			display: flex; flex-direction: column;
		}
		#top-menu-panel.open {
			transform: translateY(0);
			opacity: 1; pointer-events: auto;
		}
		#top-menu-header {
			display: flex; align-items: center; justify-content: space-between;
			padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.12);
		}
		#top-menu-content { padding: 12px; display: grid; gap: 10px; grid-template-columns: 1fr; flex: 1; overflow: auto; }
		#top-menu-actions { display: grid; gap: 8px; grid-template-columns: repeat(4, minmax(0, 1fr)); }
		#top-menu-webm { display: grid; gap: 8px; grid-template-columns: minmax(0,1fr) auto auto; align-items: center; }
		#top-menu-content .row { display: flex; gap: 8px; align-items: center; }
		#top-menu-content input[type="text"] {
			flex: 1; padding: 10px 12px; background: rgba(255,255,255,0.06);
			border: 1px solid rgba(255,255,255,0.25); color: #fff; border-radius: 8px;
		}
		#top-menu-content .btn {
			padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
			font-size: 12px; letter-spacing: 1px; border-radius: 6px; cursor: pointer;
		}
		#top-menu-content .btn:hover { background: #fff; color: #000; }
		/* Footer with volume slider pinned to the bottom of the panel */
		#top-menu-footer { padding: 8px 14px; border-top: 1px solid rgba(255,255,255,0.12); }
		#top-menu-footer #volume-slider-container {
			/* Override global fixed/top styles so it lives inside the panel footer */
			position: static; left: auto; top: auto; transform: none; z-index: auto;
			display:flex; align-items:center; justify-content: center; width:100%; height:48px;
			opacity: 1 !important; pointer-events: auto;
		}
		/* Themed select (WebM dropdown) */
		#avatar-webm-select {
			appearance: none; -webkit-appearance: none; -moz-appearance: none;
			padding: 0 12px; min-width: 220px;
			background: rgba(255,255,255,0.06);
			border: 1px solid rgba(255,255,255,0.25);
			color: #fff; border-radius: 8px;
			flex: 1; min-width: 0; width: auto; max-width: 100%;
			height: 42px; box-sizing: border-box;
		}
		#avatar-webm-select:focus { outline: none; border-color: rgba(255,255,255,0.45); }
		/* Allow left header group to expand, enabling the select to stretch */
		#bottom-avatar-header > div:first-child { flex: 1; min-width: 0; }
		/* Add a bit of spacing before the right-side controls group */
		#bottom-avatar-header > div:last-child { margin-left: 10px; flex-shrink: 0; }
		/* Enlarge all buttons on the Avatar Settings top line by ~50% with rounded corners */
		#bottom-avatar-header .btn {
			font-size: 1.5em;
			height: 42px;
			padding: 0 16px;
			border-radius: 10px;
			display: inline-flex; align-items: center; justify-content: center;
			line-height: 1; box-sizing: border-box;
			/* Theme colors (avoid white buttons) */
			background: rgba(255,255,255,0.08);
			border: 1px solid rgba(255,255,255,0.25);
			color: #fff;
			cursor: pointer;
			transition: background 160ms ease;
		}
		#bottom-avatar-header .btn:hover { background: rgba(212,175,55,0.28); color: #fff; }
		/* Icon buttons after the WebM dropdown: make square with rounded corners */
		#avatar-webm-open,
		#avatar-webm-prev,
		#avatar-webm-next,
		#btn-bottommenu-close {
			width: 42px; height: 42px;
			padding: 0;
			display: inline-flex; align-items: center; justify-content: center;
			border-radius: 10px;
			line-height: 1;
		}
		/* Ensure right-side header buttons use the same theme */
		#avatar-btn-auto,
		#avatar-btn-reset,
		#btn-bottommenu-close {
			background: rgba(255,255,255,0.08);
			border: 1px solid rgba(255,255,255,0.25);
			color: #fff;
		}
		/* Auto toggle "on" state uses text color only */
		#avatar-btn-auto.on,
		#btn-webm-auto.on {
			color: #ffd700;
		}
		#avatar-btn-auto:hover,
		#avatar-btn-reset:hover,
		#btn-bottommenu-close:hover {
			background: rgba(212,175,55,0.28);
			color: #fff;
		}
		/* Scrollbar styling for stations list */
		#top-menu-stations {
			scrollbar-color: rgba(255,255,255,0.35) rgba(255,255,255,0.08);
			scrollbar-width: thin;
		}
		#top-menu-stations::-webkit-scrollbar { width: 10px; height: 10px; }
		#top-menu-stations::-webkit-scrollbar-track { background: rgba(255,255,255,0.06); border-radius: 8px; }
		#top-menu-stations::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.32); border-radius: 8px; border: 2px solid rgba(0,0,0,0.15); }
		#top-menu-stations::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.45); }
		/* Make the volume slider clearly visible inside the top menu footer */
		#top-menu-footer #volume-slider {
			height: 16px;
			background: rgba(255,255,255,0.18);
			border-radius: 8px;
		}
		#top-menu-footer #volume-slider::-webkit-slider-runnable-track {
			height: 6px; background: rgba(255,255,255,0.24); border-radius: 6px;
		}
		#top-menu-footer #volume-slider::-moz-range-track {
			height: 6px; background: rgba(255,255,255,0.24); border-radius: 6px;
		}
		#top-menu-footer #volume-slider::-moz-range-progress {
			height: 6px; background: rgba(212,175,55,0.35); border-radius: 6px 0 0 6px;
		}
		/* Unify slider style across panels to match volume theme (track color, thumb style) */
		#top-menu-content input[type="range"],
        #mix-content input[type="range"],
        #textin-content input[type="range"],
		#bottom-avatar-content input[type="range"],
		#settings-panel input[type="range"],
		#webm-settings-panel input[type="range"] {
			-webkit-appearance: none; appearance: none;
			height: 16px; background: transparent; cursor: pointer;
		}
        #top-menu-content input[type="range"]::-webkit-slider-runnable-track,
        #mix-content input[type="range"]::-webkit-slider-runnable-track,
        #textin-content input[type="range"]::-webkit-slider-runnable-track,
		#bottom-avatar-content input[type="range"]::-webkit-slider-runnable-track,
		#settings-panel input[type="range"]::-webkit-slider-runnable-track,
		#webm-settings-panel input[type="range"]::-webkit-slider-runnable-track {
			height: 6px; background: rgba(255,255,255,0.24); border-radius: 6px;
		}
        #top-menu-content input[type="range"]::-moz-range-track,
        #mix-content input[type="range"]::-moz-range-track,
        #textin-content input[type="range"]::-moz-range-track,
		#bottom-avatar-content input[type="range"]::-moz-range-track,
		#settings-panel input[type="range"]::-moz-range-track,
		#webm-settings-panel input[type="range"]::-moz-range-track {
			height: 6px; background: rgba(255,255,255,0.24); border-radius: 6px;
		}
        #top-menu-content input[type="range"]::-moz-range-progress,
        #mix-content input[type="range"]::-moz-range-progress,
        #textin-content input[type="range"]::-moz-range-progress,
		#bottom-avatar-content input[type="range"]::-moz-range-progress,
		#settings-panel input[type="range"]::-moz-range-progress,
		#webm-settings-panel input[type="range"]::-moz-range-progress {
			height: 6px; background: rgba(212,175,55,0.35); border-radius: 6px 0 0 6px;
		}
        #top-menu-content input[type="range"]::-webkit-slider-thumb,
        #mix-content input[type="range"]::-webkit-slider-thumb,
        #textin-content input[type="range"]::-webkit-slider-thumb,
		#bottom-avatar-content input[type="range"]::-webkit-slider-thumb,
		#settings-panel input[type="range"]::-webkit-slider-thumb,
		#webm-settings-panel input[type="range"]::-webkit-slider-thumb {
			-webkit-appearance: none; appearance: none;
			width: 14px; height: 14px; border-radius: 50%;
			background: rgba(0,0,0,0.9); /* black thumb */
			border: 2px solid rgba(212,175,55,0.9); /* gold border */
			margin-top: -4px;
			box-shadow: 0 0 8px rgba(0,0,0,0.25);
		}
        #top-menu-content input[type="range"]::-moz-range-thumb,
        #mix-content input[type="range"]::-moz-range-thumb,
        #textin-content input[type="range"]::-moz-range-thumb,
		#bottom-avatar-content input[type="range"]::-moz-range-thumb,
		#settings-panel input[type="range"]::-moz-range-thumb,
		#webm-settings-panel input[type="range"]::-moz-range-thumb {
			width: 14px; height: 14px; border-radius: 50%;
			background: rgba(0,0,0,0.9); /* black thumb */
			border: 2px solid rgba(212,175,55,0.9); /* gold border */
			box-shadow: 0 0 8px rgba(0,0,0,0.25);
		}

		/* Bottom Avatar Menu Panel (Moved to Right) */
#bottom-avatar-panel {
    position: fixed; top: 0; right: 0; bottom: 0; height: 100vh;
    width: 50vw;
    z-index: 95;
    background: rgba(0,0,0,0.8);
    border-left: 1px solid rgba(255,255,255,0.2);
    border-radius: 10px 0 0 10px;
    backdrop-filter: blur(10px);
    box-shadow: -10px 0 30px rgba(0,0,0,0.6);
    transform: translateX(100%);
    transition: transform 0.35s ease-in-out, opacity 0.2s ease-in-out;
    opacity: 0; pointer-events: none;
    display: flex; flex-direction: column;
}
#bottom-avatar-panel.open {
    transform: translateX(0);
    opacity: 1; pointer-events: auto;
}
		#bottom-avatar-header {
			display: flex; align-items: center; justify-content: space-between;
			padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.12);
		}
		#bottom-avatar-content { padding: 12px; display: grid; gap: 10px; grid-template-columns: 1fr; flex: 1; overflow: auto; }
		#bottom-avatar-actions { display: grid; gap: 8px; grid-template-columns: minmax(0,1fr) auto auto; align-items: center; }
		#bottom-avatar-content .row { display: flex; gap: 8px; align-items: center; }
		#bottom-avatar-content input[type="range"] {
			flex: 1; padding: 0; background: rgba(255,255,255,0.06);
		}
		#bottom-avatar-content .btn {
			padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
			font-size: 12px; letter-spacing: 1px; border-radius: 6px; cursor: pointer;
		}
		#bottom-avatar-content .btn:hover { background: #fff; color: #000; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "butterchurn": "https://esm.sh/butterchurn@2.6.0",
                "butterchurn-presets": "https://esm.sh/butterchurn-presets@2.4.7",
                "lodash": "https://esm.sh/lodash@4.17.21"
            }
        }
    </script>
</head>
<body>

    <!-- START SCREEN -->
	<div id="overlay" class="no-blur bg-lite">
		<h1 id="logo-omni" data-text="OMNI&gt;"><span class="logo-letter logo-o">O</span><span class="logo-letter logo-m">M</span><span class="logo-letter">N</span><span class="logo-letter logo-start">I</span><span class="logo-letter logo-start">&gt;</span></h1>
		<!-- Toggle URL input (shown via clicking 'N' in OMNI>) -->
		<div id="url-flyover" class="is-hidden">
            <input type="text" id="radio-url" class="radio-input interactive" value="https://stream.bigfm.de/tomorrowland/mp3-128/" placeholder="Paste Stream URL">
        </div>

        <div class="control-group">
            <input type="file" id="file-input" accept="audio/*" style="display:none">
        </div>

        <div id="loading-status">Select a source to begin</div>
        <div id="shortcuts-status"></div>
    </div>
    <!-- Mic confirmation modal -->
    <div id="mic-confirm">
        <div class="panel">
            <div class="title">Microphone Audio Input?</div>
            <div class="desc">This will request access to your microphone and use it as the audio source.</div>
            <div class="actions">
                <button id="btn-mic-ok" class="btn">Okay</button>
                <button id="btn-mic-cancel" class="btn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- HUD (Fades out when idle) -->
    <div id="ui-layer" class="hidden">
        <div class="nav-btn interactive" id="btn-prev">â®</div>

        <div class="center-controls">
            <!-- SKIP PRESET BUTTON (Only for ProjectM) -->
            <button class="icon-btn interactive display-none" id="btn-skip-preset" title="Next Visual Preset">â­</button>
            <!-- WEBM TOGGLE -->
            <button class="icon-btn interactive" id="btn-webm" title="Toggle WebM Overlay">ðŸŽ›ï¸</button>

            <!-- TITLE INFO -->
            <div id="mode-info">
                <span id="mode-title">INIT</span>
                <span id="mode-sub">Engine Ready</span>
            </div>

            <!-- SETTINGS BUTTON -->
            <button class="icon-btn interactive" id="btn-settings" title="Visualizer Settings">ðŸŽšï¸</button>
            <button class="icon-btn interactive" id="btn-webm-panel-toggle" title="Avatar Settings">ðŸ’ƒ</button>
            
        </div>

        <div class="nav-btn interactive" id="btn-next">â¯</div>
    </div>

    <div id="canvas-container"></div>
    <audio id="radio-element" crossorigin="anonymous"></audio>
    <audio id="radio-element-b" crossorigin="anonymous"></audio>
	<!-- Top bar aligns shuffle, volume, and radio controls -->
	<div id="top-bar" class="display-none"></div>
	<!-- Top Menu Panel -->
	<div id="top-menu-panel" class="display-none">
		<div id="top-menu-content">
			<!-- Scrollable Radio Stations List (migrated from Radio Panel) -->
			<div id="top-menu-stations" style="flex:1; overflow:auto; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 8px; background: rgba(255,255,255,0.04);">
				<div id="radio-list"></div>
			</div>
			<!-- Single-row visualization sliders (minimal labels), above volume slider -->
			<div class="row" style="display:grid; grid-template-columns: auto 1fr auto 1fr auto 1fr auto 1fr; gap:10px; align-items:center; margin-top:8px; width:100%;">
				<label for="tm-inp-shuffle-min" style="font-size:11px; color:#ccc; min-width:28px; text-align:right">Min</label>
				<input id="tm-inp-shuffle-min" type="range" min="3" max="120" step="1" value="30" style="width:100%;">
				<label for="tm-inp-shuffle-max" style="font-size:11px; color:#ccc; min-width:28px; text-align:right">Max</label>
				<input id="tm-inp-shuffle-max" type="range" min="5" max="180" step="1" value="60" style="width:100%;">
				<label for="tm-inp-transition" style="font-size:11px; color:#ccc; min-width:36px; text-align:right">Trans</label>
				<input id="tm-inp-transition" type="range" min="0" max="10" step="0.1" value="2.7" style="width:100%;">
				<label for="tm-inp-pixelratio" style="font-size:11px; color:#ccc; min-width:20px; text-align:right">PR</label>
				<input id="tm-inp-pixelratio" type="range" min="0.5" max="3" step="0.1" value="1" style="width:100%;">
			</div>
			<div id="top-menu-actions">
				<button class="btn" id="topmenu-prev-station" title="Previous Station">âŸµ Station</button>
				<button class="btn" id="topmenu-next-station" title="Next Station">Station âŸ¶</button>
				<button class="btn" id="topmenu-prev-visual" title="Previous Visual">âŸµ Visual</button>
				<button class="btn" id="topmenu-next-visual" title="Next Visual">Visual âŸ¶</button>
			</div>
			<!-- footer with volume slider will be appended below -->
		</div>
		<div id="top-menu-footer">
			<div id="volume-slider-container" class="interactive">
				<input id="volume-slider" type="range" min="0" max="1" step="0.01" value="0.2">
			</div>
		</div>
	</div>
	<!-- Bottom Avatar Menu Panel -->
	<div id="bottom-avatar-panel" class="display-none">
		<div id="bottom-avatar-header">
			<div style="display:flex; gap:10px; align-items:center">
				<h3>WEBMâ–¹</h3>
				<select id="avatar-webm-select"></select>
				<button class="btn" id="avatar-webm-open" title="Open selected WebM">â–¶</button>
				<div style="display:flex; gap:6px;">
					<button class="btn" id="avatar-webm-prev" title="Prev WebM">âŸ¨</button>
					<button class="btn" id="avatar-webm-next" title="Next WebM">âŸ©</button>
				</div>
			</div>
			<div style="display:flex; gap:8px; align-items:center">
				<button class="btn" id="avatar-btn-auto" title="Toggle random WebM (30-60s)">Auto</button>
				<button class="btn" id="avatar-btn-reset" title="Reset to defaults">âŽ‹</button>
				<button class="btn" id="btn-bottommenu-close" title="Close">âœ•</button>
			</div>
		</div>
		<div id="bottom-avatar-content">
			<div class="row">
				<label for="avatar-inp-scale" style="min-width:120px; font-size:12px; color:#ccc">Size (vw)</label>
				<input id="avatar-inp-scale" type="range" min="10" max="200" step="1" value="50">
			</div>
			<div class="row">
				<label for="avatar-inp-x" style="min-width:120px; font-size:12px; color:#ccc">X (vw)</label>
				<input id="avatar-inp-x" type="range" min="0" max="100" step="1" value="50">
			</div>
			<div class="row">
				<label for="avatar-inp-y" style="min-width:120px; font-size:12px; color:#ccc">Y (vh)</label>
				<input id="avatar-inp-y" type="range" min="0" max="100" step="1" value="50">
			</div>
			<div class="row">
				<label for="avatar-inp-rot" style="min-width:120px; font-size:12px; color:#ccc">Rotate (deg)</label>
				<input id="avatar-inp-rot" type="range" min="-180" max="180" step="1" value="0">
			</div>
			<div class="row">
				<label for="avatar-inp-speed" style="min-width:120px; font-size:12px; color:#ccc">Speed</label>
				<input id="avatar-inp-speed" type="range" min="0.1" max="4" step="0.1" value="1.0">
			</div>
			<div class="row">
				<label for="avatar-inp-opacity" style="min-width:120px; font-size:12px; color:#ccc">Opacity</label>
				<input id="avatar-inp-opacity" type="range" min="0" max="1" step="0.01" value="0.82">
			</div>
			<div class="row">
				<label for="avatar-inp-dup" style="min-width:120px; font-size:12px; color:#ccc">Duplicates (0-2)</label>
				<input id="avatar-inp-dup" type="range" min="0" max="2" step="1" value="0">
			</div>
		</div>
	</div>
    <!-- Quick Radio Button and old Radio Panel removed (assets retained) -->
    <div id="station-banner" class="display-none"></div>
    <!-- Rising text overlay layer -->
    <div id="text-overlay-layer"></div>
    <!-- Text-In Panel -->
    <div id="textin-panel" class="display-none" aria-label="Text-In Panel">
        <h3>
            <span>TEXT-IN</span>
            <div style="display:flex; align-items:center; gap:8px; margin-left:auto; margin-right:8px">
                <button class="icon-btn interactive" id="btn-textin-close" title="Close" aria-label="Close">âœ•</button><button class="textin-btn interactive" id="ti-send">Send</button>
                <button class="textin-btn interactive" id="ti-auto">Auto</button>
<input type="number" class="textin-num" id="ti-auto-interval" value="1000" min="100" step="100" title="Auto interval (ms)">
            </div>
            
        </h3>
        <div id="textin-content">
            <div class="textin-row">
                <div class="textin-label">Text</div>
                <input type="text" id="ti-text" class="textin-input" value="LuckyðŸ€Radio" placeholder="Your message...">
            </div>
            <div class="textin-row">
                <div class="textin-label">Font</div>
                <select id="ti-font" class="textin-select">
                    <option value="'Segoe UI', sans-serif">Segoe UI</option>
                    <option value="Arial, Helvetica, sans-serif">Arial</option>
                    <option value="'Courier New', Courier, monospace">Courier New</option>
                    <option value="'Times New Roman', Times, serif">Times New Roman</option>
                    <option value="Georgia, 'Times New Roman', serif">Georgia</option>
                    <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                    <option value="Roboto, sans-serif">Roboto</option>
                    <option value="Oswald, sans-serif">Oswald</option>
                    <option value="Montserrat, sans-serif">Montserrat</option>
                    <option value="Raleway, sans-serif">Raleway</option>
                    <option value="Poppins, sans-serif">Poppins</option>
                    <option value="Orbitron, sans-serif">Orbitron</option>
                    <option value="Audiowide, cursive">Audiowide</option>
                    <option value="'Share Tech Mono', monospace">Share Tech Mono</option>
                    <option value="VT323, monospace">VT323</option>
                    <option value="Electrolize, sans-serif">Electrolize</option>
                    <option value="Oxanium, cursive">Oxanium</option>
                    <option value="Quantico, sans-serif">Quantico</option>
                    <option value="Syncopate, sans-serif">Syncopate</option>
                    <option value="'Exo 2', sans-serif">Exo 2</option>
                    <option value="'Chakra Petch', sans-serif">Chakra Petch</option>
                    <option value="Teko, sans-serif">Teko</option>
                    <option value="Sarpanch, sans-serif">Sarpanch</option>
                    <option value="'Major Mono Display', monospace">Major Mono Display</option>
                    <option value="Monoton, cursive">Monoton</option>
                    <option value="Quicksilver, cursive">Quicksilver</option>
                    <option value="'Playfair Display', serif">Playfair Display</option>
                    <option value="Lobster, cursive" selected>Lobster</option>
                    <option value="'Open Sans', sans-serif">Open Sans</option>
                    <option value="Nunito, sans-serif">Nunito</option>
                    <option value="Merriweather, serif">Merriweather</option>
                    <option value="Rubik, sans-serif">Rubik</option>
                    <option value="Inter, sans-serif">Inter</option>
                    <option value="'Fira Sans', sans-serif">Fira Sans</option>
                    <option value="'Fira Mono', monospace">Fira Mono</option>
                    <option value="Inconsolata, monospace">Inconsolata</option>
                    <option value="'Source Code Pro', monospace">Source Code Pro</option>
                    <option value="'Press Start 2P', cursive">Press Start 2P</option>
                </select>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb; margin-left:8px">
                    <input type="checkbox" id="ti-font-rand" title="Random Font" checked>
                </label>
            </div>
            <div class="textin-row">
                <div class="textin-label">Color</div>
                <input type="color" id="ti-color" class="textin-color" value="#ffffff">
                <button id="ti-color-rand" class="btn-mini" title="Random color">ðŸŽ²</button>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
                    <input type="checkbox" id="ti-color-rand-check" checked title="Random Color">
                </label>
                <div class="textin-label">Size</div>
                <div class="slider-col">
                    <input type="range" id="ti-size" class="textin-range main-range" min="16" max="200" value="64">
                    <div class="range-sub">
                        <input type="range" id="ti-size-rmin" class="textin-range sub-range" min="16" max="200" value="16" step="1" title="Min Size">
                        <input type="range" id="ti-size-rmax" class="textin-range sub-range" min="16" max="200" value="200" step="1" title="Max Size">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
                    <input type="checkbox" id="ti-size-rand" checked title="Random Size">
                </label>
            </div>
            <div class="textin-row">
                <div class="textin-label">X Position</div>
                <div class="slider-col">
                    <input type="range" id="ti-x" class="textin-range main-range" min="0" max="100" value="50">
                    <div class="range-sub">
                        <input type="range" id="ti-x-rmin" class="textin-range sub-range" min="0" max="100" value="0" step="1" title="Min X (%)">
                        <input type="range" id="ti-x-rmax" class="textin-range sub-range" min="0" max="100" value="100" step="1" title="Max X (%)">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
                    <input type="checkbox" id="ti-x-rand" checked title="Random X">
                </label>
            </div>
            <div class="textin-row">
                <div class="textin-label">Border</div>
                <div class="slider-col">
                    <input type="range" id="ti-border" class="textin-range main-range" min="0" max="10" value="2">
                    <div class="range-sub">
                        <input type="range" id="ti-border-rmin" class="textin-range sub-range" min="0" max="10" value="0" step="1" title="Min Border">
                        <input type="range" id="ti-border-rmax" class="textin-range sub-range" min="0" max="10" value="10" step="1" title="Max Border">
                    </div>
                </div>
                <input type="color" id="ti-border-color" class="textin-color" value="#000000">
                <button id="ti-border-color-rand" class="btn-mini" title="Random border color">ðŸŽ²</button>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
                    <input type="checkbox" id="ti-border-color-rand-check" title="Random Border Color" checked>
                </label>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
                    <input type="checkbox" id="ti-border-rand" title="Random Border">
                </label>
            </div>
            <div class="textin-row">
                <div class="textin-label">Glow</div>
                <div class="slider-col">
                    <input type="range" id="ti-glow" class="textin-range main-range" min="0" max="50" value="12">
                    <div class="range-sub">
                        <input type="range" id="ti-glow-rmin" class="textin-range sub-range" min="0" max="50" value="0" step="1" title="Min Glow">
                        <input type="range" id="ti-glow-rmax" class="textin-range sub-range" min="0" max="50" value="50" step="1" title="Max Glow">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb; margin-left:8px">
                    <input type="checkbox" id="ti-glow-rand" title="Random Glow">
                </label>
                <input type="color" id="ti-glow-color" class="textin-color" value="#00ffff" title="Glow Color">
                <button id="ti-glow-color-rand" class="btn-mini" title="Random glow color">ðŸŽ²</button>
<label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb">
    <input type="checkbox" id="ti-glow-color-rand-check" title="Random Glow Color" checked>
</label>
            </div>

            <div class="textin-row">
                <div class="textin-label">Flashing</div>
                <input type="checkbox" id="ti-flash">
                <div class="textin-label">Flash Speed</div>
                <div class="slider-col">
                    <input type="range" id="ti-flash-speed" class="textin-range main-range" min="0" max="5" value="1" step="0.1">
                    <div class="range-sub">
                        <input type="range" id="ti-flashspeed-rmin" class="textin-range sub-range" min="0" max="5" value="0" step="0.1" title="Min Flash Speed">
                        <input type="range" id="ti-flashspeed-rmax" class="textin-range sub-range" min="0" max="5" value="5" step="0.1" title="Max Flash Speed">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb; margin-left:8px">
                    <input type="checkbox" id="ti-flashspeed-rand" title="Random Flash Speed">
                </label>
            </div>
            <div class="textin-row">
                <div class="textin-label">Rise Speed</div>
                <div class="slider-col">
                    <input type="range" id="ti-speed" class="textin-range main-range" min="25" max="800" value="25">
                    <div class="range-sub">
                        <input type="range" id="ti-speed-rmin" class="textin-range sub-range" min="25" max="800" value="25" step="1" title="Min Rise Speed">
                        <input type="range" id="ti-speed-rmax" class="textin-range sub-range" min="25" max="800" value="800" step="1" title="Max Rise Speed">
                    </div>
                </div>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#bbb; margin-left:8px">
                    <input type="checkbox" id="ti-speed-rand" title="Random Speed" checked>
                </label>
            </div>
            <div id="textin-preview-wrap">
                <div id="textin-preview">Preview</div>
            </div>
        </div>
    </div>
    <div id="mix-panel" class="display-none" aria-label="Mix Settings">
        <h3 style="display:flex; align-items:center; gap:12px; padding: 12px 14px;">
            <div style="flex:1; display:flex; align-items:center; gap:8px;">
                <span style="font-size:12px; color:#888; font-weight:bold">A</span>
                <input type="range" id="mix-crossfader" min="0" max="1" step="0.01" value="0" style="width:100%; cursor:pointer;">
                <span style="font-size:12px; color:#888; font-weight:bold">B</span>
            </div>

            <button class="icon-btn interactive" id="btn-mix-close" title="Close" aria-label="Close">âœ•</button>
        </h3>
        
        <div style="display:grid; grid-template-columns: 1fr; gap: 2px; align-items:flex-start; margin-bottom:12px">
                <div>
                    <div style="display:flex; flex-wrap:wrap; align-items:center; gap:10px; margin-bottom:6px">
                        <div style="font-size:12px; color:#bbb">Second Stationâ¤µ</div>
                        <button class="btn" id="mix-b-play">Play B</button>
                        <button class="btn" id="mix-b-stop">Stop B</button>
                        <div class="status-row" style="margin:0; display:flex; align-items:center; gap:6px">
                            <div id="mix-b-status-dot" class="status-dot"></div>
                            <div id="mix-b-status-text">B: Stopped</div>
                        </div>
                    </div>

                    <select id="mix-station-b" class="textin-select" style="width: 100%"></select>

                    <div class="eq-strip">
                        
                        <div class="eq-group">
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-a-low" style="--knob-color:#0ff">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Lo</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-a-mid" style="--knob-color:#0ff">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Mid</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-a-high" style="--knob-color:#0ff">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Hi</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-a-gain" style="--knob-color:#0ff">
                                    <div class="knob-indicator"></div><div class="knob-value">1.0</div>
                                </div>
                                <div class="eq-label" style="color:#0ff">Gain</div>
                            </div>
                        </div>
                        
                        <div class="eq-divider"></div>

                        <div class="eq-group">
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-b-gain" style="--knob-color:#f0f">
                                    <div class="knob-indicator"></div><div class="knob-value">1.0</div>
                                </div>
                                <div class="eq-label" style="color:#f0f">Gain</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-b-high" style="--knob-color:#f0f">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Hi</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-b-mid" style="--knob-color:#f0f">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Mid</div>
                            </div>
                            <div class="eq-col">
                                <div class="knob-wrap" id="knob-b-low" style="--knob-color:#f0f">
                                    <div class="knob-indicator"></div><div class="knob-value">0</div>
                                </div>
                                <div class="eq-label">Lo</div>
                            </div>
                        </div>
                    </div>
                    </div>
            </div>

            <div>
                
                <div id="mix-effects">
                    <button class="btn" id="fx-wav4" title="Left-click: play once â€¢ Right-click: loop">WaaðŸ“¯</button>
                    <button class="btn" id="fx-wav5" title="Left-click: play once â€¢ Right-click: loop">WaaaðŸ“£</button>
                    <button class="btn" id="fx-wav6" title="Left-click: play once â€¢ Right-click: loop">AirðŸ“¢</button>
                    <button class="btn" id="fx-lowpass">Low-pass</button>
                    <button class="btn" id="fx-bass">Bass-Boost</button>
                    <button class="btn" id="fx-echo">~Echo~</button>
                    <button class="btn" id="fx-highpass">High-pass</button>
                    <button class="btn" id="fx-treble">Treble-Boost</button>
                    <button class="btn" id="fx-distort">Distortion</button>
                    <button class="btn" id="fx-arp">Arpeggiator</button>
                    <button class="btn" id="fx-tk">TK-Filter</button>
                    <button class="btn" id="fx-wav" title="Left-click: play once â€¢ Right-click: loop">ðŸ’­ðŸ’¡</button>
                    <button class="btn" id="fx-wav1" title="Left-click: play once â€¢ Right-click: loop">fx-1</button>
                    <button class="btn" id="fx-wav2" title="Left-click: play once â€¢ Right-click: loop">fx-2</button>
                    <button class="btn" id="fx-wav3" title="Left-click: play once â€¢ Right-click: loop">fx-3</button>
                </div>
            </div>

        </div>
    </div>
    
    <!-- WebM Overlay + Nav -->
    <div id="webm-overlay" class="display-none">
        <video id="webm-video" muted loop playsinline></video>
        <video id="webm-video-left" muted loop playsinline class="display-none"></video>
        <video id="webm-video-right" muted loop playsinline class="display-none"></video>
    </div>
    <button id="webm-prev" class="webm-nav display-none" title="Previous video">â®</button>
    <button id="webm-next" class="webm-nav display-none" title="Next video">â¯</button>
    
    <!-- Settings Panel -->
    <div id="settings-panel" class="display-none">
        <h3>Visualizer Settings</h3>
        <div id="settings-content">
            <div class="settings-row">
                <label for="inp-shuffle-min">Shuffle min (s)</label>
                <input id="inp-shuffle-min" type="range" min="3" max="120" step="1" value="30">
            </div>
            <div class="settings-row">
                <label for="inp-shuffle-max">Shuffle max (s)</label>
                <input id="inp-shuffle-max" type="range" min="5" max="180" step="1" value="60">
            </div>
            <div class="settings-row">
                <label for="inp-transition">Transition (s)</label>
                <input id="inp-transition" type="range" min="0" max="10" step="0.1" value="2.7">
            </div>
            <div class="settings-row">
                <label for="inp-pixelratio">Pixel Ratio</label>
                <input id="inp-pixelratio" type="range" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="settings-note">Settings apply to ProjectM v2. Shuffle times are randomized between min and max. Transition affects preset morph duration. Pixel ratio applies on next init.</div>
            <div class="settings-actions">
                <button class="btn-small" id="btn-settings-apply">Apply</button>
                <button class="btn-small" id="btn-settings-close">Close</button>
            </div>
        </div>
    </div>
    
    <!-- WebM Settings Panel -->
    <div id="webm-settings-panel" class="display-none">
        <div class="panel-head">
            <h3>AVATAR SETTINGS</h3>
            <div style="display:flex; gap:8px; align-items:center">
                <button class="btn-small" id="btn-webm-auto" title="Toggle random WebM (30-60s)">Auto</button>
                <button class="btn-small" id="btn-webm-reset" title="Reset to defaults">âŽ‹</button>
                <button class="icon-btn interactive" id="btn-webm-close" title="Close" aria-label="Close" onclick="hideWebmSettingsPanel && hideWebmSettingsPanel()">âœ•</button>
            </div>
        </div>
        <div id="webm-settings-content">
            <div class="settings-row">
                <label for="inp-webm-scale">Size (vw)</label>
                <input id="inp-webm-scale" type="range" min="10" max="200" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-x">X (vw)</label>
                <input id="inp-webm-x" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-y">Y (vh)</label>
                <input id="inp-webm-y" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-rot">Rotate (deg)</label>
                <input id="inp-webm-rot" type="range" min="-180" max="180" step="1" value="0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-speed">Speed</label>
                <input id="inp-webm-speed" type="range" min="0.1" max="4" step="0.1" value="1.0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-opacity">Opacity</label>
                <input id="inp-webm-opacity" type="range" min="0" max="1" step="0.01" value="0.82">
            </div>
            <div class="settings-row">
                <label for="inp-webm-dup">Duplicates (0-2)</label>
                <input id="inp-webm-dup" type="range" min="0" max="2" step="1" value="0">
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        import butterchurn from 'butterchurn';
        import butterchurnPresets from 'butterchurn-presets';

        // --- GLOBAL STATE ---
        const state = {
            audioCtx: null,
            sourceNode: null,
            analyserNode: null,
            isPlaying: false,
            currentModeIdx: 0,
            activeVisualizer: null,
            idleTimer: null,
            mediaStream: null
        };

        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('loading-status');
        const uiLayer = document.getElementById('ui-layer');
        const radioQuickBtn = document.getElementById('radio-quick');
        const radioPanel = document.getElementById('radio-panel');
        const radioListEl = document.getElementById('radio-list');
        const radioInputEl = document.getElementById('radio-url') || document.getElementById('station-url');
        const audioEl = document.getElementById('radio-element');
        const audioElB = document.getElementById('radio-element-b');
        const stationBanner = document.getElementById('station-banner');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsBtn = document.getElementById('btn-settings');
        const settingsApplyBtn = document.getElementById('btn-settings-apply');
        const settingsCloseBtn = document.getElementById('btn-settings-close');
        // Text-In refs/state
        const textInPanel = document.getElementById('textin-panel');
        const textOverlayLayer = document.getElementById('text-overlay-layer');
        const tiText = document.getElementById('ti-text');
        const tiFont = document.getElementById('ti-font');
        const tiFontRand = document.getElementById('ti-font-rand');
        const tiColor = document.getElementById('ti-color');
        const tiColorRandBtn = document.getElementById('ti-color-rand');
        const tiColorRandCheck = document.getElementById('ti-color-rand-check');
        const tiSize = document.getElementById('ti-size');
        const tiSizeRand = document.getElementById('ti-size-rand');
        const tiSizeRMin = document.getElementById('ti-size-rmin');
        const tiSizeRMax = document.getElementById('ti-size-rmax');
        const tiX = document.getElementById('ti-x');
        const tiXRand = document.getElementById('ti-x-rand');
        const tiXRMin = document.getElementById('ti-x-rmin');
        const tiXRMax = document.getElementById('ti-x-rmax');
        const tiBorder = document.getElementById('ti-border');
        const tiBorderColor = document.getElementById('ti-border-color');
        const tiBorderColorRandBtn = document.getElementById('ti-border-color-rand');
        const tiBorderColorRandCheck = document.getElementById('ti-border-color-rand-check');
        const tiBorderRand = document.getElementById('ti-border-rand');
        const tiBorderRMin = document.getElementById('ti-border-rmin');
        const tiBorderRMax = document.getElementById('ti-border-rmax');
        const tiGlowRand = document.getElementById('ti-glow-rand');
        const tiGlowColor = document.getElementById('ti-glow-color');
        const tiGlowColorRandBtn = document.getElementById('ti-glow-color-rand');
        const tiGlowColorRandCheck = document.getElementById('ti-glow-color-rand-check');
        const tiGlowRMin = document.getElementById('ti-glow-rmin');
        const tiGlowRMax = document.getElementById('ti-glow-rmax');
        const tiFlashSpeedRand = document.getElementById('ti-flashspeed-rand');
        const tiFlashSpeedRMin = document.getElementById('ti-flashspeed-rmin');
        const tiFlashSpeedRMax = document.getElementById('ti-flashspeed-rmax');
        const tiSpeedRand = document.getElementById('ti-speed-rand');
        const tiSpeedRMin = document.getElementById('ti-speed-rmin');
        const tiSpeedRMax = document.getElementById('ti-speed-rmax');
        const tiGlow = document.getElementById('ti-glow');
        const tiFlash = document.getElementById('ti-flash');
        const tiFlashSpeed = document.getElementById('ti-flash-speed');
        const tiSpeed = document.getElementById('ti-speed');
        const tiPreview = document.getElementById('textin-preview');
        const tiSend = document.getElementById('ti-send');
        const tiAutoBtn = document.getElementById('ti-auto');
        const tiAutoInterval = document.getElementById('ti-auto-interval');
        const tiClose = document.getElementById('btn-textin-close');
        let textOverlayAnimId = null;
        const activeTextOverlays = [];
        let shortcutsLocked = false;
        let textAutoTimer = null;
        let textAutoOn = false;
        // Mix panel refs
        const micConfirm = document.getElementById('mic-confirm');
        const micOk = document.getElementById('btn-mic-ok');
        const micCancel = document.getElementById('btn-mic-cancel');
        const mixPanel = document.getElementById('mix-panel');
        const mixClose = document.getElementById('btn-mix-close');
        const fxLow = document.getElementById('fx-lowpass');
        const fxHigh = document.getElementById('fx-highpass');
        const fxBass = document.getElementById('fx-bass');
        const fxTreble = document.getElementById('fx-treble');
        const fxEcho = document.getElementById('fx-echo');
        const fxDist = document.getElementById('fx-distort');
        const fxArp = document.getElementById('fx-arp');
        const fxTk = document.getElementById('fx-tk');
        const fxWav = document.getElementById('fx-wav');
        const fxWav1 = document.getElementById('fx-wav1');
        const fxWav2 = document.getElementById('fx-wav2');
        const fxWav3 = document.getElementById('fx-wav3');
        const fxWav4 = document.getElementById('fx-wav4');
        const fxWav5 = document.getElementById('fx-wav5');
        const fxWav6 = document.getElementById('fx-wav6');
        const mixStationB = document.getElementById('mix-station-b');
        const mixPlayB = document.getElementById('mix-b-play');
        const mixStopB = document.getElementById('mix-b-stop');
        const mixCross = document.getElementById('mix-crossfader');
        // Sample player
        const audioElSample = new Audio();
        audioElSample.preload = 'auto';
        audioElSample.src = 'wav.mp3';
        const audioElSample1 = new Audio();
        audioElSample1.preload = 'auto';
        audioElSample1.src = 'wav1.mp3';
        const audioElSample2 = new Audio();
        audioElSample2.preload = 'auto';
        audioElSample2.src = 'wav2.mp3';
        const audioElSample3 = new Audio();
        audioElSample3.preload = 'auto';
        audioElSample3.src = 'wav3.mp3';
        const audioElSample4 = new Audio();
        audioElSample4.preload = 'auto';
        audioElSample4.src = 'wav4.mp3';
        const audioElSample5 = new Audio();
        audioElSample5.preload = 'auto';
        audioElSample5.src = 'wav5.mp3';
        const audioElSample6 = new Audio();
        audioElSample.preload = 'auto';
        audioElSample6.src = 'wav6.mp3';
        let sampleLoop = false, sampleLoop1 = false, sampleLoop2 = false, sampleLoop3 = false;
        // Ensure media elements don't double-play outside the WebAudio graph
        // Allow HTML elements to output so MediaElementSource has signal; mixing is controlled in WebAudio
        try { audioEl.muted = false; } catch(_) {}
        try { audioElB.muted = false; } catch(_) {}
        try { audioElSample.muted = false; } catch(_) {}
        try { audioElSample1.muted = false; } catch(_) {}
        try { audioElSample2.muted = false; } catch(_) {}
        try { audioElSample3.muted = false; } catch(_) {}
        // Element volume at 1 so MediaElementSourceNode receives full-strength signal
        try { audioEl.volume = 1; } catch(_) {}
        try { audioElB.volume = 1; } catch(_) {}
        try { audioElSample.volume = 1; } catch(_) {}
        try { audioElSample1.volume = 1; } catch(_) {}
        try { audioElSample2.volume = 1; } catch(_) {}
        try { audioElSample3.volume = 1; } catch(_) {}
        const mixBStatusDot = document.getElementById('mix-b-status-dot');
        const mixBStatusText = document.getElementById('mix-b-status-text');
        function updateMixBStatus() {
            // Check the active dynamic audio object first, fallback to the static element
            const activeB = state.audioElB || audioElB;
            
            const playing = !!(
                (activeB && !activeB.paused && !activeB.ended) ||
                (audioElSample && !audioElSample.paused && !audioElSample.ended) ||
                (audioElSample1 && !audioElSample1.paused && !audioElSample1.ended) ||
                (audioElSample2 && !audioElSample2.paused && !audioElSample2.ended) ||
                (audioElSample3 && !audioElSample3.paused && !audioElSample3.ended) ||
                (audioElSample4 && !audioElSample4.paused && !audioElSample4.ended) ||
                (audioElSample5 && !audioElSample5.paused && !audioElSample5.ended) ||
                (audioElSample6 && !audioElSample6.paused && !audioElSample6.ended)
            );
            
            if (mixBStatusDot) mixBStatusDot.classList.toggle('on', playing);
            if (mixBStatusText) mixBStatusText.textContent = playing ? 'B: Playing' : 'B: Stopped';
        }
        const inpShuffleMin = document.getElementById('inp-shuffle-min');
        const inpShuffleMax = document.getElementById('inp-shuffle-max');
        const inpTransition = document.getElementById('inp-transition');
        const inpPixelRatio = document.getElementById('inp-pixelratio');
        const webmOverlayEl = document.getElementById('webm-overlay');
        const webmVideoEl = document.getElementById('webm-video');
        const webmVideoLeftEl = document.getElementById('webm-video-left');
        const webmVideoRightEl = document.getElementById('webm-video-right');
        const webmBtn = document.getElementById('btn-webm');
        const webmPrevBtn = document.getElementById('webm-prev');
        const webmNextBtn = document.getElementById('webm-next');
        const webmSettingsPanel = document.getElementById('webm-settings-panel');
        const webmCloseBtn = document.getElementById('btn-webm-close');
        const inpWebmScale = document.getElementById('inp-webm-scale');
        const inpWebmX = document.getElementById('inp-webm-x');
        const inpWebmY = document.getElementById('inp-webm-y');
        const inpWebmRot = document.getElementById('inp-webm-rot');
        const inpWebmSpeed = document.getElementById('inp-webm-speed');
        const inpWebmOpacity = document.getElementById('inp-webm-opacity');
        const inpWebmDup = document.getElementById('inp-webm-dup');
        const stations = [];
        // Volume slider
        const volumeSlider = document.getElementById('volume-slider');
        const topBar = document.getElementById('top-bar');
        const shuffleToggle = document.getElementById('shuffle-toggle');
        let currentStationIndex = -1;
        let currentStationBIndex = 0;
        // Keep up to 5 most recent stations to enable true "previous" navigation
        let stationHistory = [];
        // Guard to avoid pushing into history when navigating back
        let suppressHistoryPush = false;
        let panelIdleTimer = null;
        let webmList = [];
        let webmIndex = 0;
        let webmOn = false;
        let radioPanelTimer = null;
        let settingsPanelTimer = null;
        let webmSettingsTimer = null;
        let stationBannerTimer = null;
        // Hold the radio button visible after right-click random selection
        let radioQuickHoldUntil = 0;
        let radioQuickHoldTimeout = null;
        // Guard to suppress unintended overlay-start when opening local file via "O"
        let suppressNextOverlayStartUntil = 0;
        const webmSettings = {
            scaleVw: 50,
            posXvw: 50,
            posYvh: 50,
            rotationDeg: 0,
            playbackRate: 1.0,
            opacity: 0.82,
            duplicates: 0
        };
        // EQ State Storage
        const eqState = {
            a: { gain: 1.0, high: 0, mid: 0, low: 0 },
            b: { gain: 1.0, high: 0, mid: 0, low: 0 }
        };

        // Helper to bind a visual knob to a value and callback
        // Helper to bind a visual knob to a value and callback
        function bindKnob(id, min, max, initial, stateObj, key, callback) {
            const el = document.getElementById(id);
            if (!el) return;
            const indicator = el.querySelector('.knob-indicator');
            const valTooltip = el.querySelector('.knob-value');
            
            // FIX: Start at 45deg (Bottom-Left) and sweep 270deg to 315deg (Bottom-Right)
            // This rotates the whole logic 180 degrees compared to before.
            const updateVisuals = (val) => {
                const pct = (val - min) / (max - min);
                const deg = 45 + (pct * 270); 
                if (indicator) indicator.style.transform = `translate(-50%, 0) rotate(${deg}deg)`;
                if (valTooltip) valTooltip.textContent = (Math.round(val * 10) / 10);
            };

            // Set initial
            stateObj[key] = initial;
            updateVisuals(initial);

            // Drag Interaction
            let startY = 0;
            let startVal = 0;

            const onMove = (e) => {
                const y = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                const dy = startY - y; // Drag up = positive
                const range = max - min;
                const delta = (dy / 200) * range; 
                let newVal = Math.max(min, Math.min(max, startVal + delta));
                
                stateObj[key] = newVal;
                updateVisuals(newVal);
                if (callback) callback(newVal);
            };

            const onUp = () => {
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('touchmove', onMove);
                window.removeEventListener('mouseup', onUp);
                window.removeEventListener('touchend', onUp);
            };

            const onDown = (e) => {
                e.preventDefault();
                startY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
                startVal = stateObj[key];
                window.addEventListener('mousemove', onMove);
                window.addEventListener('touchmove', onMove, {passive: false});
                window.addEventListener('mouseup', onUp);
                window.addEventListener('touchend', onUp);
            };

            el.addEventListener('mousedown', onDown);
            el.addEventListener('touchstart', onDown, {passive: false});
            
            el.addEventListener('dblclick', () => {
                const def = (key === 'gain') ? 1.0 : 0;
                stateObj[key] = def;
                updateVisuals(def);
                if (callback) callback(def);
            });
        }
        // Radio retry policy
        let radioRetryAttempts = 0;
        const MAX_RADIO_RETRIES = 6;
        // WebM auto-random toggle
        let webmAutoOn = false;
        let webmAutoTimer = null;
		// Bottom text color history (avoid immediate repeats)
		let recentBottomColors = [];
		// Overlay glow color cycler
		let overlayGlowCycleCount = 0;
		let overlayGlowListenerBound = false;
		let overlayGlowColorTimer = null;
		const overlayGlowDurationMs = 2400; // must match CSS animation duration
		function randomHexColor() {
			return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
		}
		// Typed status text effect
		let statusTypeTimer = null;
		function typeStatus(text, onDone) {
			const el = document.getElementById('loading-status');
			if (!el) return;
			if (statusTypeTimer) { try { clearTimeout(statusTypeTimer); } catch(e) {} statusTypeTimer = null; }
			const full = String(text || '');
			el.innerText = '';
			let i = 0;
			const step = () => {
				el.innerText = full.slice(0, i);
				try { if (typeof layoutOverlayElements === 'function') layoutOverlayElements(); } catch(e) {}
				i++;
				if (i <= full.length) {
					statusTypeTimer = setTimeout(step, 60);
				} else {
					try { if (typeof onDone === 'function') onDone(); } catch(e) {}
				}
			};
			step();
		}
function randomGlowColor() {
    const h = Math.floor(Math.random() * 360);
    return `hsl(${h}, 90%, 60%)`;
}
		// Generic typewriter for any element id
		let shortcutsTypeTimer = null;
		function typeStatusTo(elId, text, speed) {
			const el = document.getElementById(elId);
			if (!el) return;
			const useSpeed = typeof speed === 'number' ? speed : 50;
			// separate timer for shortcuts line to avoid interference
			if (elId === 'shortcuts-status' && shortcutsTypeTimer) { try { clearTimeout(shortcutsTypeTimer); } catch(e) {} shortcutsTypeTimer = null; }
			const full = String(text || '');
			el.innerText = '';
			let i = 0;
			const step = () => {
				el.innerText = full.slice(0, i);
				try { if (typeof layoutOverlayElements === 'function') layoutOverlayElements(); } catch(e) {}
				i++;
				if (i <= full.length) {
					if (elId === 'shortcuts-status') shortcutsTypeTimer = setTimeout(step, useSpeed);
					else setTimeout(step, useSpeed);
				}
			};
			step();
		}
		// Layout helper to keep URL and shortcuts a fixed distance from title/status
		function layoutOverlayElements() {
			const logo = document.getElementById('logo-omni');
			const urlFly = document.getElementById('url-flyover');
			const shortcuts = document.getElementById('shortcuts-status');
			const status = document.getElementById('loading-status');
			if (!logo) return;
			const logoRect = logo.getBoundingClientRect();
			// Tight, consistent gaps to avoid large spacing
			const gapAbove = 50; // px above title (URL input offset)
			const gapBelow = 10; // px below status/title
			// Position URL flyover above title
			if (urlFly) {
				const y = Math.max(0, Math.round(logoRect.top - gapAbove));
				urlFly.style.top = y + 'px';
			}
			// Position shortcuts below (under status if present, else under title)
			if (shortcuts) {
				let anchorBottom = logoRect.bottom;
				if (status) {
					const stRect = status.getBoundingClientRect();
					anchorBottom = Math.max(anchorBottom, stRect.bottom);
				}
				const top = Math.round(anchorBottom + gapBelow);
				shortcuts.style.top = top + 'px';
				// Ensure up to 5 lines visible
				const lineHeight = 1.35 * 12; // matches CSS font-size:12px; line-height:1.35
				shortcuts.style.maxHeight = Math.round(lineHeight * 5) + 'px';
			}
		}
		function setBottomTextRandomColor() {
			const titleEl = document.getElementById('mode-title');
			const subEl = document.getElementById('mode-sub');
			if(!titleEl && !subEl) return;
			let hex = '#ffffff';
			let attempts = 0;
			do {
				hex = '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
				attempts++;
			} while (recentBottomColors.includes(hex) && attempts < 10);
			if (titleEl) titleEl.style.color = hex;
			if (subEl) subEl.style.color = hex;
			recentBottomColors.push(hex);
			if (recentBottomColors.length > 16) recentBottomColors.shift();
		}
        let modeShuffleOn = false;
        let modeShuffleTimer = null;
        
        // Settings state (for ProjectM v2)
        const visualSettings = {
            shuffleMinSec: 30,
            shuffleMaxSec: 60,
            transitionSec: 2.7,
            pixelRatio: 1
        };

        // --- UI UTILS ---
        function resetIdleTimer() {
            uiLayer.style.opacity = '1';
			if (radioQuickBtn) {
				radioQuickBtn.style.opacity = '1';
				radioQuickBtn.style.pointerEvents = 'auto';
			}
            // Show volume slider on interaction
            const vs = document.getElementById('volume-slider-container');
            if (vs && state.isPlaying) { vs.style.opacity = '1'; vs.style.pointerEvents = 'auto'; }
            // Show top bar on interaction
            if (topBar && state.isPlaying) { topBar.style.opacity = '1'; topBar.style.pointerEvents = 'auto'; }
            // Always reveal station banner on interaction if it exists
            if (stationBanner) {
                if (stationBannerTimer) { clearTimeout(stationBannerTimer); stationBannerTimer = null; }
                stationBanner.style.opacity = '1';
                stationBanner.style.pointerEvents = 'auto';
            }
			if(radioPanel && !radioPanel.classList.contains('display-none')) {
				radioPanel.style.opacity = '1';
				radioPanel.style.pointerEvents = 'auto';
			}
            // Show webm nav when overlay is active
            if(webmOn && !webmOverlayEl.classList.contains('display-none')) {
                webmPrevBtn.style.opacity = '1';
                webmNextBtn.style.opacity = '1';
                webmPrevBtn.style.pointerEvents = 'auto';
                webmNextBtn.style.pointerEvents = 'auto';
            }
            document.body.style.cursor = 'default';
            if (state.idleTimer) clearTimeout(state.idleTimer);
            if (panelIdleTimer) clearTimeout(panelIdleTimer);
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            if(state.isPlaying) {
                state.idleTimer = setTimeout(() => {
                    uiLayer.style.opacity = '0';
					// Honor hold window after right-click
					if (Date.now() >= radioQuickHoldUntil && radioQuickBtn) {
						radioQuickBtn.style.opacity = '0';
						radioQuickBtn.style.pointerEvents = 'none';
					}
                    // Hide volume slider on idle (but keep visible if top menu is open)
                    const vs = document.getElementById('volume-slider-container');
                    const menu = document.getElementById('top-menu-panel');
                    const menuOpen = !!(menu && !menu.classList.contains('display-none') && menu.classList.contains('open'));
                    if (vs) {
                        if (menuOpen) {
                            vs.style.opacity = '1';
                            vs.style.pointerEvents = 'auto';
                        } else {
                            vs.style.opacity = '0';
                            vs.style.pointerEvents = 'none';
                        }
                    }
                    // Hide top bar on idle
                    if (topBar) { topBar.style.opacity = '0'; topBar.style.pointerEvents = 'none'; }
                    if(!stationBanner.classList.contains('display-none')) {
                        stationBanner.style.opacity = '0';
                        stationBanner.style.pointerEvents = 'none';
                    }
                    // Hide webm nav
                    webmPrevBtn.style.opacity = '0';
                    webmNextBtn.style.opacity = '0';
                    webmPrevBtn.style.pointerEvents = 'none';
                    webmNextBtn.style.pointerEvents = 'none';
                    document.body.style.cursor = 'none';
                }, 3000);
				// Panels fade out and close after 30s if open
				if(radioPanel && !radioPanel.classList.contains('display-none')) scheduleRadioPanelClose();
                if(!settingsPanel.classList.contains('display-none')) scheduleSettingsPanelClose();
                if(!webmSettingsPanel.classList.contains('display-none')) scheduleWebmSettingsClose();
            }
        }
        window.addEventListener('mousemove', resetIdleTimer);
        window.addEventListener('click', resetIdleTimer);
        window.addEventListener('resize', () => { try { layoutOverlayElements(); } catch(e) {} });

        // Updated Fullscreen Logic with forced Resize Trigger
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => forceResize(), 200);
                }).catch(err => console.log(err));
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().then(() => {
                        setTimeout(() => forceResize(), 200);
                    });
                }
            }
        }

        function forceResize() {
            if(state.activeVisualizer && state.activeVisualizer.onResize) {
                state.activeVisualizer.onResize();
            }
			try { layoutOverlayElements(); } catch(e) {}
		}
		// Start screen text loop (fade out after 30s, retype after 30s) until playing
		let startTextLoopTimer = null;
		function cancelStartTextLoop() {
			if (startTextLoopTimer) { try { clearTimeout(startTextLoopTimer); } catch(e) {} startTextLoopTimer = null; }
		}
		function scheduleStartTextLoop() {
			try { cancelStartTextLoop(); } catch(e) {}
			if (state.isPlaying) return;
			const l = document.getElementById('loading-status');
			const sh = document.getElementById('shortcuts-status');
			if (!l || !sh) return;
			l.style.opacity = '1'; sh.style.opacity = '1';
			const defaultLine = 'Select a source to begin';
			const shortcuts = [
				'F Fullscreen  â€¢  C Next Visual  â€¢  ,/. Visual',
				'V Random Station  â€¢  B Previous Station  â€¢  R Top Menu',
				'T Text-In Panel  â€¢  M Mix Settings  â€¢  G WebM Settings',
				'W Toggle Avatar  â€¢  Q/E Avatar Speed  â€¢  Arrows Move Avatar',
				'+/âˆ’ Size  â€¢  Z/X Opacity  â€¢  Esc Back'
			].join('\n');
			let phase = 'visible';
			const loop = () => {
				if (state.isPlaying) { cancelStartTextLoop(); return; }
				if (phase === 'visible') {
					startTextLoopTimer = setTimeout(() => {
						l.style.opacity = '0';
						sh.style.opacity = '0';
						phase = 'hidden';
						loop();
					}, 30000);
				} else {
					startTextLoopTimer = setTimeout(() => {
						l.style.opacity = '1';
						sh.style.opacity = '1';
						try { 
							typeStatus(defaultLine, () => { 
								try { typeStatusTo('shortcuts-status', shortcuts, 30); } catch(e) {}
							}); 
						} catch(e) {}
						phase = 'visible';
						loop();
					}, 30000);
				}
			};
			loop();
        }
		// Make the last two letters "I>" clickable to start radio
		(() => {
			try {
				const logo = document.getElementById('logo-omni');
				if (!logo) return;
				const starts = logo.querySelectorAll('.logo-start');
				starts.forEach((el) => {
					el.style.cursor = 'pointer';
					el.title = 'Start Radio';
					el.addEventListener('click', (e) => {
						e.stopPropagation();
						const btn = document.getElementById('btn-radio');
						if (btn) btn.click();
						else if (typeof playRadio === 'function') playRadio();
					});
				});
				// Make "N" toggle the URL input flyover (reserve space via is-hidden)
				const nEl = logo.querySelector('.logo-letter:nth-child(3)');
				if (nEl) {
					nEl.style.cursor = 'pointer';
					nEl.title = 'Toggle Stream URL';
					nEl.addEventListener('click', (e) => {
						e.stopPropagation();
						const fly = document.getElementById('url-flyover');
						if (!fly) return;
						const hidden = fly.classList.contains('is-hidden');
						if (hidden) fly.classList.remove('is-hidden');
						else fly.classList.add('is-hidden');
						// focus/select input when showing
						if (!hidden) return;
                    const inp = document.getElementById('radio-url') || document.getElementById('station-url');
						if (inp) {
							try { inp.focus(); inp.select(); } catch(e) {}
						}
					});
				}
				// Make "O" load local audio
				const oEl = logo.querySelector('.logo-o');
				if (oEl) {
					oEl.style.cursor = 'pointer';
					oEl.title = 'Load Local Audio';
					oEl.addEventListener('click', (e) => {
						e.stopPropagation();
                        // Suppress overlay click-to-start shortly after opening file dialog
                        try { suppressNextOverlayStartUntil = Date.now() + 1200; } catch(_) {}
						const btn = document.getElementById('btn-file');
						if (btn) btn.click();
						else {
							const input = document.getElementById('file-input');
							if (input) input.click();
						}
					});
				}
				// Make "M" use mic (with confirm)
				const mEl = logo.querySelector('.logo-m');
				if (mEl) {
					mEl.style.cursor = 'pointer';
					mEl.title = 'Use Microphone';
					mEl.addEventListener('click', (e) => {
						e.stopPropagation();
						try { showMicConfirm(); } catch(_) {
							const btn = document.getElementById('btn-mic');
							if (btn) btn.click();
							else if (typeof useMic === 'function') useMic();
						}
					});
				}
			} catch(e) {}
		})();
        
        // Start radio when clicking anywhere on the start screen background (excluding title/inputs)
        (function bindOverlayClickToStart() {
            try {
                const overlay = document.getElementById('overlay');
                if (!overlay) return;
                overlay.addEventListener('click', (e) => {
                    if (state && state.isPlaying) return;
                    // If a recent "O" triggered file dialog, do not start radio
                    try { if (Date.now() < suppressNextOverlayStartUntil) return; } catch(_) {}
                    const logo = document.getElementById('logo-omni');
                    const urlFly = document.getElementById('url-flyover');
                    // Ignore clicks on title (OMNI>) and URL input area
                    if ((logo && logo.contains(e.target)) || (urlFly && urlFly.contains(e.target))) {
                        return;
                    }
                    try { e.stopPropagation(); } catch(_) {}
                    if (typeof playRadio === 'function') playRadio();
                });
            } catch(e) {}
        })();
        // --- Bottom Avatar Menu helpers ---
        function isBottomMenuOpen() {
            const p = document.getElementById('bottom-avatar-panel');
            return !!(p && !p.classList.contains('display-none') && p.classList.contains('open'));
        }
        function openBottomMenuPanel() {
            // Prevent opening if a recent panel close just happened
            try { if (window.__panelGuardUntilMs && Date.now() < window.__panelGuardUntilMs) return; } catch(_) {}
            const p = document.getElementById('bottom-avatar-panel');
            if (!p) return;
            try {
                // Populate WebM select
                const sel = document.getElementById('avatar-webm-select');
                if (sel) {
                    sel.innerHTML = '';
                    if (Array.isArray(webmList) && webmList.length > 0) {
                        webmList.forEach((pth, idx) => {
                            const opt = document.createElement('option');
                            opt.value = String(idx);
                            opt.textContent = (pth || '').split('/').pop() || pth || ('Item ' + (idx+1));
                            if (typeof webmIndex === 'number' && idx === webmIndex) opt.selected = true;
                            sel.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = '0';
                        opt.textContent = '(load list)';
                        sel.appendChild(opt);
                    }
                }
                // Sync inputs from current settings
                const aScale = document.getElementById('avatar-inp-scale');
                const aX = document.getElementById('avatar-inp-x');
                const aY = document.getElementById('avatar-inp-y');
                const aRot = document.getElementById('avatar-inp-rot');
                const aSpeed = document.getElementById('avatar-inp-speed');
                const aOpacity = document.getElementById('avatar-inp-opacity');
                const aDup = document.getElementById('avatar-inp-dup');
                if (aScale) aScale.value = String(webmSettings.scaleVw);
                if (aX) aX.value = String(webmSettings.posXvw);
                if (aY) aY.value = String(webmSettings.posYvh);
                if (aRot) aRot.value = String(webmSettings.rotationDeg);
                if (aSpeed) aSpeed.value = String(webmSettings.playbackRate);
                if (aOpacity) aOpacity.value = String(webmSettings.opacity);
                if (aDup) aDup.value = String(webmSettings.duplicates);
                const autoBtn = document.getElementById('avatar-btn-auto');
                if (autoBtn) { autoBtn.textContent = 'Auto'; autoBtn.classList.toggle('on', webmAutoOn); }
            } catch(_) {}
            p.classList.remove('display-none');
            requestAnimationFrame(() => { p.classList.add('open'); });
        }
        function closeBottomMenuPanel() {
            const p = document.getElementById('bottom-avatar-panel');
            if (!p) return;
            p.classList.remove('open');
            try { window.__panelGuardUntilMs = Date.now() + 1200; } catch(_) {}
            setTimeout(() => { p.classList.add('display-none'); }, 350);
        }
        function toggleBottomMenuPanel() {
            if (isBottomMenuOpen()) closeBottomMenuPanel(); else openBottomMenuPanel();
        }
        // Bind bottom menu controls
        (function bindBottomMenuControls(){
            try {
                const btnClose = document.getElementById('btn-bottommenu-close');
                if (btnClose) btnClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeBottomMenuPanel(); });
                const selWebm = document.getElementById('avatar-webm-select');
                const btnOpenWebm = document.getElementById('avatar-webm-open');
                const btnPrevWebm = document.getElementById('avatar-webm-prev');
                const btnNextWebm = document.getElementById('avatar-webm-next');
                if (btnPrevWebm) btnPrevWebm.addEventListener('click', (e)=>{ e.stopPropagation(); prevWebm(); });
                if (btnNextWebm) btnNextWebm.addEventListener('click', (e)=>{ e.stopPropagation(); nextWebm(); });
                if (btnOpenWebm) btnOpenWebm.addEventListener('click', (e)=>{ 
                    e.stopPropagation();
                    // Toggle behavior: if open, close; otherwise open selected
                    if (typeof webmOn !== 'undefined' && webmOn) {
                        try { hideWebm(); } catch(_) {}
                        return;
                    }
                    if (typeof loadWebmList === 'function' && webmList.length === 0) {
                        loadWebmList().finally(()=>{ try { const idx = Math.max(0, Math.min(webmList.length-1, parseInt((selWebm?.value)||'0',10)||0)); setWebm(idx); showWebm(); } catch(_){} });
                    } else {
                        try { const idx = Math.max(0, Math.min(webmList.length-1, parseInt((selWebm?.value)||'0',10)||0)); setWebm(idx); showWebm(); } catch(_){}
                    }
                });
                const aScale = document.getElementById('avatar-inp-scale');
                const aX = document.getElementById('avatar-inp-x');
                const aY = document.getElementById('avatar-inp-y');
                const aRot = document.getElementById('avatar-inp-rot');
                const aSpeed = document.getElementById('avatar-inp-speed');
                const aOpacity = document.getElementById('avatar-inp-opacity');
                const aDup = document.getElementById('avatar-inp-dup');
                const updateFromAvatarInputs = () => {
                    webmSettings.scaleVw = Number(aScale?.value) || 50;
                    webmSettings.posXvw = Number(aX?.value) || 50;
                    webmSettings.posYvh = Number(aY?.value) || 50;
                    webmSettings.rotationDeg = Number(aRot?.value) || 0;
                    webmSettings.playbackRate = Math.max(0.1, Math.min(4, Number(aSpeed?.value) || 1));
                    webmSettings.opacity = Math.max(0, Math.min(1, Number(aOpacity?.value) || 1));
                    webmSettings.duplicates = Math.max(0, Math.min(2, Math.floor(Number(aDup?.value) || 0)));
                    applyWebmSettings();
                };
                [aScale, aX, aY, aRot, aSpeed, aOpacity, aDup].forEach(el => {
                    if (el) el.addEventListener('input', updateFromAvatarInputs);
                });
                const btnAuto = document.getElementById('avatar-btn-auto');
                if (btnAuto) btnAuto.addEventListener('click', (e)=>{ 
                    e.preventDefault(); 
                    e.stopPropagation(); 
                    setWebmAuto(!webmAutoOn); 
                    const autoBtn = document.getElementById('avatar-btn-auto'); 
                    if (autoBtn) { autoBtn.textContent = 'Auto'; autoBtn.classList.toggle('on', webmAutoOn); }
                    // If auto just turned on and no WebM is playing, start the first WebM
                    try {
                        if (webmAutoOn && !webmOn) {
                            if (webmList.length === 0 && typeof loadWebmList === 'function') {
                                loadWebmList().finally(() => {
                                    if (webmList.length > 0) { setWebm(0); showWebm(); }
                                });
                            } else if (webmList.length > 0) {
                                setWebm(0); showWebm();
                            }
                        }
                    } catch(_) {}
                });
                const btnReset = document.getElementById('avatar-btn-reset');
                if (btnReset) btnReset.addEventListener('click', (e)=>{ 
                    e.preventDefault(); e.stopPropagation();
                    webmSettings.scaleVw = 50;
                    webmSettings.posXvw = 50;
                    webmSettings.posYvh = 50;
                    webmSettings.rotationDeg = 0;
                    webmSettings.playbackRate = 1.0;
                    webmSettings.opacity = 0.82;
                    webmSettings.duplicates = 0;
                    if (aScale) aScale.value = '50';
                    if (aX) aX.value = '50';
                    if (aY) aY.value = '50';
                    if (aRot) aRot.value = '0';
                    if (aSpeed) aSpeed.value = '1.0';
                    if (aOpacity) aOpacity.value = '0.82';
                    if (aDup) aDup.value = '0';
                    applyWebmSettings();
                });
            } catch(e) {}
        })();

        // Gesture handling: swipe to change visual, double-tap to open WebM; WebM overlay swipes to navigate videos
        (function bindGestures() {
            try {
                const canvasEl = document.getElementById('canvas-container');
                const webmOverlay = document.getElementById('webm-overlay');
                if (!canvasEl) return;
                const SWIPE_PX = 40;
                const TAP_MAX_MOVE = 8;
                const DOUBLE_TAP_MS = 300;
                let pDownX = 0, pDownY = 0, pDownTime = 0;
                let lastTapTime = 0;
                let handledSwipe = false;
                // Suppress random-station click when we just handled a swipe/double-tap
                window.__suppressNextClick = false;
                const onPointerDown = (e) => {
                    pDownX = e.clientX || (e.touches && e.touches[0]?.clientX) || 0;
                    pDownY = e.clientY || (e.touches && e.touches[0]?.clientY) || 0;
                    pDownTime = Date.now();
                    handledSwipe = false;
                };
                const onPointerUpCanvas = (e) => {
                    if (!state || !state.isPlaying) return;
                    // ignore if UI overlays present
                    const overlay = document.getElementById('overlay');
                    if (overlay && !overlay.classList.contains('hidden') && overlay.style.display !== 'none') return;
                    const x = e.clientX || (e.changedTouches && e.changedTouches[0]?.clientX) || 0;
                    const y = e.clientY || (e.changedTouches && e.changedTouches[0]?.clientY) || 0;
                    const dx = x - pDownX;
                    const dy = y - pDownY;
                    const adx = Math.abs(dx), ady = Math.abs(dy);
                    // Vertical swipe: down/up closes open panel first; only opens target if none open
                    if (ady > SWIPE_PX && ady > adx) {
                        handledSwipe = true;
                        window.__suppressNextClick = true;
                        try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                        
                        // Guard against follow-up events
                        const guardUntil = (typeof window !== 'undefined' && window.__panelGuardUntilMs) ? window.__panelGuardUntilMs : 0;
                        if (Date.now() < guardUntil) return;

                        // Check which panels are currently open
                        const topOpen = (typeof isTopMenuOpen === 'function') && isTopMenuOpen();
                        const avatarOpen = (typeof isBottomMenuOpen === 'function') && isBottomMenuOpen(); // Now the side panel
                        // Check if Mix Panel is open (manually since it doesn't have an isXOpen helper)
                        const mixOpen = mixPanel && !mixPanel.classList.contains('display-none') && mixPanel.classList.contains('open');

                        // PRIORITY: Close any open panel before opening a new one
                        if (topOpen) { if (typeof closeTopMenuPanel === 'function') closeTopMenuPanel(); return; }
                        if (avatarOpen) { if (typeof closeBottomMenuPanel === 'function') closeBottomMenuPanel(); return; }
                        
                        if (dy > 0) { // SWIPE DOWN
                            // If Mix Panel is open at the bottom, swipe down should close it
                            if (mixOpen) { toggleMixPanel(); return; }
                            
                            // Otherwise, open the Top Menu
                            if (typeof openTopMenuPanel === 'function') openTopMenuPanel();
                        } else { // SWIPE UP
                            // Open Mix Settings (instead of Avatar/WebM)
                            if (!mixOpen) toggleMixPanel();
                        }
                        return;
                    }
                    // Horizontal swipe changes visual
                    if (adx > SWIPE_PX && adx > ady) {
                        handledSwipe = true;
                        window.__suppressNextClick = true;
                        try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                        if (dx < 0) loadMode(state.currentModeIdx + 1);
                        else loadMode(state.currentModeIdx - 1);
                        return;
                    }
                    // Double tap toggles Fullscreen (no station change, no WebM)
                    const moved = (adx > TAP_MAX_MOVE || ady > TAP_MAX_MOVE);
                    const now = Date.now();
                    if (!moved && (now - lastTapTime) < DOUBLE_TAP_MS) {
                        window.__suppressNextClick = true;
                        try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                        try { if (window.__randomClickTimer) { clearTimeout(window.__randomClickTimer); window.__randomClickTimer = null; } } catch(_) {}
                        try { toggleFullscreen(); } catch(_) {}
                        lastTapTime = 0; // reset
                        return;
                    }
                    // Record tap time for double-tap detection
                    if (!moved) lastTapTime = now;
                };
                const onPointerUpWebm = (e) => {
                    if (!webmOn) return;
                    const x = e.clientX || (e.changedTouches && e.changedTouches[0]?.clientX) || 0;
                    const y = e.clientY || (e.changedTouches && e.changedTouches[0]?.clientY) || 0;
                    const dx = x - pDownX;
                    const dy = y - pDownY;
                    const adx = Math.abs(dx), ady = Math.abs(dy);
                    if (adx > SWIPE_PX && adx > ady) {
                        // Only within overlay area: navigate webms
                        handledSwipe = true;
                        window.__suppressNextClick = true;
                        try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                        if (dx < 0) nextWebm();
                        else prevWebm();
                    }
                };
                // Pointer listeners (mouse + touch via pointer events)
                canvasEl.addEventListener('pointerdown', onPointerDown, { passive: true });
                canvasEl.addEventListener('pointerup', onPointerUpCanvas, { passive: false });
                if (webmOverlay) {
                    webmOverlay.addEventListener('pointerdown', onPointerDown, { passive: true });
                    webmOverlay.addEventListener('pointerup', onPointerUpWebm, { passive: false });
                }
                // Double click: toggle Fullscreen
                canvasEl.addEventListener('dblclick', (e) => {
                    if (!state || !state.isPlaying) return;
                    try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                    try { if (window.__randomClickTimer) { clearTimeout(window.__randomClickTimer); window.__randomClickTimer = null; } } catch(_) {}
                    try { toggleFullscreen(); } catch(_) {}
                }, { passive: false });
                // Double click on WebM overlay: toggle Fullscreen
                if (webmOverlay) {
                    webmOverlay.addEventListener('dblclick', (e) => {
                        try { e.preventDefault(); e.stopPropagation(); } catch(_) {}
                        try { if (window.__randomClickTimer) { clearTimeout(window.__randomClickTimer); window.__randomClickTimer = null; } } catch(_) {}
                        try { toggleFullscreen(); } catch(_) {}
                    }, { passive: false });
                }
                // Wheel: scroll UP opens top menu; scroll DOWN opens bottom menu; never open the other when closing (trackpads/mice)
                // Wheel: scroll UP opens top menu; scroll DOWN opens Mix Settings (bottom); 
                let lastWheelAt = 0;
                canvasEl.addEventListener('wheel', (e) => {
                    if (!state || !state.isPlaying) return;
                    const guardUntil = (typeof window !== 'undefined' && window.__panelGuardUntilMs) ? window.__panelGuardUntilMs : 0;
                    const now = Date.now();
                    if (now < guardUntil) return;
                    if (now - lastWheelAt < 250) return;
                    lastWheelAt = now;
                    
                    const dy = e.deltaY || 0;
                    
                    // Check if Mix Panel is open (manual check)
                    const mixOpen = mixPanel && !mixPanel.classList.contains('display-none') && mixPanel.classList.contains('open');
                    // Check if Side/Avatar Panel is open
                    const sideOpen = typeof isBottomMenuOpen === 'function' && isBottomMenuOpen();
                    // Check if Top Menu is open
                    const topOpen = typeof isTopMenuOpen === 'function' && isTopMenuOpen();

                    if (dy < 0) {
                        // SCROLL UP: Open Top Menu (or close others)
                        try {
                            if (mixOpen) { toggleMixPanel(); return; }
                            if (sideOpen) { closeBottomMenuPanel(); return; }
                            if (!topOpen) { openTopMenuPanel(); }
                        } catch(_) {}
                    } else if (dy > 0) {
                        // SCROLL DOWN: Open Mix Settings at Bottom (or close others)
                        try {
                            if (topOpen) { closeTopMenuPanel(); return; }
                            if (sideOpen) { closeBottomMenuPanel(); return; }
                            if (!mixOpen) { toggleMixPanel(); }
                        } catch(_) {}
                    }
                }, { passive: true });
            } catch(e) {}
        })();

        // When playing, clicking anywhere (except UI controls) picks a random station
        (function bindGlobalRandomClickWhilePlaying() {
            try {
                const area = document.getElementById('canvas-container');
                if (!area) return;
                area.addEventListener('click', (e) => {
                    try {
                        if (!state || !state.isPlaying) return;
                        // Delay station change to detect potential double-click; cancel if dblclick fires
                        if (window.__suppressNextClick) { window.__suppressNextClick = false; return; }
                        const delayMs = 280; // align with DOUBLE_TAP_MS window
                        try { if (window.__randomClickTimer) { clearTimeout(window.__randomClickTimer); window.__randomClickTimer = null; } } catch(_) {}
                        window.__randomClickTimer = setTimeout(() => {
                            try {
                                if (!state || !state.isPlaying) return;
                                // If a panel is open or overlay visible, ignore
                                const overlay = document.getElementById('overlay');
                                const menu = document.getElementById('top-menu-panel');
                                const webm = document.getElementById('webm-overlay');
                                if (overlay && !overlay.classList.contains('hidden') && overlay.style.display !== 'none') return;
                                if (menu && !menu.classList.contains('display-none') && menu.classList.contains('open')) return;
                                // If WebM overlay is visible, allow clicks outside of it to change station
                                if (webm && !webm.classList.contains('display-none')) {
                                    if (e.target && e.target.closest && e.target.closest('#webm-overlay')) return;
                                }
                                if (typeof pickRandomStation === 'function') pickRandomStation();
                            } catch(_) {} 
                        }, delayMs);
                        // If start overlay or top menu is visible, ignore
                        const overlay = document.getElementById('overlay');
                        const menu = document.getElementById('top-menu-panel');
                        const webm = document.getElementById('webm-overlay');
                    } catch(_) {}
                }, false);
            } catch(e) {}
        })();

        // WebM speed helpers
        function setWebmSpeed(newRate) {
            const clamped = Math.max(0.1, Math.min(4, Number(newRate) || 1));
            webmSettings.playbackRate = clamped;
            if (typeof inpWebmSpeed !== 'undefined' && inpWebmSpeed) {
                inpWebmSpeed.value = String(clamped);
            }
            applyWebmSettings();
        }
        function adjustWebmSpeed(delta) {
            setWebmSpeed((Number(webmSettings.playbackRate) || 1) + (delta || 0));
        }
        // WebM position/size/opacity helpers
        function adjustWebmPosition(dxVw, dyVh) {
            if (!webmOn) return;
            var x = Number(webmSettings.posXvw) || 50;
            var y = Number(webmSettings.posYvh) || 50;
            var nx = Math.max(0, Math.min(100, x + (dxVw || 0)));
            var ny = Math.max(0, Math.min(100, y + (dyVh || 0)));
            webmSettings.posXvw = nx;
            webmSettings.posYvh = ny;
            if (typeof inpWebmX !== 'undefined' && inpWebmX) inpWebmX.value = String(nx);
            if (typeof inpWebmY !== 'undefined' && inpWebmY) inpWebmY.value = String(ny);
            applyWebmSettings();
        }
        function adjustWebmScale(deltaVw) {
            if (!webmOn) return;
            var min = Number((typeof inpWebmScale !== 'undefined' && inpWebmScale && inpWebmScale.min) ? inpWebmScale.min : 10);
            var max = Number((typeof inpWebmScale !== 'undefined' && inpWebmScale && inpWebmScale.max) ? inpWebmScale.max : 100);
            var cur = Number(webmSettings.scaleVw) || min;
            var nv = Math.max(min, Math.min(max, cur + (deltaVw || 0)));
            webmSettings.scaleVw = nv;
            if (typeof inpWebmScale !== 'undefined' && inpWebmScale) inpWebmScale.value = String(nv);
            applyWebmSettings();
        }
        function adjustWebmOpacity(delta) {
            if (!webmOn) return;
            var cur = Number(webmSettings.opacity) || 0;
            var nv = Math.max(0, Math.min(1, cur + (delta || 0)));
            webmSettings.opacity = nv;
            if (typeof inpWebmOpacity !== 'undefined' && inpWebmOpacity) inpWebmOpacity.value = String(nv);
            applyWebmSettings();
        }
        // Volume control handling (50% = 0 dB; below attenuate, above amplify)
        function setVolume(value) {
            const v = Math.max(0, Math.min(1, Number(value) || 0));
            if (state && state.gainNode && state.gainNode.gain) {
                // Map slider to dB curve:
                // v = 0.5 -> 0 dB (1.0 linear)
                // v < 0.5 -> -40 dB .. 0 dB
                // v > 0.5 -> 0 dB .. +12 dB
                let gainLinear = 1.0;
                if (v === 0) {
                    gainLinear = 0.0;
                } else if (v < 0.5) {
                    const t = v / 0.5;           // 0..1
                    const dB = -40 * (1 - t);    // -40..0
                    gainLinear = Math.pow(10, dB / 20);
                } else if (v > 0.5) {
                    const t = (v - 0.5) / 0.5;   // 0..1
                    const dB = 12 * t;           // 0..+12
                    gainLinear = Math.pow(10, dB / 20);
                } else {
                    gainLinear = 1.0;
                }
                state.gainNode.gain.value = gainLinear;
                // Also toggle media element mute to guarantee silence at 0
                try {
                    const el = document.getElementById('radio-element');
                    if (el) el.muted = (v === 0);
                } catch(e) {}
            }
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyserNode = state.audioCtx.createAnalyser();
                state.analyserNode.fftSize = 2048; 
				state.gainNode = state.audioCtx.createGain();
				state.gainNode.gain.value = 1.0;

                // Create Gains for Crossfader
                state.streamAGain = state.audioCtx.createGain();
                state.streamBGain = state.audioCtx.createGain();
                state.streamAGain.gain.value = 1.0; 
                state.streamBGain.gain.value = 0.0; 
                state.mixInput = state.audioCtx.createGain();

                // --- CHANNEL A EQ ---
                state.trimA = state.audioCtx.createGain(); state.trimA.gain.value = eqState.a.gain;
                state.eqA = {
                    high: state.audioCtx.createBiquadFilter(),
                    mid: state.audioCtx.createBiquadFilter(),
                    low: state.audioCtx.createBiquadFilter()
                };
                state.eqA.high.type = 'highshelf'; state.eqA.high.frequency.value = 3000; state.eqA.high.gain.value = eqState.a.high;
                state.eqA.mid.type = 'peaking'; state.eqA.mid.frequency.value = 1000; state.eqA.mid.gain.value = eqState.a.mid;
                state.eqA.low.type = 'lowshelf'; state.eqA.low.frequency.value = 200; state.eqA.low.gain.value = eqState.a.low;
                state.eqA.high.connect(state.eqA.mid); state.eqA.mid.connect(state.eqA.low); state.eqA.low.connect(state.trimA); state.trimA.connect(state.streamAGain);

                // --- CHANNEL B EQ ---
                state.trimB = state.audioCtx.createGain(); state.trimB.gain.value = eqState.b.gain;
                state.eqB = {
                    high: state.audioCtx.createBiquadFilter(),
                    mid: state.audioCtx.createBiquadFilter(),
                    low: state.audioCtx.createBiquadFilter()
                };
                state.eqB.high.type = 'highshelf'; state.eqB.high.frequency.value = 3000; state.eqB.high.gain.value = eqState.b.high;
                state.eqB.mid.type = 'peaking'; state.eqB.mid.frequency.value = 1000; state.eqB.mid.gain.value = eqState.b.mid;
                state.eqB.low.type = 'lowshelf'; state.eqB.low.frequency.value = 200; state.eqB.low.gain.value = eqState.b.low;
                state.eqB.high.connect(state.eqB.mid); state.eqB.mid.connect(state.eqB.low); state.eqB.low.connect(state.trimB); state.trimB.connect(state.streamBGain);

                state.streamAGain.connect(state.mixInput);
                state.streamBGain.connect(state.mixInput);
                
                // Existing FX chain...
                state.fx = {
                    low: { node: state.audioCtx.createBiquadFilter(), on: false },
                    high: { node: state.audioCtx.createBiquadFilter(), on: false },
                    bass: { node: state.audioCtx.createBiquadFilter(), on: false },
                    treble: { node: state.audioCtx.createBiquadFilter(), on: false },
                    arp: { filter: state.audioCtx.createBiquadFilter(), lfo: state.audioCtx.createOscillator(), lfoGain: state.audioCtx.createGain(), on: false },
                    tk: { node: state.audioCtx.createBiquadFilter(), on: false },
                    echoDelay: { node: state.audioCtx.createDelay(5.0), on: false },
                    echoFeedback: { node: state.audioCtx.createGain(), on: false },
                    distort: { node: state.audioCtx.createWaveShaper(), on: false }
                };
                state.fx.low.node.type = 'lowpass'; state.fx.low.node.frequency.value = 1800;
                state.fx.high.node.type = 'highpass'; state.fx.high.node.frequency.value = 200;
                state.fx.bass.node.type = 'peaking'; state.fx.bass.node.frequency.value = 100; state.fx.bass.node.Q.value = 1.0; state.fx.bass.node.gain.value = 6;
                state.fx.treble.node.type = 'peaking'; state.fx.treble.node.frequency.value = 4000; state.fx.treble.node.Q.value = 0.7; state.fx.treble.node.gain.value = 6;
                state.fx.arp.filter.type = 'bandpass'; state.fx.arp.filter.frequency.value = 800; state.fx.arp.filter.Q.value = 2.0;
                state.fx.arp.lfo.type = 'square'; state.fx.arp.lfo.frequency.value = 4.0; state.fx.arp.lfoGain.gain.value = 0; 
                state.fx.arp.lfo.connect(state.fx.arp.lfoGain);
                try { state.fx.arp.lfoGain.connect(state.fx.arp.filter.frequency); } catch(_) {}
                try { state.fx.arp.lfo.start(); } catch(_) {}
                state.fx.tk.node.type = 'bandpass'; state.fx.tk.node.frequency.value = 1200; state.fx.tk.node.Q.value = 4.0;
                state.fx.echoDelay.node.delayTime.value = 0.28; state.fx.echoFeedback.node.gain.value = 0.35;
                const curveLen = 44100; const curve = new Float32Array(curveLen); const amount = 120;
                for (let i=0;i<curveLen;i++){ const x = i/curveLen*2-1; curve[i] = ((3+amount)*x*20*Math.PI/180)/(Math.PI+amount*Math.abs(x)); }
                state.fx.distort.node.curve = curve; state.fx.distort.node.oversample = '4x';

                try { state.mixInput.disconnect(); } catch(_) {}
                state.mixInput.connect(state.analyserNode);
                try { state.analyserNode.disconnect(); } catch(_) {}
                state.analyserNode.connect(state.gainNode);
                try { state.gainNode.disconnect(); } catch(_) {}
                state.gainNode.connect(state.audioCtx.destination);

				if (volumeSlider) {
					volumeSlider.value = String(0.2);
					volumeSlider.addEventListener('input', (e) => setVolume(volumeSlider.value));
					try { setVolume(0.2); } catch(e) {}
				}
                try { applyCrossfade(0); } catch(_) {}
                
                // --- BIND KNOBS ---
                // We bind them here so they update the Live Audio Nodes
                // Stream A
                bindKnob('knob-a-gain', 0, 2, eqState.a.gain, eqState.a, 'gain', v => { if(state.trimA) state.trimA.gain.value = v; });
                bindKnob('knob-a-high', -20, 20, eqState.a.high, eqState.a, 'high', v => { if(state.eqA.high) state.eqA.high.gain.value = v; });
                bindKnob('knob-a-mid', -20, 20, eqState.a.mid, eqState.a, 'mid', v => { if(state.eqA.mid) state.eqA.mid.gain.value = v; });
                bindKnob('knob-a-low', -20, 20, eqState.a.low, eqState.a, 'low', v => { if(state.eqA.low) state.eqA.low.gain.value = v; });
                
                // Stream B
                bindKnob('knob-b-gain', 0, 2, eqState.b.gain, eqState.b, 'gain', v => { if(state.trimB) state.trimB.gain.value = v; });
                bindKnob('knob-b-high', -20, 20, eqState.b.high, eqState.b, 'high', v => { if(state.eqB.high) state.eqB.high.gain.value = v; });
                bindKnob('knob-b-mid', -20, 20, eqState.b.mid, eqState.b, 'mid', v => { if(state.eqB.mid) state.eqB.mid.gain.value = v; });
                bindKnob('knob-b-low', -20, 20, eqState.b.low, eqState.b, 'low', v => { if(state.eqB.low) state.eqB.low.gain.value = v; });
            }
            if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
        }
        function rebuildEffectsChain() {
            if (!state.audioCtx) return;
            // Disconnect everything from mixInput forward
            try { state.mixInput.disconnect(); } catch(_) {}
            const enabled = [];
            if (state.fx.low.on) enabled.push(state.fx.low.node);
            if (state.fx.high.on) enabled.push(state.fx.high.node);
            if (state.fx.bass.on) enabled.push(state.fx.bass.node);
            if (state.fx.treble.on) enabled.push(state.fx.treble.node);
            if (state.fx.arp.on) enabled.push(state.fx.arp.filter);
            if (state.fx.tk.on) enabled.push(state.fx.tk.node);
            if (state.fx.echoDelay.on) {
                // echo network: mix -> delay -> feedback -> delay
                try { state.fx.echoDelay.node.disconnect(); } catch(_) {}
                try { state.fx.echoFeedback.node.disconnect(); } catch(_) {}
                state.fx.echoDelay.node.connect(state.fx.echoFeedback.node);
                state.fx.echoFeedback.node.connect(state.fx.echoDelay.node);
                enabled.push(state.fx.echoDelay.node);
            }
            if (state.fx.distort.on) enabled.push(state.fx.distort.node);
            // Chain: mixInput -> ...enabled... -> analyser
            let last = state.mixInput;
            for (const node of enabled) {
                try { last.disconnect(); } catch(_) {}
                last.connect(node);
                last = node;
            }
            try { last.disconnect(); } catch(_) {}
            last.connect(state.analyserNode);
            // Ensure analyser -> master gain -> dest remains
            try { state.analyserNode.disconnect(); } catch(_) {}
            state.analyserNode.connect(state.gainNode);
            try { state.gainNode.disconnect(); } catch(_) {}
            state.gainNode.connect(state.audioCtx.destination);
            // Reconnect visualizer if needed
            try {
                if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                    state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                }
            } catch(_) {}
        }
        
        // Enable/disable start controls (radio/mic/file/url)
        function setStartControlsEnabled(enabled) {
            const btnRadio = document.getElementById('btn-radio');
            const btnMic = document.getElementById('btn-mic');
            const btnFile = document.getElementById('btn-file');
            const urlInput = document.getElementById('radio-url') || document.getElementById('station-url');
            [btnRadio, btnMic, btnFile, urlInput].forEach(el => {
                if(!el) return;
                if(enabled) {
                    el.removeAttribute('disabled');
                    el.setAttribute('tabindex', '0');
                } else {
                    el.setAttribute('disabled', 'true');
                    el.setAttribute('tabindex', '-1');
                }
            });
        }
		function applyOverlayGlowAndLogo() {
            const overlay = document.getElementById('overlay');
			// Randomize overlay glow and OMNI shimmer color
			const glowHex = randomHexColor();
			overlay.style.setProperty('--glowColor', glowHex);
			overlay.classList.add('glow-on');
			// reset cycle counter so next change happens on next min pass
			overlayGlowCycleCount = 0;
			// Use a timer aligned to animation minima (every 2 cycles of the 2400ms animation)
			if (overlayGlowColorTimer) { clearInterval(overlayGlowColorTimer); overlayGlowColorTimer = null; }
			overlayGlowColorTimer = setInterval(() => {
				if (overlay.classList.contains('glow-on')) {
					overlay.style.setProperty('--glowColor', randomHexColor());
				}
			}, overlayGlowDurationMs * 2);
			const logo = document.getElementById('logo-omni');
			if (logo) {
				const omniHex = randomHexColor();
				logo.style.setProperty('--omniColor', omniHex);
				// retrigger animation
				logo.classList.remove('logo-animate');
				// force reflow
				void logo.offsetWidth;
				logo.classList.add('logo-animate');
				// ensure persistent glow pulse is active
				logo.classList.add('logo-glow');
			}
		}
		function showOverlay() {
			const overlay = document.getElementById('overlay');
			overlay.classList.remove('hidden');
			overlay.style.display = 'flex';
            // Restore tiled background for start screen
            try {
                document.body.style.backgroundImage = "url('pta.gif')";
                document.body.style.backgroundRepeat = "repeat";
                document.body.style.backgroundPosition = "top left";
                document.body.style.backgroundSize = "auto";
            } catch(_) {}
			applyOverlayGlowAndLogo();
			// Hide quick radio button on start page
			if (typeof radioQuickBtn !== 'undefined' && radioQuickBtn) {
				radioQuickBtn.style.display = 'none';
			}
			// Hide volume slider on start overlay
			(() => { const vs = document.getElementById('volume-slider-container'); if (vs) vs.style.display = 'none'; })();
			// Show full-screen border frame
			const border = document.getElementById('border-frame');
			if (border) border.classList.add('visible');
			// Type the current status line on start screen, then shortcuts
			const shortcuts = [
				'F Fullscreen  â€¢  C Next Visual  â€¢  ,/. Visual',
				'V Random Station  â€¢  B Previous Station  â€¢  R Top Menu',
				'T Text-In Panel  â€¢  M Mix Settings  â€¢  G WebM Settings',
				'W Toggle Avatar  â€¢  Q/E Avatar Speed  â€¢  Arrows Move Avatar',
				'+/âˆ’ Size  â€¢  Z/X Opacity  â€¢  Esc Back'
			].join('\n');
			if (statusEl) {
				typeStatus(statusEl.innerText || 'Select a source to begin', () => {
					typeStatusTo('shortcuts-status', shortcuts, 30);
					try { layoutOverlayElements(); } catch(e) {}
					try { scheduleStartTextLoop(); } catch(e) {}
				});
			} else {
				typeStatusTo('shortcuts-status', shortcuts, 30);
				try { layoutOverlayElements(); } catch(e) {}
				try { scheduleStartTextLoop(); } catch(e) {}
			}
            setStartControlsEnabled(true);
        }
        function hideOverlay() {
            const overlay = document.getElementById('overlay');
            overlay.classList.add('hidden');
            overlay.style.display = 'none';
			overlay.classList.remove('glow-on');
            try { cancelStartTextLoop(); } catch(e) {}
			if (overlayGlowColorTimer) { try { clearInterval(overlayGlowColorTimer); } catch(e) {} overlayGlowColorTimer = null; }
			// Hide full-screen border frame
			const border = document.getElementById('border-frame');
			if (border) border.classList.remove('visible');
            setStartControlsEnabled(false);
        }
		// Apply initial glow/shimmer on first startup if overlay is visible
		(() => {
			const overlay = document.getElementById('overlay');
			if (overlay && !overlay.classList.contains('hidden') && overlay.style.display !== 'none') {
				
                // DELAY THE GLOW by 5 seconds (5000ms)
                setTimeout(() => {
				    applyOverlayGlowAndLogo();
                }, 5000);

				// Ensure radio quick button is hidden on the start screen
				try {
					const rq = document.getElementById('radio-quick');
					if (rq) rq.style.display = 'none';
				} catch(e) {}
				
                // SHOW BORDER FRAME IMMEDIATELY (Restored)
				const border = document.getElementById('border-frame');
				if (border) border.classList.add('visible');
				
                // Type initial status then shortcuts (if text present)
				const s = document.getElementById('loading-status');
				const shortcuts = [
					'F Fullscreen  â€¢  C Next Visual  â€¢  ,/. Visual',
					'V Random Station  â€¢  B Previous Station  â€¢  R Top Menu',
					'T Text-In Panel  â€¢  M Mix Settings  â€¢  G WebM Settings',
					'W Toggle Avatar  â€¢  Q/E Avatar Speed  â€¢  Arrows Move Avatar',
					'+/âˆ’ Size  â€¢  Z/X Opacity  â€¢  Esc Back'
				].join('\n');
				if (s && s.innerText && s.innerText.trim().length > 0) {
					typeStatus(s.innerText.trim(), () => { typeStatusTo('shortcuts-status', shortcuts, 30); try { layoutOverlayElements(); } catch(e) {} try { scheduleStartTextLoop(); } catch(e) {} });
				} else {
					typeStatusTo('shortcuts-status', shortcuts, 30); try { layoutOverlayElements(); } catch(e) {} try { scheduleStartTextLoop(); } catch(e) {}
				}
			}
			// Background is now preloaded and applied via CSS for first-paint immediacy
		})();

        // --- FIXED PLAYRADIO FUNCTION ---
        function playRadio() {
            initAudio();
            let url = '';
            try {
                url = (radioInputEl && radioInputEl.value) ? radioInputEl.value : '';
                if (!url && Array.isArray(stations) && stations.length > 0) {
                    const idx = (typeof currentStationIndex === 'number' && currentStationIndex >= 0) ? currentStationIndex : 0;
                    url = stations[idx]?.url || '';
                }
            } catch(_) {}
            if (!url) return;
            statusEl.innerText = "Connecting to Stream...";
            
            // Update Banner
            (function updateInitialStationTitle() {
                let nameToShow = null;
                if (currentStationIndex >= 0 && stations[currentStationIndex] && stations[currentStationIndex].url === url) {
                    nameToShow = stations[currentStationIndex].name;
                }
                showStationBanner(nameToShow || deriveTitleFromUrl(url));
            })();
            
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                if(state.sourceNode) { try { state.sourceNode.disconnect(); } catch(e) {} }
                if (!state.radioElementSource) {
                    state.radioElementSource = state.audioCtx.createMediaElementSource(audioEl);
                }
                state.sourceNode = state.radioElementSource;
                
                // --- NEW ROUTING: Connect to EQ Chain A instead of direct Gain ---
                try { state.sourceNode.disconnect(); } catch(_) {}
                state.sourceNode.connect(state.eqA.high);
                
                rebuildEffectsChain();
                try { applyCrossfade(mixCross ? mixCross.value : 0); } catch(_) {}
                
                try { if (state.activeVisualizer && state.activeVisualizer.visualizer && state.activeVisualizer.visualizer.connectAudio) state.activeVisualizer.visualizer.connectAudio(state.analyserNode); } catch(e) {}
                if(!state.isPlaying) startGame();
                radioRetryAttempts = 0;
            }).catch(e => {
                // Retry logic (abbreviated for brevity, essentially same as before)
                console.error("Stream playback failed:", e);
            });
        
            
            // --- FIX START: Reuse MediaElementSource ---
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                // Disconnect whatever was previously active (e.g. file source or mic)
                if(state.sourceNode) {
                    try { state.sourceNode.disconnect(); } catch(e) {}
                }

                // Check if we have already created a source for the Radio Element
                if (!state.radioElementSource) {
                    // First time only: Create and store it
                    state.radioElementSource = state.audioCtx.createMediaElementSource(audioEl);
                }

                // Use the persistent source
                state.sourceNode = state.radioElementSource;
                
                // Route to Stream A gain -> mix/effects -> analyser
                state.sourceNode.connect(state.streamAGain);
                
                rebuildEffectsChain();
                try { applyCrossfade(mixCross ? mixCross.value : 0); } catch(_) {}
                
                // Ensure active visualizer is connected
                try {
                    if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                        state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                    }
                } catch(e) { /* ignore */ }

                if(!state.isPlaying) startGame();
                
                // Success: reset retry attempts
                radioRetryAttempts = 0;
            }).catch(e => {
                console.error("Stream playback failed:", e);
                // auto-retry with a new random station
                radioRetryAttempts = (radioRetryAttempts || 0) + 1;
                if (radioRetryAttempts <= MAX_RADIO_RETRIES && stations.length > 0) {
                    statusEl.innerText = "Stream failed. Trying another station...";
                    if (currentStationIndex < 0 || currentStationIndex >= stations.length) {
                        currentStationIndex = Math.floor(Math.random() * stations.length);
                        setStation(currentStationIndex);
                    } else {
                        pickRandomStation();
                    }
                } else {
                    statusEl.innerText = "No playable station found. Check console for CORS/Mixed Content errors.";
                }
            });
            // --- FIX END ---
        }

        async function useMic() {
            initAudio();
            statusEl.innerText = "Requesting Mic Access...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaStreamSource(stream);
                state.mediaStream = stream;
                try { state.sourceNode.disconnect(); } catch(_) {}
                state.sourceNode.connect(state.streamAGain);
                rebuildEffectsChain();
                // Ensure active visualizer (e.g., ProjectM) is connected to the current analyser
                try {
                    if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                        state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                    }
                } catch(e) { /* ignore */ }
                startGame();
            } catch(e) { statusEl.innerText = "Error: " + e.message; }
        }

        function useFile(e) {
            initAudio();
            const file = e.target.files[0];
            if(!file) return;
            statusEl.innerText = "Decoding...";
            // Ensure any radio/media element playback is stopped before using a local file
            try {
                if (audioEl && !audioEl.paused) {
                    audioEl.pause();
                }
                if (audioEl) {
                    audioEl.removeAttribute('src');
                    audioEl.load();
                }
            } catch(e) { /* ignore */ }
            // Safely disconnect any existing source node (MediaElementSource or BufferSource)
            try {
                if (state.sourceNode) {
                    if (typeof state.sourceNode.stop === 'function') {
                        try { state.sourceNode.stop(); } catch(_) {}
                    }
                    state.sourceNode.disconnect();
                }
            } catch(e) { /* ignore */ }
            const reader = new FileReader();
            reader.onload = (ev) => {
                state.audioCtx.decodeAudioData(ev.target.result, (buffer) => {
                    if(state.sourceNode) {
                        try {
                            if (typeof state.sourceNode.stop === 'function') {
                                state.sourceNode.stop();
                            }
                            state.sourceNode.disconnect();
                        } catch(e) { /* ignore */ }
                    }
                    state.sourceNode = state.audioCtx.createBufferSource();
                    state.sourceNode.buffer = buffer;
                    state.sourceNode.loop = true;
                    try { state.sourceNode.disconnect(); } catch(_) {}
                    state.sourceNode.connect(state.streamAGain);
                    rebuildEffectsChain();
                    state.sourceNode.start(0);
                    // Ensure active visualizer (e.g., ProjectM) is connected to the current analyser
                    try {
                        if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                            state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                        }
                    } catch(e) { /* ignore */ }
                    startGame();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function startGame() {
            state.isPlaying = true;
            const overlay = document.getElementById('overlay');
            // Digital transition: animate overlay out, then start visuals
            overlay.classList.add('digital-out');
            document.getElementById('ui-layer').classList.remove('hidden');
            setTimeout(() => {
                hideOverlay();
                overlay.classList.remove('digital-out');
                // Ensure background gif is not shown behind canvas once playing
                try {
                    document.body.style.backgroundImage = 'none';
                    document.body.style.backgroundRepeat = 'no-repeat';
                    document.body.style.backgroundPosition = '';
                    document.body.style.backgroundSize = '';
                } catch(e) {}
                // Start with last visual if saved, else "ProjectM v2" if available
                try {
                    let idxToLoad = -1;
                    try {
                        const savedName = localStorage.getItem('lastModeName');
                        if (savedName) {
                            const savedIdx = modes.findIndex(m => m && m.name === savedName);
                            if (savedIdx >= 0) idxToLoad = savedIdx;
                        } else {
                            const savedIdxStr = localStorage.getItem('lastModeIndex');
                            const savedIdxNum = savedIdxStr != null ? parseInt(savedIdxStr, 10) : -1;
                            if (!isNaN(savedIdxNum) && savedIdxNum >= 0 && savedIdxNum < modes.length) {
                                idxToLoad = savedIdxNum;
                            }
                        }
                    } catch(_) {}
                    if (idxToLoad < 0) {
                        idxToLoad = Math.max(0, modes.findIndex(m => m && m.name === "ProjectM v2"));
                    }
                    loadMode(idxToLoad);
                } catch(e) {
                    loadMode(0);
                }
                try { cancelStartTextLoop(); } catch(e) {}
                // Show quick radio button once the app has started
                if (typeof radioQuickBtn !== 'undefined' && radioQuickBtn) {
                    radioQuickBtn.style.display = '';
                }
                // Build top bar: show quick radio (volume slider lives in top menu)
                try {
                    if (topBar && radioQuickBtn) {
                        topBar.innerHTML = '';
                        // Ensure the top bar is actually shown (remove class that forces display:none)
                        topBar.classList.remove('display-none');
                        topBar.appendChild(radioQuickBtn);
                        topBar.style.display = 'flex';
                        topBar.style.opacity = '1';
                        topBar.style.pointerEvents = 'auto';
                    }
                } catch(e) {}
            resetIdleTimer();
            }, 520);
        }

function stopAllAndShowStart() {
    // Stop active visualizer
    if (state.activeVisualizer && typeof state.activeVisualizer.destroy === 'function') {
        try { state.activeVisualizer.destroy(); } catch(e) {}
    }
    state.activeVisualizer = null;
    // Stop audio sources
    try {
        if (state.sourceNode) {
            try { state.sourceNode.disconnect(); } catch(e) {}
            try { if (typeof state.sourceNode.stop === 'function') state.sourceNode.stop(0); } catch(e) {}
            state.sourceNode = null;
        }
        if (state.mediaStream) {
            try { state.mediaStream.getTracks().forEach(t => t.stop()); } catch(e) {}
            state.mediaStream = null;
        }
        if (audioEl) {
            try { audioEl.pause(); } catch(e) {}
            try { audioEl.currentTime = 0; } catch(e) {}
            try { audioEl.src = ''; audioEl.load(); } catch(e) {}
        }
    } catch (err) { /* ignore */ }
    // Hide player UI and other overlays, show start overlay
    document.getElementById('ui-layer').classList.add('hidden');
    if (typeof hideRadioPanel === 'function') { try { hideRadioPanel(); } catch(e) {} }
    const sb = document.getElementById('station-banner');
    if (sb) { sb.classList.add('display-none'); }
    if (typeof hideWebm === 'function' && typeof webmOn !== 'undefined' && webmOn) {
        try { hideWebm(); } catch(e) {}
    }
	state.isPlaying = false;
	if (typeof statusEl !== 'undefined' && statusEl) {
		try { typeStatus("Not streaming â€” choose a source to begin"); } catch(e) {}
	}
    showOverlay();
}
        // --- ENGINE: BUTTERCHURN ---
        class MilkdropEngine {
            constructor() {
                this.name = "ProjectM / Milkdrop";
                this.presets = butterchurnPresets.getPresets();
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null; // Track canvas reference
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                
                // FIX: Explicitly set canvas attributes to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                container.appendChild(this.canvas);

                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                });
                this.visualizer.connectAudio(state.analyserNode);
                // Randomize preset on each init/selection
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                const key = this.presetKeys[idx];
                this.visualizer.loadPreset(this.presets[key], 2.7); 
                if (state.activeVisualizer === this) {
                document.getElementById('mode-sub').innerText = key;
                }
				// Change bottom HUD color on each preset load
				try { setBottomTextRandomColor(); } catch(e) {}
            }

            nextPreset() {
                // Pick a random preset different from current
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 30;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 60;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }
            
            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
					try { setBottomTextRandomColor(); } catch(e) {}
                } catch(e) { alert("Invalid JSON"); }
            }

            onResize() { 
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    // FIX: Update attributes AND renderer
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: BUTTERCHURN v2 (Enhanced) ---
        class MilkdropEngineV2 {
            constructor() {
                this.name = "ProjectM v2";
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null;
                this.transitionSec = visualSettings.transitionSec;
                // Use global preset map directly (largest available pack)
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                container.appendChild(this.canvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                // Randomize preset on each init/selection
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if(this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
				// Change bottom HUD color on each preset load
				try { setBottomTextRandomColor(); } catch(e) {}
            }

            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, Number(visualSettings.transitionSec) || 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
					try { setBottomTextRandomColor(); } catch(e) {}
                } catch(e) { alert("Invalid JSON"); }
            }

            nextPreset() {
                if(this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            applySettings() {
                // Restart scheduling with new shuffle window
                this.restartCycle();
                // Transition seconds will be used on next loadPreset call automatically
            }

            onResize() {
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: ProjectM v3 with Bars Overlay ---
        class MilkdropEngineV3 {
            constructor() {
                this.name = "ProjectM v3 (Bars Overlay)";
                this.resizeHandler = this.onResize.bind(this);
                this.pmCanvas = null;
                this.overlayRenderer = null;
                this.overlayScene = null;
                this.overlayCamera = null;
                this.bars = [];
                this.dataArray = null;
                this.transitionSec = visualSettings.transitionSec;
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                // ProjectM canvas (background)
                this.pmCanvas = document.createElement('canvas');
                this.pmCanvas.width = window.innerWidth;
                this.pmCanvas.height = window.innerHeight;
                container.appendChild(this.pmCanvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.pmCanvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                // Randomize preset on each init/selection
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
                this.loadPreset(this.currentPresetIdx);

                // Overlay bars (transparent WebGL)
                this.overlayScene = new THREE.Scene();
                this.overlayCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.overlayCamera.position.z = 8;
                this.overlayRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.overlayRenderer.setSize(window.innerWidth, window.innerHeight);
                this.overlayRenderer.setPixelRatio(window.devicePixelRatio || 1);
                this.overlayRenderer.domElement.style.position = 'absolute';
                this.overlayRenderer.domElement.style.top = '0';
                this.overlayRenderer.domElement.style.left = '0';
                this.overlayRenderer.domElement.style.pointerEvents = 'none';
                container.appendChild(this.overlayRenderer.domElement);

                // Build bars similar to sceneBars
                const group = new THREE.Group();
                this.bars = [];
                const numBars = 64;
                const spacing = 0.25;
                for (let i = 0; i < numBars; i++) {
                    const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.x = (i - numBars / 2) * spacing;
                    group.add(mesh);
                    this.bars.push(mesh);
                }
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                const point = new THREE.PointLight(0x00ffff, 1.2, 50);
                point.position.set(0, 5, 5);
                this.overlayScene.add(ambient, point, group);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);

                window.addEventListener('resize', this.resizeHandler);
                this.animate = this.animate.bind(this);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if (this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
                try { setBottomTextRandomColor(); } catch (e) {}
            }

            nextPreset() {
                if (this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if (this.presetKeys.length > 1) {
                    while (next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            onResize() {
                // PM
                if (this.visualizer && this.pmCanvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.pmCanvas.width = w;
                    this.pmCanvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
                // Overlay
                if (this.overlayRenderer && this.overlayCamera) {
                    this.overlayCamera.aspect = window.innerWidth / window.innerHeight;
                    this.overlayCamera.updateProjectionMatrix();
                    this.overlayRenderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate);
                // Render ProjectM (background)
                try {
                    if (this.visualizer && typeof this.visualizer.render === 'function') {
                        this.visualizer.render();
                    }
                } catch(e) { /* ignore */ }
                // Update bars overlay
                if (state && state.analyserNode && this.dataArray) {
                    state.analyserNode.getByteFrequencyData(this.dataArray);
                    const step = Math.floor(this.dataArray.length / Math.max(1, this.bars.length));
                    const t = performance.now() * 0.0008;
                    for (let i = 0; i < this.bars.length; i++) {
                        const v = this.dataArray[i * step] / 255;
                        const h = 0.2 + v * 3.0;
                        this.bars[i].scale.y = h;
                        this.bars[i].position.y = h * 0.25;
                        const hue = (i / this.bars.length + t) % 1;
                        this.bars[i].material.color.setHSL(hue, 1, 0.5);
                        this.bars[i].material.emissive.setHSL(hue, 1, 0.2);
                    }
                }
                if (this.overlayRenderer && this.overlayScene && this.overlayCamera) {
                    this.overlayRenderer.render(this.overlayScene, this.overlayCamera);
                }
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                if (this.overlayRenderer) {
                    try { this.overlayRenderer.dispose(); } catch(e) {}
                }
                container.innerHTML = '';
            }
        }
        // --- ENGINE: THREE.JS ---
        class ThreeEngine {
            constructor(name, sceneFn) {
                this.name = name;
                this.sceneFn = sceneFn;
                this.resizeHandler = this.onResize.bind(this);
				// Adaptive quality settings (auto-tune for stronger/weaker machines)
				this.quality = {
					mode: 'auto',
					minPixelRatio: 1,
					maxPixelRatio: 2.5,
					adjustIntervalMs: 1000,
					lastAdjustTs: 0,
					frameTimesMs: []
				};
            }

            init() {
                container.innerHTML = '';
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 4;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				// Prefer physically-correct lighting and good tone mapping on capable devices
				if (this.renderer) {
					// Guard for different three.js versions
					if ('outputColorSpace' in this.renderer) {
						this.renderer.outputColorSpace = THREE.SRGBColorSpace;
					} else if ('outputEncoding' in this.renderer) {
						this.renderer.outputEncoding = THREE.sRGBEncoding;
					}
					if ('toneMapping' in this.renderer && THREE.ACESFilmicToneMapping) {
						this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
					}
					if ('physicallyCorrectLights' in this.renderer) {
						this.renderer.physicallyCorrectLights = true;
					}
				}
				// Initial pixel ratio tuned for device; will auto-adjust at runtime
				const initialPR = Math.min(window.devicePixelRatio || 1, this.quality.maxPixelRatio);
				this.renderer.setPixelRatio(initialPR);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                container.appendChild(this.renderer.domElement);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);
                this.updateFn = this.sceneFn(this.scene, this.camera, this.composer);
                
                window.addEventListener('resize', this.resizeHandler);
				this._lastFrameTs = performance.now();
				this.quality.lastAdjustTs = this._lastFrameTs;
                this.animate();
            }

            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
				// Track frame time for adaptive quality
				const now = performance.now();
				const dt = now - (this._lastFrameTs || now);
				this._lastFrameTs = now;
				if (isFinite(dt) && dt > 0 && dt < 250) {
					const q = this.quality;
					q.frameTimesMs.push(dt);
					if (q.frameTimesMs.length > 90) q.frameTimesMs.shift();
					// Adjust roughly once per second
					if (q.mode === 'auto' && (now - q.lastAdjustTs) >= q.adjustIntervalMs && q.frameTimesMs.length >= 30) {
						const avg = q.frameTimesMs.reduce((a, b) => a + b, 0) / q.frameTimesMs.length;
						const currentPR = this.renderer.getPixelRatio ? this.renderer.getPixelRatio() : 1;
						let targetPR = currentPR;
						// Targets ~60fps. If consistently faster, try increase detail; if slower, reduce.
						if (avg < 14 && currentPR < q.maxPixelRatio) targetPR = Math.min(q.maxPixelRatio, currentPR + 0.25);
						if (avg > 20 && currentPR > q.minPixelRatio) targetPR = Math.max(q.minPixelRatio, currentPR - 0.25);
						if (Math.abs(targetPR - currentPR) >= 0.1) {
							const w = window.innerWidth, h = window.innerHeight;
							this.renderer.setPixelRatio(targetPR);
							this.renderer.setSize(w, h, false);
							this.composer.setSize(w, h);
						}
						q.lastAdjustTs = now;
					}
				}
                state.analyserNode.getByteFrequencyData(this.dataArray);
                if(this.updateFn) this.updateFn(this.dataArray, performance.now());
                this.composer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                window.removeEventListener('resize', this.resizeHandler);
                this.renderer.dispose();
                container.innerHTML = '';
            }
        }

        // --- SCENES ---
        const sceneSphere = (scene) => {
            // Use SphereGeometry for clean UVs and per-vertex coloring
            const geo = new THREE.SphereGeometry(0.9, 64, 64);
            const base = geo.attributes.position.array.slice();
            // Allocate vertex colors
            const colorAttr = new THREE.Float32BufferAttribute(geo.attributes.position.count * 3, 3);
            geo.setAttribute('color', colorAttr);
            const mat = new THREE.MeshBasicMaterial({ vertexColors: true });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            return (data, time) => {
                const bass = data[8] / 255;
                const mid = data[32] / 255;
                const tre = data[64] / 255;
                const t = time * 0.001;
                // Audio-driven subtle vertex displacement
                const arr = geo.attributes.position.array;
                for (let i = 0; i < arr.length; i += 3) {
                    const bx = base[i], by = base[i + 1], bz = base[i + 2];
                    const n = Math.sin(bx * 1.1 + t * 1.8) * 0.015 + Math.cos(by * 1.3 - t * 1.6) * 0.015;
                    const a = (i / 3) % data.length;
                    const v = data[a] / 255;
                    const push = 0.04 + bass * 0.22 + mid * 0.12 + v * 0.06;
                    const s = 1.0 + n + push * 0.02;
                    arr[i] = bx * s; arr[i + 1] = by * s; arr[i + 2] = bz * s;
                }
                geo.attributes.position.needsUpdate = true;
                // Radiating multi-colour effect based on spherical coords + time + audio
                const cols = colorAttr.array;
                for (let i = 0, vi = 0; i < arr.length; i += 3, vi += 3) {
                    const x = arr[i], y = arr[i + 1], z = arr[i + 2];
                    const ang = Math.atan2(y, x);              // [-PI, PI]
                    const r = Math.sqrt(x * x + y * y + z * z);
                    const hue = ((ang / (Math.PI * 2)) + 0.5 + t * 0.25 + bass * 0.15) % 1;
                    const sat = 0.9;
                    const lig = 0.45 + 0.25 * (mid + tre * 0.5);
                    const c = new THREE.Color().setHSL(hue, sat, lig);
                    cols[vi] = c.r; cols[vi + 1] = c.g; cols[vi + 2] = c.b;
                }
                colorAttr.needsUpdate = true;
                // Rotation and scale breathing
                mesh.rotation.y += 0.004 + mid * 0.02;
                mesh.rotation.x += 0.002 + tre * 0.01;
                mesh.scale.setScalar(1 + bass * 0.3 + mid * 0.12);
            };
        };

        const sceneTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const count = 40;
            const meshes = [];
            for(let i=0; i<count; i++){
                const geo = new THREE.TorusGeometry(1+(i*0.5), 0.05, 8, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);
                meshes.push(mesh);
            }
            scene.add(group);
            return (data, time) => {
                const step = Math.floor(data.length/count);
                for(let i=0; i<count; i++){
                    const val = data[i*step]/255;
                    meshes[i].scale.setScalar(1 + val);
                    meshes[i].material.color.setHSL(val + (time*0.0002), 1, 0.5);
                    meshes[i].rotation.z += 0.01 * (i%2?1:-1);
                }
                camera.position.z = 25 + Math.sin(time*0.001)*5;
                camera.rotation.z = time * 0.0005;
            };
        };

        const sceneBars = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const numBars = 64;
            for(let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
				mesh.position.x = 0; // will be positioned in update based on current viewport width
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0x00ffff, 1.2, 50);
            point.position.set(0, 5, 5);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / numBars);
				const t = time * 0.0008;
				// Compute current frustum width at z = 0 to make bars span visible width
				const fovRad = THREE.MathUtils.degToRad(camera.fov);
				const frustumHeight = 2 * Math.tan(fovRad / 2) * camera.position.z;
				const frustumWidth = frustumHeight * camera.aspect;
				const spacing = frustumWidth / numBars;
				const baseWidth = 0.18;
				const targetWidth = spacing * 0.7;
				const xScale = Math.max(0.1, targetWidth / baseWidth);
                for(let i = 0; i < numBars; i++) {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 3.0;
					// Position bars evenly across the visible width
					bars[i].position.x = (i - (numBars - 1) / 2) * spacing;
					// Width to fit lane, height driven by audio
					bars[i].scale.x = xScale;
                    bars[i].scale.y = h;
                    bars[i].position.y = h * 0.25;
                    const hue = (i / numBars + t) % 1;
                    bars[i].material.color.setHSL(hue, 1, 0.5);
                    bars[i].material.emissive.setHSL(hue, 1, 0.2);
                }
				// No side-to-side motion
				group.rotation.y = 0;
            };
        };

        // Vertical Mirror Audio Bars (fills viewport height and resizes)
        const sceneBarsVerticalMirror = (scene, camera) => {
            const group = new THREE.Group();
            // Rotate 180 degrees
            group.rotation.x = Math.PI;
            const bars = [];
            const numBars = 64;
            const baseWidth = 0.2;
            const baseHeight = 0.2;
            for (let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(baseWidth, baseHeight, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x0a0a0a, metalness: 0.15, roughness: 0.55 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(0, 0, 0); // y will be set in update
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.45);
            const point = new THREE.PointLight(0x88ccff, 1.1, 50);
            point.position.set(0, 0, 6);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const t = time * 0.0006;
                // Compute visible height for current camera for consistent vertical fit
                const visibleHeight = 2 * Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * Math.abs(camera.position.z);
                const spacing = visibleHeight / (numBars + 2); // a small top/bottom margin
                const targetBarHeight = spacing * 0.6;
                const heightScale = targetBarHeight / baseHeight;
                const step = Math.max(1, Math.floor(data.length / numBars));
                for (let i = 0; i < numBars; i++) {
                    const mesh = bars[i];
                    // Position bars vertically, centered around y=0
                    mesh.position.y = (i - (numBars - 1) / 2) * spacing;
                    // Fixed bar height to align cleanly in the stack
                    mesh.scale.y = heightScale;
                    // Width responds to audio; centered so it extends both left and right
                    const v = data[i * step] / 255;
                    const width = baseWidth * (1 + v * 8.0); // responsive extent to both sides
                    mesh.scale.x = width / baseWidth;
                    // Color/emissive shift over time and index
                    const hue = (i / numBars + t) % 1;
                    mesh.material.color.setHSL(hue, 1, 0.55);
                    mesh.material.emissive.setHSL(hue, 1, 0.18);
                }
            };
        };

        // Circular Audio Bars
        const sceneBarsCircle = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const num = 72;
            const radius = 3.0;
            for (let i = 0; i < num; i++) {
                const geo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x101010, metalness: 0.2, roughness: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                const a = (i / num) * Math.PI * 2;
                m.position.set(Math.cos(a) * radius, Math.sin(a) * radius, 0);
                m.lookAt(0, 0, 0);
                group.add(m); bars.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const pl = new THREE.PointLight(0x88bbff, 1.2, 40); pl.position.set(0, 0, 6); scene.add(pl, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / bars.length);
                const t = time * 0.0005;
                bars.forEach((b, i) => {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 2.8;
                    b.scale.y = h;
                    const hue = (i / bars.length + t) % 1;
                    b.material.color.setHSL(hue, 1, 0.55);
                    b.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z += 0.002;
            };
        };

        // 3D Audio Bars (radial tiers)
        const sceneBars3D = (scene, camera) => {
            const group = new THREE.Group();
            const tiers = 4;
            const perTier = 48;
            const bars = [];
            for (let t = 0; t < tiers; t++) {
                const r = 1.5 + t * 0.9;
                for (let i = 0; i < perTier; i++) {
                    const a = (i / perTier) * Math.PI * 2;
                    const geo = new THREE.BoxGeometry(0.12 + t*0.02, 0.5, 0.12 + t*0.02);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.3, roughness: 0.5, emissive: 0x000000 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(Math.cos(a) * r, Math.sin(a) * r, -t * 0.6);
                    m.lookAt(0, 0, -t * 0.6 - 1);
                    group.add(m); bars.push(m);
                }
            }
            const amb = new THREE.AmbientLight(0xffffff, 0.35);
            const pl = new THREE.PointLight(0xff88cc, 1.4, 60); pl.position.set(0, 0, 8);
            scene.add(amb, pl, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / bars.length);
                const t = time * 0.0006;
                bars.forEach((b, i) => {
                    const v = data[(i * step) % data.length] / 255;
                    const h = 0.2 + v * 3.2;
                    b.scale.y = h;
                    b.position.z = -Math.floor(i / perTier) * 0.6 - v * 0.8;
                    const hue = (i / bars.length + t) % 1;
                    b.material.color.setHSL(hue, 1, 0.55);
                    b.material.emissive.setHSL(hue, 1, 0.15);
                });
                group.rotation.z = Math.sin(t * 0.8) * 0.2;
                group.rotation.x = Math.cos(t * 0.6) * 0.15;
            };
        };

        // Bars Vortex (wormhole made of bars)
        const sceneBarsVortex = (scene, camera) => {
            const group = new THREE.Group();
            const rings = [];
            const bars = [];
            const ringCount = 24;      // depth of the tunnel
            const barsPerRing = 56;    // bars around the ring
            const startRadius = 3.0;
            const endRadius = 0.6;     // taper to a small radius to form a wormhole
            const depthStep = 0.4;     // spacing between rings along -Z
            const twistPerRing = 0.18; // spiral twist down the tunnel
            for (let r = 0; r < ringCount; r++) {
                const radius = startRadius + (endRadius - startRadius) * (r / (ringCount - 1));
                const ring = [];
                for (let i = 0; i < barsPerRing; i++) {
                    const angle = (i / barsPerRing) * Math.PI * 2 + r * twistPerRing;
                    const geo = new THREE.BoxGeometry(0.08, 0.5, 0.08);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, metalness: 0.35, roughness: 0.55 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, -r * depthStep);
                    m.lookAt(0, 0, -r * depthStep - 1);
                    group.add(m);
                    bars.push(m);
                    ring.push(m);
                }
                rings.push({ radius, meshes: ring });
            }
            // Lighting
            const amb = new THREE.AmbientLight(0xffffff, 0.3);
            const pl1 = new THREE.PointLight(0x66ccff, 1.3, 80); pl1.position.set(0, 0, 8);
            const pl2 = new THREE.PointLight(0xff66aa, 1.1, 80); pl2.position.set(0, 0, -ringCount * depthStep * 0.5);
            scene.add(amb, pl1, pl2, group);
            camera.position.z = 8.5;
            // Animation
            let scrollZ = 0;
            // Smoothing buffers
            const smoothedVals = new Array(ringCount * barsPerRing).fill(0);
            let smoothedBass = 0;
            const smooth = (prev, next, alpha) => prev + (next - prev) * alpha; // alpha ~ 0.15
            return (data, time) => {
                const t = time * 0.0006;
                const step = Math.max(1, Math.floor(data.length / bars.length));
                // Smooth bass to avoid jerkiness in forward motion
            const bassRaw = (data[8] || 0) / 255;
            smoothedBass = smooth(smoothedBass, bassRaw, 0.08);
                // Create a forward motion through the tunnel (smoothed)
            scrollZ += 0.025 + smoothedBass * 0.06;
                const baseZShift = scrollZ % depthStep;
                bars.forEach((b, i) => {
                    const vRaw = (data[(i * step) % data.length] || 0) / 255;
                    const v = smoothedVals[i] = smooth(smoothedVals[i], vRaw, 0.08);
                    const h = 0.22 + v * 2.0; // reduced range for steadier bars
                    b.scale.y = h;
                    // slight breathing of radius per ring by mids
                    const ringIdx = Math.floor(i / barsPerRing);
                    const mid = smooth(0, (data[24] || 0) / 255, 0.08);
                    const ring = rings[ringIdx];
                    const frac = ringIdx / (ringCount - 1);
                    const breathe = 0.04 * Math.sin(t * 1.8 + ringIdx * 0.35) * (0.5 + mid * 0.5);
                    const angle = (i % barsPerRing) / barsPerRing * Math.PI * 2 + ringIdx * twistPerRing + t * 0.8;
                    const cr = Math.max(0.1, ring.radius * (1.0 + breathe));
                    b.position.x = Math.cos(angle) * cr;
                    b.position.y = Math.sin(angle) * cr;
                    // continuous flow along z to simulate vortex pull
                    const z = -ringIdx * depthStep + baseZShift - v * 0.35; // less aggressive z wobble
                    b.position.z = z;
                    b.lookAt(0, 0, z - 1);
                    // color cycle along tunnel
                    const hue = (frac + t * 0.06 + v * 0.12) % 1;
                    b.material.color.setHSL(hue, 1, 0.55);
                    b.material.emissive.setHSL(hue, 1, 0.15);
                });
                // gentle whole-tunnel rotation for a wormhole effect
                group.rotation.z = Math.sin(t * 0.55) * 0.22;
                group.rotation.x = Math.cos(t * 0.45) * 0.14;
            };
        };
        // High-energy neon sphere variants
        const sceneElectroSphere = (scene, camera) => {
            const geo = new THREE.IcosahedronGeometry(1.6, 64);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.8, roughness: 0.2, emissive: 0x000000 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            const base = geo.attributes.position.array.slice();
            const noise = new SimplexNoise();
            const light = new THREE.PointLight(0x66ccff, 2.2, 40);
            light.position.set(2, 2, 4);
            scene.add(new THREE.AmbientLight(0xffffff, 0.25), light);
            camera.position.z = 5;
            return (data, time) => {
                const t = time*0.0007;
                const arr = geo.attributes.position.array;
                const bass = data[8]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = base[i], y = base[i+1], z = base[i+2];
                    const n = noise.noise3d(x*0.8 + t*0.9, y*0.8 - t*0.7, z*0.8 + t*0.6);
                    const scale = 1.0 + n*(0.12 + bass*0.8);
                    arr[i] = x*scale; arr[i+1] = y*scale; arr[i+2] = z*scale;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.rotation.y += 0.01 + bass*0.06;
                mesh.rotation.x += 0.004;
                const hue = (t*0.3 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.55);
                light.intensity = 1.8 + bass*3.2;
            };
        };

        const scenePhotonShell = (scene, camera) => {
            // Points on a sphere shell
            const num = 4000;
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const u = Math.random();
                const v = Math.random();
                const theta = 2*Math.PI*u;
                const phi = Math.acos(2*v-1);
                const r = 1.8;
                positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
                positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                positions[i*3+2] = r*Math.cos(phi);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            // Orbiting rings
            const rings = [];
            for(let i=0;i<3;i++){
                const ring = new THREE.TorusGeometry(2.0 + i*0.15, 0.03, 12, 200);
                const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
                const tor = new THREE.Mesh(ring, m);
                scene.add(tor);
                rings.push(tor);
            }
            camera.position.z = 6;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[10]/255;
                points.rotation.y = t*0.4 + bass*0.6;
                points.rotation.x = Math.sin(t*0.4)*0.2;
                const hue = (t*0.2 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.6);
                mat.size = 0.03 + bass*0.15;
                rings.forEach((r, i) => {
                    r.rotation.x = t*(i+1);
                    r.rotation.y = t*(i+1)*0.6;
                    r.material.color.setHSL((hue + i*0.1)%1, 1, 0.6);
                    r.material.opacity = 0.4 + bass*0.5;
                });
            };
        };

        const scenePulseOrb = (scene, camera) => {
            const layers = [];
            const layerCount = 5;
            for(let i=0;i<layerCount;i++){
                const radius = 1.2 + i*0.22;
                const geo = new THREE.SphereGeometry(radius, 96, 96);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x55ccff,
                    metalness: 0.4,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.18 + i*0.08,
                    emissive: new THREE.Color(0x113355),
                    emissiveIntensity: 0.25 + i*0.05
                });
                const mesh = new THREE.Mesh(geo, mat);
                layers.push(mesh);
                scene.add(mesh);
            }
            // Dimmer, colored lighting to reduce central white clipping
            const ambient = new THREE.AmbientLight(0x223344, 0.18);
            const light = new THREE.PointLight(0x66ccff, 0.7, 60);
            light.position.set(1.5, 2.0, 6.0);
            scene.add(ambient, light);
            camera.position.z = 7.5;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                const mid = data[24]/255;
                layers.forEach((m, i) => {
                    const hue = (0.55 + 0.08*i + t*0.06) % 1;
                    m.material.color.setHSL(hue, 0.85, 0.55 - i*0.04);
                    const s = 1.0 + bass*(0.35 + i*0.1) + Math.sin(t*1.6 + i)*0.03;
                    m.scale.setScalar(s);
                    m.rotation.y += 0.002 + mid*0.015 + i*0.0015;
                    m.rotation.x += 0.0015 + i*0.001;
                    m.material.opacity = 0.18 + i*0.08 + bass*0.08;
                });
                light.intensity = 0.6 + bass*1.2;
                light.position.x = 1.5 + Math.sin(t*0.7)*1.0;
                light.position.y = 2.0 + Math.cos(t*0.5)*0.6;
            };
        };

        // New scenes
        const sceneStarfield = (scene, camera) => {
            const stars = [];
            const geo = new THREE.SphereGeometry(0.02, 6, 6);
            for(let i=0;i<1200;i++){
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: Math.random()*0.8+0.2 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                scene.add(m); stars.push(m);
            }
            camera.position.z = 6;
            return (data, time) => {
                const bass = data[8]/255;
                const t = time*0.0002;
                stars.forEach((s, i) => {
                    s.position.z += 0.02 + bass*0.3;
                    if(s.position.z > 40) s.position.z = -40;
                    const hue = (i/1200 + t) % 1;
                    s.material.color.setHSL(hue, 0.7, 0.6);
                });
                camera.rotation.z = Math.sin(t*2)*0.1;
            };
        };

        const sceneWaveGrid = (scene, camera) => {
            const gridSize = 64;
            const spacing = 0.2;
            const group = new THREE.Group();
            const planes = [];
            for(let x=0;x<gridSize;x++){
                for(let y=0;y<gridSize;y++){
                    const geo = new THREE.PlaneGeometry(0.18, 0.18);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set((x - gridSize/2)*spacing, (y - gridSize/2)*spacing, 0);
                    group.add(p);
                    planes.push(p);
                }
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / gridSize);
                const t = time * 0.0015;
                planes.forEach((p, idx) => {
                    const i = idx % gridSize;
                    const j = Math.floor(idx / gridSize);
                    const v = data[(i*step) % data.length]/255;
                    p.position.z = Math.sin(i*0.2 + j*0.25 + t*4) * (0.1 + v*0.8);
                    const hue = (v + (i+j)/ (gridSize*2) + t*0.2)%1;
                    p.material.color.setHSL(hue, 1, 0.5);
                    p.material.opacity = 0.35 + v*0.65;
                });
                group.rotation.x = Math.sin(t*0.2)*0.4;
                group.rotation.y = Math.cos(t*0.25)*0.4;
            };
        };

        const sceneParticles = (scene, camera) => {
            const num = 1500;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                positions[i*3+0] = (Math.random()-0.5)*40;
                positions[i*3+1] = (Math.random()-0.5)*40;
                positions[i*3+2] = (Math.random()-0.5)*40;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 10;
            return (data, time) => {
                const bass = data[4]/255;
                points.rotation.y += 0.001 + bass*0.01;
                points.rotation.x += 0.0006;
                const hue = (time*0.0001)%1;
                points.material.color.setHSL(hue, 1, 0.6);
                points.material.size = 0.05 + bass*0.25;
            };
        };

        // --- Additional Tunnel Variants ---
        const sceneNeonTunnel = (scene, camera) => {
            const rings = [];
            const count = 36;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(2.5, 0.08, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.4;
                rings.push(m);
                scene.add(m);
            }
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[8]/255;
                rings.forEach((r, i) => {
                    r.position.z += 0.12 + bass*0.6;
                    if(r.position.z > 3.5) r.position.z -= count*1.4;
                    const hue = ((i/count) + time*0.0002) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.rotation.x = time*0.0006 + i*0.03;
                });
                camera.rotation.z = Math.sin(time*0.0006)*0.15;
            };
        };

        const sceneTwistTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const segs = [];
            for(let i=0;i<90;i++){
                const geo = new THREE.CylinderGeometry(2.2, 2.2, 0.4, 60, 1, true);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff66ff, wireframe: true, transparent: true, opacity: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*0.9;
                m.rotation.z = i*0.1;
                group.add(m);
                segs.push(m);
            }
            scene.add(group);
            camera.position.z = 3.5;
            return (data, time) => {
                const mid = data[24]/255;
                segs.forEach((s, i) => {
                    s.position.z += 0.08 + mid*0.5;
                    if(s.position.z > 2.5) s.position.z -= 90*0.9;
                    s.rotation.z += 0.003 + mid*0.03;
                    const hue = ((i/90) + time*0.00015) % 1;
                    s.material.color.setHSL(hue, 1, 0.6);
                    s.material.opacity = 0.25 + mid*0.75;
                });
                group.rotation.y = Math.sin(time*0.0005)*0.3;
            };
        };

        const sceneParticleTunnel = (scene, camera) => {
            const num = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const r = 2 + Math.random()*2.5;
                const a = Math.random()*Math.PI*2;
                const z = -Math.random()*60;
                positions[i*3+0] = Math.cos(a)*r;
                positions[i*3+1] = Math.sin(a)*r;
                positions[i*3+2] = z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 3;
            return (data, time) => {
                const bass = data[6]/255;
                const arr = geo.attributes.position.array;
                for(let i=0;i<arr.length;i+=3){
                    arr[i+2] += 0.22 + bass*1.6;
                    if(arr[i+2] > 2.5) arr[i+2] -= 62.5;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0002)%1;
                mat.color.setHSL(hue, 1, 0.7);
                points.rotation.z += 0.001 + bass*0.02;
            };
        };

        const sceneGalaxy = (scene, camera) => {
            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            for(let i=0;i<count;i++){
                const r = Math.random() * 20;
                const angle = Math.random()*Math.PI*2;
                const arm = ((i%2) * 2 - 1) * (r*0.1);
                const x = Math.cos(angle + arm) * r;
                const y = (Math.random()-0.5) * 2;
                const z = Math.sin(angle + arm) * r;
                positions[i*3+0] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                const c = new THREE.Color().setHSL((r/20)*0.6 + 0.2, 1, 0.6);
                colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 16;
            return (data, time) => {
                const bass = data[10]/255;
                points.rotation.z = time*0.0001 + bass*0.2;
                mat.size = 0.04 + bass*0.18;
            };
        };

        const sceneKaleidoRings = (scene, camera) => {
            const group = new THREE.Group();
            const rings = [];
            for(let i=0;i<14;i++){
                const geo = new THREE.TorusGeometry(0.8 + i*0.35, 0.04, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const torus = new THREE.Mesh(geo, mat);
                group.add(torus);
                rings.push(torus);
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / rings.length);
                const t = time*0.0006;
                rings.forEach((r, i) => {
                    const v = data[i*step]/255;
                    r.rotation.x = t*(i%3+1);
                    r.rotation.y = -t*(i%2+1);
                    r.material.color.setHSL(((i/rings.length)+t)%1, 1, 0.55);
                    r.material.opacity = 0.3 + v*0.7;
                    r.scale.setScalar(1 + v*0.4);
                });
                group.rotation.z = Math.sin(t*2)*0.3;
            };
        };

        const sceneTerrain = (scene, camera) => {
            const size = 80;
            const segments = 120;
            const geo = new THREE.PlaneGeometry(size, size, segments, segments);
            const mat = new THREE.MeshStandardMaterial({ color: 0x4444ff, wireframe: false, metalness: 0.2, roughness: 0.9, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2.5;
            scene.add(mesh);
            const light = new THREE.PointLight(0x88ccff, 2, 120);
            light.position.set(0, 20, 20);
            scene.add(light, new THREE.AmbientLight(0xffffff, 0.35));
            const noise = new SimplexNoise();
            camera.position.set(0, 10, 22);
            return (data, time) => {
                const arr = geo.attributes.position.array;
                const t = time*0.0003;
                const bass = data[20]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = arr[i+0];
                    const y = arr[i+1];
                    const n = noise.noise3d(x*0.05, y*0.05, t)*2.0;
                    arr[i+2] = n + bass*3.0;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.material.color.setHSL((t*0.2 + bass*0.3)%1, 0.8, 0.5);
                light.intensity = 1.5 + bass*2.5;
            };
        };

        const sceneHexGrid = (scene, camera) => {
            const group = new THREE.Group();
            const hexes = [];
            const radius = 0.25;
            const rows = 22, cols = 22;
            for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                    const x = (c + (r%2?0.5:0)) * radius*1.8 - cols*radius*0.9;
                    const y = r * radius*1.6 - rows*radius*0.8;
                    const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 6, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, metalness: 0.1, roughness: 0.7 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x, y, 0);
                    m.rotation.x = Math.PI/2;
                    group.add(m);
                    hexes.push(m);
                }
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xff66ff, 1.6, 60);
            light.position.set(0, 0, 10);
            scene.add(light, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / hexes.length) || 1;
                const t = time*0.001;
                hexes.forEach((h, i) => {
                    const v = data[(i*step)%data.length]/255;
                    h.scale.z = 0.4 + v*2.8;
                    const hue = (v*0.6 + ((i%cols)/cols) + t*0.1)%1;
                    h.material.color.setHSL(hue, 1, 0.5);
                    h.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z = Math.sin(t*0.5)*0.2;
            };
        };

        const sceneRibbons = (scene, camera) => {
            const group = new THREE.Group();
            const ribbons = [];
            const createRibbon = (color) => {
                const points = [];
                for(let i=0;i<80;i++){
                    points.push(new THREE.Vector3(i*0.08, Math.sin(i*0.2)*0.4, 0));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tube = new THREE.TubeGeometry(curve, 200, 0.03, 8, false);
                const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.2, emissive: 0x000000 });
                const mesh = new THREE.Mesh(tube, mat);
                return mesh;
            };
            for(let i=0;i<6;i++){
                const hue = i/6;
                const col = new THREE.Color().setHSL(hue, 1, 0.6);
                const m = createRibbon(col);
                m.position.y = (i-3)*0.4;
                m.position.x = -3;
                group.add(m);
                ribbons.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.6), group);
            const light = new THREE.PointLight(0x66ffff, 2, 40);
            light.position.set(0, 2, 8);
            scene.add(light);
            camera.position.set(0, 2, 10);
            return (data, time) => {
                const bass = data[12]/255;
                const t = time*0.0012;
                ribbons.forEach((m, i) => {
                    m.rotation.y = t*(i%3+1);
                    m.rotation.x = Math.sin(t + i)*0.3;
                    m.position.x = -3 + Math.sin(t*0.7 + i)*2.5 + bass*2.0;
                });
                group.rotation.z = Math.sin(t*0.6)*0.2;
                light.intensity = 1.2 + bass*2.0;
            };
        };

        // --- Infinity Pattern Tunnels ---
        const sceneInfinityTunnel = (scene, camera, composer) => {
            const rings = [];
            const count = 64;
            const baseRadius = 2.2;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(baseRadius, 0.06, 12, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.0;
                rings.push(m);
                scene.add(m);
            }
            const after = new AfterimagePass(0.88);
            composer.addPass(after);
            camera.position.z = 4;
            return (data, time) => {
                const t = time * 0.001;
                const bass = data[10]/255;
                rings.forEach((r, i) => {
                    // Figure-eight cross-section via Lissajous pattern
                    const phase = (i*0.22) + t*1.2;
                    r.position.x = Math.sin(phase) * (baseRadius * 0.6);
                    r.position.y = Math.sin(phase*2.0) * (baseRadius * 0.35);
                    r.position.z += 0.18 + bass*0.8;
                    if(r.position.z > 2.5) r.position.z -= count*1.0;
                    const hue = ((i/count) + t*0.05) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.material.opacity = 0.35 + bass*0.6;
                    r.rotation.x = phase*0.2;
                    r.rotation.y = -phase*0.15;
                });
                camera.rotation.z = Math.sin(t*0.8)*0.2;
            };
        };

        const sceneInfinityMirror = (scene, camera, composer) => {
            const frames = [];
            const count = 40;
            for(let i=0;i<count;i++){
                const geo = new THREE.RingGeometry(0.8, 3.0, 6, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.z = -i*1.4;
                frames.push(ring);
                scene.add(ring);
            }
            const after = new AfterimagePass(0.9);
            composer.addPass(after);
            camera.position.z = 3.8;
            return (data, time) => {
                const t = time*0.001;
                const mid = data[24]/255;
                frames.forEach((f, i) => {
                    f.position.z += 0.14 + mid*0.7;
                    if(f.position.z > 2.5) f.position.z -= count*1.4;
                    const s = 0.9 + Math.sin(i*0.2 + t*2.0)*0.08 + mid*0.2;
                    f.scale.set(s, s, s);
                    f.rotation.z = t*0.7 + i*0.05;
                    const hue = ((i/count) + t*0.1) % 1;
                    f.material.color.setHSL(hue, 1, 0.65);
                    f.material.opacity = 0.3 + mid*0.7;
                });
            };
        };
        // --- Kaleidoscope Shader ---
        const KaleidoShader = {
            uniforms: {
                tDiffuse: { value: null },
                sides: { value: 6.0 },
                angle: { value: 0.0 },
                rotation: { value: 0.0 },
                time: { value: 0.0 },
                gain: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float sides;
                uniform float angle;
                uniform float rotation;
                uniform float time;
                uniform float gain;
                varying vec2 vUv;
                
                float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
                float noise(vec2 p){
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f*f*(3.0-2.0*f);
                    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
                }
                float fbm(vec2 p){
                    float v = 0.0;
                    float a = 0.5;
                    for(int i=0;i<5;i++){
                        v += a * noise(p);
                        p = p * 2.0 + vec2(23.1, 17.7);
                        a *= 0.5;
                    }
                    return v;
                }
                vec3 palette(float t){
                    return 0.5 + 0.5*cos(6.2831853*(vec3(0.0,0.33,0.67) + t));
                }
                vec4 fractalColor(vec2 uv){
                    // Centered uv for fractal evolution
                    vec2 q = uv - 0.5;
                    float r = length(q);
                    float ang = atan(q.y, q.x);
                    vec2 p = vec2(cos(ang), sin(ang)) * (r * 2.2);
                    float f = fbm(p * 1.8 + vec2(time*0.15, -time*0.11 + gain*0.3));
                    vec3 col = palette(f + r*0.25 + gain*0.2);
                    // Radial darkening to avoid bright center
                    float vign = smoothstep(0.95, 0.3, r);
                    return vec4(col * vign, 1.0);
                }
                void main() {
                    vec2 uv = vUv - 0.5;
                    float r = length(uv);
                    float a = atan(uv.y, uv.x) + rotation;
                    float sector = 6.28318530718 / max(1.0, sides);
                    a = mod(a, sector);
                    a = abs(a - sector * 0.5);
                    a += angle;
                    vec2 pos = vec2(cos(a), sin(a)) * r;
                    vec2 sampleUv = pos + 0.5;
                    bool inBounds = all(greaterThanEqual(sampleUv, vec2(0.0))) && all(lessThanEqual(sampleUv, vec2(1.0)));
                    vec4 src = texture2D(tDiffuse, clamp(sampleUv, 0.0, 1.0));
                    vec4 fractCol = fractalColor(sampleUv);
                    // Blend: use fractal when out-of-bounds, otherwise softly mix by radial factor to eliminate white cores
                    float mixAmt = smoothstep(0.0, 0.35, r) * 0.7 + gain*0.2;
                    vec4 col = mix(src, fractCol, mixAmt);
                    if(!inBounds){
                        col = fractCol;
                    }
                    gl_FragColor = col;
                }
            `
        };

        const RadialZoomShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    vec2 toCenter = center - vUv;
                    float offset = strength * 0.02;
                    for (float t = 0.0; t <= 1.0; t += 0.1) {
                        vec2 sampleUv = vUv + toCenter * t * offset;
                        color += texture2D(tDiffuse, sampleUv);
                        total += 1.0;
                    }
                    gl_FragColor = color / total;
                }
            `
        };

        // Helper: build a simple colorful source for kaleidoscope
        function buildKaleidoSource(scene) {
            const group = new THREE.Group();
            const num = 24;
            for(let i=0;i<num;i++){
                const hue = i/num;
                const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6) });
                const geo = new THREE.TorusKnotGeometry(0.5 + (i%6)*0.05, 0.12, 90, 18, 2 + (i%3), 3 + (i%4));
                const m = new THREE.Mesh(geo, mat);
                m.position.set(Math.cos(i)*2.2, Math.sin(i*1.3)*1.2, -1 - (i%5)*0.2);
                m.rotation.x = i*0.2;
                m.rotation.y = i*0.15;
                group.add(m);
            }
            scene.add(group);
            return group;
        }

        const sceneKaleido = (sides) => (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            pass.uniforms.sides.value = sides;
            composer.addPass(pass);
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[12]/255;
                group.rotation.y = time*0.0006 + bass*0.2;
                group.rotation.x = Math.sin(time*0.0004)*0.3;
                pass.uniforms.rotation.value = time*0.0002 + bass*0.6;
                pass.uniforms.angle.value = Math.sin(time*0.0005)*0.5;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = bass;
            };
        };

        const sceneKaleidoSpiral = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            composer.addPass(pass);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[6]/255;
                pass.uniforms.sides.value = 5.0 + Math.floor((Math.sin(time*0.0007)+1.0)*3.5); // 5..12
                pass.uniforms.rotation.value = time*0.00035 + bass*0.8;
                pass.uniforms.angle.value = Math.cos(time*0.0006)*0.8;
                group.rotation.y += 0.002 + bass*0.02;
                group.rotation.z = Math.sin(time*0.0003)*0.4;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = (data[12]+data[24])/(2.0*255.0);
            };
        };

        const sceneKaleidoLayered = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const k1 = new ShaderPass(KaleidoShader);
            const k2 = new ShaderPass(KaleidoShader);
            k1.uniforms.sides.value = 7.0;
            k2.uniforms.sides.value = 11.0;
            composer.addPass(k1);
            composer.addPass(k2);
            camera.position.z = 5;
            // Smoothed, time-integrated rotations to avoid jitter
            let rot1 = 0, rot2 = 0, rotY = 0, rotX = 0;
            let speed1 = 0.00022, speed2 = -0.00026, speedY = 0.00028, speedX = 0.00018;
            let gSmooth = 0;
            let lastTime = 0;
            return (data, time) => {
                const gRaw = (data[6] + data[10] + data[12] + data[24]) / (4.0 * 255.0);
                gSmooth = gSmooth + (gRaw - gSmooth) * 0.08; // low-pass filter
                const dt = lastTime ? (time - lastTime) : 16.0; // ms
                lastTime = time;
                // Gently modulate speeds with smoothed gain
                const target1 = 0.00022 + gSmooth * 0.00040;
                const target2 = -0.00026 - gSmooth * 0.00035;
                const targetY = 0.00028 + gSmooth * 0.00025;
                const targetX = 0.00018 + gSmooth * 0.00010;
                speed1 += (target1 - speed1) * 0.05;
                speed2 += (target2 - speed2) * 0.05;
                speedY += (targetY - speedY) * 0.05;
                speedX += (targetX - speedX) * 0.05;
                // Integrate rotations (smooth)
                rot1 += speed1 * dt;
                rot2 += speed2 * dt;
                rotY += speedY * dt;
                rotX += speedX * dt;
                group.rotation.x = rotX;
                group.rotation.y = rotY;
                k1.uniforms.rotation.value = rot1;
                k2.uniforms.rotation.value = rot2;
                // Slow, continuous angle sweep
                k1.uniforms.angle.value = Math.sin(time * 0.00025) * 0.55;
                k2.uniforms.angle.value = Math.cos(time * 0.00023) * 0.55;
                // Pass time/gain to shaders
                const tSec = time * 0.001;
                k1.uniforms.time.value = tSec;
                k2.uniforms.time.value = tSec;
                k1.uniforms.gain.value = gSmooth;
                k2.uniforms.gain.value = gSmooth * 0.85;
            };
        };

        const sceneKaleidoZoom = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const kaleido = new ShaderPass(KaleidoShader);
            const zoom = new ShaderPass(RadialZoomShader);
            composer.addPass(kaleido);
            composer.addPass(zoom);
            camera.position.z = 4.5;
            return (data, time) => {
                const bass = data[14]/255;
                group.rotation.y = time*0.0005 + bass*0.3;
                kaleido.uniforms.sides.value = 10.0;
                kaleido.uniforms.rotation.value = time*0.00025;
                zoom.uniforms.center.value.set(0.5, 0.5);
                zoom.uniforms.strength.value = 0.1 + bass*0.6;
                kaleido.uniforms.time.value = time*0.001;
                kaleido.uniforms.gain.value = (data[10]+data[14]+data[18])/(3.0*255.0);
            };
        };

        // --- Self-Replicating / Fractal Scenes ---
        const sceneMengerSponge = (scene, camera) => {
            const depth = 2; // keep counts reasonable
            const positions = [];
            function addLevel(center, size, d){
                if(d === 0){
                    positions.push({ center, size });
                    return;
                }
                const step = size / 3;
                for(let x=0;x<3;x++){
                    for(let y=0;y<3;y++){
                        for(let z=0;z<3;z++){
                            // Skip the center cross sections
                            const mid = (x===1) + (y===1) + (z===1);
                            if(mid >= 2) continue;
                            const nx = center.x + (x-1)*step;
                            const ny = center.y + (y-1)*step;
                            const nz = center.z + (z-1)*step;
                            addLevel(new THREE.Vector3(nx, ny, nz), step, d-1);
                        }
                    }
                }
            }
            addLevel(new THREE.Vector3(0,0,0), 6, depth);
            const count = positions.length;
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.3, roughness: 0.6, emissive: 0x000000 });
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            const dummy = new THREE.Object3D();
            positions.forEach((p, i) => {
                dummy.position.copy(p.center);
                dummy.scale.setScalar(p.size * 0.95);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            });
            mesh.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(6, 8, 10);
            scene.add(light, mesh);
            camera.position.set(0, 0, 14);
            return (data, time) => {
                const g = (data[6]+data[12]+data[24])/(3*255);
                mesh.rotation.x = time*0.0003 + g*0.4;
                mesh.rotation.y = time*0.0004 + g*0.5;
                mat.emissiveIntensity = 0.2 + g*2.0;
                const hue = (time*0.00008 + g*0.3) % 1;
                mat.color.setHSL(hue, 0.7, 0.6);
            };
        };

        const sceneSierpinskiTetra = (scene, camera) => {
            // Base tetra geometry
            const r = 1;
            const v = [
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1),
                new THREE.Vector3(1, -1, -1)
            ];
            const base = new THREE.TetrahedronGeometry(r, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff88aa, metalness: 0.2, roughness: 0.7 });
            const depth = 4;
            const transforms = [];
            function add(level, center, scale){
                if(level === 0){
                    transforms.push({ center, scale });
                    return;
                }
                const s = scale * 0.5;
                for(let i=0;i<4;i++){
                    add(level-1, new THREE.Vector3(
                        center.x + v[i].x * s,
                        center.y + v[i].y * s,
                        center.z + v[i].z * s
                    ), s);
                }
            }
            add(depth, new THREE.Vector3(0,0,0), 3.0);
            const inst = new THREE.InstancedMesh(base, mat, transforms.length);
            const dummy = new THREE.Object3D();
            transforms.forEach((t, i) => {
                dummy.position.copy(t.center);
                dummy.scale.setScalar(t.scale);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.PointLight(0xff66ff, 2.4, 100);
            light.position.set(6, 6, 12);
            scene.add(light, inst);
            camera.position.set(0, 0, 16);
            return (data, time) => {
                const bass = data[8]/255;
                inst.rotation.y = time*0.00035 + bass*0.6;
                inst.rotation.x = time*0.0002;
                const hue = (time*0.00012) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                light.intensity = 1.4 + bass*3.0;
            };
        };

        const sceneGameOfLife = (scene, camera) => {
            const W = 128, H = 128;
            const cells = new Uint8Array(W*H);
            const nextCells = new Uint8Array(W*H);
            // random init
            for(let i=0;i<W*H;i++){ cells[i] = Math.random() < 0.15 ? 1 : 0; }
            const data = new Uint8Array(W*H*3);
            const tex = new THREE.DataTexture(data, W, H, THREE.RGBFormat);
            tex.needsUpdate = true;
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.95 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), mat);
            scene.add(plane);
            camera.position.z = 10;
            function step() {
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        let n = 0;
                        for(let dy=-1;dy<=1;dy++){
                            for(let dx=-1;dx<=1;dx++){
                                if(dx===0 && dy===0) continue;
                                const nx = (x+dx+W)%W;
                                const ny = (y+dy+H)%H;
                                n += cells[ny*W + nx];
                            }
                        }
                        const c = cells[idx];
                        nextCells[idx] = (c===1 && (n===2 || n===3)) || (c===0 && n===3) ? 1 : 0;
                    }
                }
                cells.set(nextCells);
            }
            let acc = 0;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3*255);
                // step a few times per second + boost with audio
                acc += 0.016 + g*0.05;
                while(acc > 0.1){ step(); acc -= 0.1; }
                // write texture
                const t = time*0.0002;
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        const alive = cells[idx];
                        const i3 = idx*3;
                        const hue = (t + x/W*0.3 + y/H*0.2) % 1;
                        const c = alive ? hue : 0.0;
                        // hsv to rgb approx via palette
                        const r = 0.5 + 0.5*Math.cos(6.2831*(c + 0.0));
                        const gch = 0.5 + 0.5*Math.cos(6.2831*(c + 0.33));
                        const b = 0.5 + 0.5*Math.cos(6.2831*(c + 0.67));
                        data[i3+0] = Math.floor(r*255);
                        data[i3+1] = Math.floor(gch*255);
                        data[i3+2] = Math.floor(b*255);
                    }
                }
                tex.needsUpdate = true;
                plane.rotation.z = Math.sin(time*0.0003)*0.2;
                plane.scale.setScalar(1.0 + g*0.3);
            };
        };

        // Mandelbrot (shader)
        const sceneMandelbrot = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                center: { value: new THREE.Vector2(-0.5, 0.0) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 center;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 c = center + uv / zoom;
                        vec2 z = vec2(0.0);
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            float x = (z.x*z.x - z.y*z.y) + c.x;
                            float y = (2.0*z.x*z.y) + c.y;
                            z = vec2(x,y);
                            if(dot(z,z) > 4.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.5), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                const baseZoom = 0.85 + Math.sin(time*0.0001)*0.15;
                uni.zoom.value = 1.5 + baseZoom * (1.0 + g*4.0);
                uni.center.value.set(-0.5 + Math.sin(time*0.00008)*0.15, Math.cos(time*0.00006)*0.1);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Julia Set (shader)
        const sceneJulia = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                c: { value: new THREE.Vector2(-0.70176, -0.3842) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 c;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 z = uv / zoom * 2.0;
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                            if(dot(z,z) > 16.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.55), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[8]+audio[16]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                uni.zoom.value = 1.4 + 0.6*Math.sin(time*0.0002) + g*2.2;
                const ang = time*0.00015;
                uni.c.value.set(Math.cos(ang)*0.7, Math.sin(ang*1.3)*0.5);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Barnsley Fern (points)
        const sceneBarnsleyFern = (scene, camera) => {
            const num = 30000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x66ff99, size: 0.03, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 8;
            let x = 0, y = 0;
            function step() {
                const r = Math.random();
                let nx, ny;
                if (r < 0.01) { nx = 0.0; ny = 0.16*y; }
                else if (r < 0.86) { nx = 0.85*x + 0.04*y; ny = -0.04*x + 0.85*y + 1.6; }
                else if (r < 0.93) { nx = 0.2*x - 0.26*y; ny = 0.23*x + 0.22*y + 1.6; }
                else { nx = -0.15*x + 0.28*y; ny = 0.26*x + 0.24*y + 0.44; }
                x = nx; y = ny;
            }
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                for (let i=0;i<num;i++) {
                    step();
                    positions[i*3+0] = x*1.6 - 2.0;
                    positions[i*3+1] = y*1.6 - 3.0;
                    positions[i*3+2] = 0;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0001 + g*0.5) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                points.rotation.z = Math.sin(time*0.0003)*0.1;
                points.scale.setScalar(1.0 + g*0.2);
            };
        };

        // Sailing Ship (stylized low-poly with audio-reactive sea)
        /* Removed Sailing Ship visualizer per request */
        /* const sceneSailingShip = (scene, camera) => {
            const group = new THREE.Group();
            // Sea plane (dynamic wave via vertex displacement in JS)
            const seaSize = 40;
            const seaSeg = 128;
            const seaGeo = new THREE.PlaneGeometry(seaSize, seaSize, seaSeg, seaSeg);
            const seaMat = new THREE.MeshStandardMaterial({ color: 0x115577, metalness: 0.0, roughness: 0.9, transparent: true, opacity: 0.95, side: THREE.DoubleSide });
            const sea = new THREE.Mesh(seaGeo, seaMat);
            sea.rotation.x = -Math.PI/2;
            sea.position.y = -1.0;
            group.add(sea);
            // Ship: hull
            const hullMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b, metalness: 0.1, roughness: 0.8, emissive: 0x000000 });
            const hull = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.6, 1.0), hullMat);
            hull.position.y = -0.4;
            group.add(hull);
            // Prow and stern wedges
            const prow = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1.0, 4), hullMat);
            prow.rotation.z = Math.PI/2;
            prow.position.set(1.9, -0.4, 0);
            group.add(prow);
            const stern = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.8, 4), hullMat);
            stern.rotation.z = -Math.PI/2;
            stern.position.set(-1.9, -0.4, 0);
            group.add(stern);
            // Mast
            const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 3.2, 12), new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness: 0.2, roughness: 0.6 }));
            mast.position.y = 1.0;
            group.add(mast);
            // Sails
            const sailMat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.0, roughness: 0.9, side: THREE.DoubleSide, emissive: 0x101010, emissiveIntensity: 0.08 });
            const sail1 = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 2.0), sailMat);
            sail1.position.set(0.6, 1.1, 0);
            sail1.rotation.y = Math.PI/10;
            group.add(sail1);
            const sail2 = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.6), sailMat);
            sail2.position.set(-0.3, 0.9, 0);
            sail2.rotation.y = Math.PI/12;
            group.add(sail2);
            // Flag
            const flag = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.25), new THREE.MeshStandardMaterial({ color: 0xff3366, side: THREE.DoubleSide, metalness: 0, roughness: 1 }));
            flag.position.set(0, 2.0, 0);
            flag.rotation.y = Math.PI/8;
            group.add(flag);
            // Lights
            const amb = new THREE.AmbientLight(0xffffff, 0.45);
            const sun = new THREE.DirectionalLight(0xffe0b0, 0.9);
            sun.position.set(4, 6, 3);
            scene.add(amb, sun, group);
            camera.position.set(0, 1.6, 7.5);
            camera.lookAt(0, 0.4, 0);
            // Sea wave data
            const basePos = sea.geometry.attributes.position.array.slice();
            const pos = sea.geometry.attributes.position;
            return (data, time) => {
                const t = time * 0.001;
                const bass = data[8] / 255;
                const mid = data[18] / 255;
                // Bobbing and slight roll with audio
                const bob = Math.sin(t * 1.2) * (0.05 + bass * 0.12);
                const roll = Math.sin(t * 0.9) * (0.03 + mid * 0.08);
                group.position.y = bob;
                group.rotation.z = roll;
                group.rotation.y = Math.sin(t * 0.3) * 0.05;
                // Flag flutter
                flag.rotation.y = Math.PI/8 + Math.sin(t*6.0 + bass*4.0)*0.25;
                // Sails subtle billow
                sail1.position.z = Math.sin(t*1.5) * 0.08;
                sail2.position.z = Math.cos(t*1.7) * 0.06;
                // Sea waves (displace Y of plane)
                for (let i = 0; i < pos.count; i++) {
                    const ix = i*3;
                    const x = basePos[ix+0];
                    const z = basePos[ix+2];
                    const w1 = Math.sin(x*0.6 + t*1.8) * 0.15;
                    const w2 = Math.cos(z*0.55 - t*1.3) * 0.12;
                    const w3 = Math.sin((x+z)*0.25 + t*2.2) * (0.08 + bass*0.22 + mid*0.1);
                    pos.array[ix+1] = -1.0 + w1 + w2 + w3;
                }
                pos.needsUpdate = true;
                sea.geometry.computeVertexNormals();
                // Color tint by audio
                const hue = (t*0.06 + bass*0.4) % 1;
                seaMat.color.setHSL(0.55 + 0.05*Math.sin(t*0.2), 0.6, 0.35 + bass*0.15);
                sailMat.emissiveIntensity = 0.08 + bass*0.35;
                hullMat.emissive.setHSL(hue, 0.8, 0.2);
                sun.intensity = 0.8 + bass*0.6;
            };
        }; */

        // Lorenz Attractor (line)
        const sceneLorenz = (scene, camera) => {
            const maxPts = 6000;
            const positions = new Float32Array(maxPts*3);
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            camera.position.z = 30;
            let x = 0.01, y = 0.0, z = 0.0;
            const dt = 0.005;
            const sigma = 10.0, rho = 28.0, beta = 8.0/3.0;
            let idx = 0;
            return (audio, time) => {
                const g = (audio[10]+audio[18])/(2.0*255.0);
                for (let k=0;k<10;k++) {
                    const dx = sigma*(y - x);
                    const dy = x*(rho - z) - y;
                    const dz = x*y - beta*z;
                    x += dx*dt;
                    y += dy*dt;
                    z += dz*dt;
                    positions[idx*3+0] = x;
                    positions[idx*3+1] = y;
                    positions[idx*3+2] = z - 20.0;
                    idx = (idx + 1) % maxPts;
                }
                geo.attributes.position.needsUpdate = true;
                line.rotation.y = time*0.0002 + g*0.4;
                line.rotation.x = Math.sin(time*0.0003)*0.2;
                const hue = (time*0.00008 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
            };
        };

        // Sierpinski Carpet (instanced)
        const sceneSierpinskiCarpet = (scene, camera) => {
            const depth = 4;
            const squares = [];
            function add(level, cx, cy, size) {
                if (level === 0) { squares.push({ cx, cy, size }); return; }
                const s3 = size/3;
                for (let dx=-1; dx<=1; dx++){
                    for (let dy=-1; dy<=1; dy++){
                        if (dx === 0 && dy === 0) continue;
                        add(level-1, cx + dx*s3, cy + dy*s3, s3);
                    }
                }
            }
            add(depth, 0, 0, 6);
            const geo = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const inst = new THREE.InstancedMesh(geo, mat, squares.length);
            const dummy = new THREE.Object3D();
            squares.forEach((s, i) => {
                dummy.position.set(s.cx, s.cy, 0);
                dummy.scale.set(s.size*0.95, s.size*0.95, 1);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(inst);
            camera.position.z = 10;
            return (audio, time) => {
                const g = (audio[4]+audio[12]+audio[28])/(3.0*255.0);
                const hue = (time*0.00015 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
                inst.rotation.z = Math.sin(time*0.0003)*0.2;
                inst.scale.setScalar(1.0 + g*0.25);
            };
        };

        // --- Emoji Helpers and Scenes ---
        function createEmojiTexture(char) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '200px Apple Color Emoji, Noto Color Emoji, Segoe UI Emoji, EmojiOne Mozilla, Twemoji Mozilla, Segoe UI Symbol, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(char, size/2, size/2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const EMOJIS = ['ðŸŽµ','âœ¨','ðŸ”¥','ðŸ’«','ðŸŒˆ','ðŸ’¥','â¤ï¸','ðŸŒ€','ðŸŒŸ','ðŸ¤–','ðŸŽ§','ðŸŽ‰','ðŸŽ‡','ðŸ›°ï¸','ðŸª','âš¡ï¸'];

        const sceneEmojiSwarm = (scene, camera) => {
            const sprites = [];
            const velocities = [];
            const count = 240;
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            for(let i=0;i<count;i++){
                const tex = textures[i % textures.length];
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                const spr = new THREE.Sprite(mat);
                spr.position.set((Math.random()-0.5)*18, (Math.random()-0.5)*10, (Math.random()-0.5)*12);
                const s = Math.random()*0.7 + 0.3;
                spr.scale.set(s, s, 1);
                sprites.push(spr);
                velocities.push(new THREE.Vector3((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03));
                scene.add(spr);
            }
            camera.position.z = 8;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                sprites.forEach((s, i) => {
                    const v = velocities[i];
                    // Simple cohesion toward origin + slight orbit
                    const toCenter = s.position.clone().multiplyScalar(-0.002);
                    v.add(toCenter);
                    v.x += Math.sin(t + i*0.1)*0.001;
                    v.y += Math.cos(t*0.8 + i*0.07)*0.001;
                    s.position.add(v);
                    // Wrap bounds
                    if(s.position.x > 10) s.position.x = -10;
                    if(s.position.x < -10) s.position.x = 10;
                    if(s.position.y > 6) s.position.y = -6;
                    if(s.position.y < -6) s.position.y = 6;
                    if(s.position.z > 8) s.position.z = -8;
                    if(s.position.z < -8) s.position.z = 8;
                    // Pulse size with bass
                    const base = 0.3 + (i%5)*0.04;
                    const pulse = base + bass*0.8;
                    s.scale.set(pulse, pulse, 1);
                    s.material.opacity = 0.6 + bass*0.4;
                });
                camera.rotation.z = Math.sin(t*0.4)*0.1;
            };
        };

        /* Removed Emoji Orbits visualizer per request */
        /* const sceneEmojiOrbits = (scene, camera) => {
            const group = new THREE.Group();
            scene.add(group);
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            const rings = [];
            for(let r=0;r<5;r++){
                const ringGroup = new THREE.Group();
                const num = 14 + r*5;
                const radius = 2.2 + r*1.4;
                for(let i=0;i<num;i++){
                    const tex = textures[Math.floor(Math.random()*textures.length)];
                    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                    const spr = new THREE.Sprite(mat);
                    const a = (i/num)*Math.PI*2;
                    spr.position.set(Math.cos(a)*radius, Math.sin(a)*radius, -r*0.4);
                    const s = 0.22 + r*0.09;
                    spr.scale.set(s, s, 1);
                    ringGroup.add(spr);
                }
                group.add(ringGroup);
                rings.push({ group: ringGroup, radius });
            }
            camera.position.z = 8;
            let lastSwapMs = 0;
            return (data, time) => {
                const bass = data[8]/255;
                const mid = data[24]/255;
                rings.forEach((r, i) => {
                    r.group.rotation.z += 0.0006 + bass*0.006 + i*0.00025;
                    r.group.position.z = Math.sin(time*0.00025 + i)*0.8;
                    r.group.children.forEach((spr, j) => {
                        spr.material.rotation = time*0.0002 + j*0.03;
                        const s0 = spr.scale.x;
                        const pulse = s0 * (0.96 + mid*0.25*Math.sin(time*0.003 + j));
                        spr.scale.set(pulse, pulse, 1);
                    });
                });
                if (time - lastSwapMs > 4000) {
                    lastSwapMs = time;
                    const ring = rings[Math.floor(Math.random()*rings.length)];
                    if (ring && ring.group.children.length > 0) {
                        const idx = Math.floor(Math.random()*ring.group.children.length);
                        const spr = ring.group.children[idx];
                        const tex = textures[Math.floor(Math.random()*textures.length)];
                        spr.material.map = tex;
                        spr.material.needsUpdate = true;
                    }
                }
                group.rotation.x = Math.sin(time*0.0004)*0.2;
                group.rotation.y = Math.cos(time*0.0003)*0.2;
            };
        }; */

        // --- ENGINE: ProjectM (Filtered Presets) ---
        class MilkdropPresetEngine {
            constructor(label, filterFn, options = {}) {
                this.name = `ProjectM: ${label}`;
                this.filterFn = typeof filterFn === 'function' ? filterFn : (() => true);
                this.options = { invert: !!options.invert };
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null;
                this.transitionSec = visualSettings.transitionSec;
                this.presets = butterchurnPresets.getPresets?.() || {};
                const allKeys = Object.keys(this.presets);
                this.filteredKeys = allKeys.filter(k => {
                    try { return !!this.filterFn(k); } catch { return false; }
                });
                // If too few presets match, fall back to full set so it cycles
                if (this.filteredKeys.length < 2) this.filteredKeys = allKeys;
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.filteredKeys.length));
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                // Apply color inversion if requested
                if (this.options.invert) {
                    this.canvas.style.filter = 'invert(1)';
                }
                container.appendChild(this.canvas);
                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);
                window.addEventListener('resize', this.resizeHandler);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if(this.filteredKeys.length === 0) return;
                const key = this.filteredKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
                try { setBottomTextRandomColor(); } catch(e) {}
            }

            nextPreset() {
                if(this.filteredKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if(this.filteredKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.filteredKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 18;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 36;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            onResize() {
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- MASTER CONTROL ---
        const modes = [
            new MilkdropEngine(),
            new MilkdropEngineV2(),
            new MilkdropEngineV3(),
            new ThreeEngine("Audio Bars (Vertical Mirror)", sceneBarsVerticalMirror),
            new ThreeEngine("Audio Bars", sceneBars),
            new ThreeEngine("Audio Bars (Circle)", sceneBarsCircle),
            new ThreeEngine("Audio Bars 3D", sceneBars3D),
            new ThreeEngine("Audio Bars: Vortex", sceneBarsVortex),
            new ThreeEngine("Neon Sphere", sceneSphere),
            new ThreeEngine("Electro Sphere", sceneElectroSphere),
            new ThreeEngine("Photon Shell", scenePhotonShell),
			new ThreeEngine("Pulse Orb", scenePulseOrb),
            new ThreeEngine("Cyber Tunnel", sceneTunnel),
            new ThreeEngine("Starfield", sceneStarfield),
            new ThreeEngine("Wave Grid", sceneWaveGrid),
            new ThreeEngine("Particles", sceneParticles),
            new ThreeEngine("Infinity Tunnel", sceneInfinityTunnel),
            new ThreeEngine("Neon Tunnel", sceneNeonTunnel),
            new ThreeEngine("Twist Tunnel", sceneTwistTunnel),
            new ThreeEngine("Particle Tunnel", sceneParticleTunnel),
            new ThreeEngine("Galaxy", sceneGalaxy),
            new ThreeEngine("Terrain", sceneTerrain),
            new ThreeEngine("Hex Grid", sceneHexGrid),
            new ThreeEngine("Mandelbrot", sceneMandelbrot),
            new ThreeEngine("Julia Set", sceneJulia),
            new ThreeEngine("Lorenz Attractor", sceneLorenz),
            new ThreeEngine("Sierpinski Carpet", sceneSierpinskiCarpet),
            new ThreeEngine("Emoji Swarm", sceneEmojiSwarm),
            new ThreeEngine("Kaleidoscope Layered", sceneKaleidoLayered),
			new ThreeEngine("Kaleidoscope Zoom", sceneKaleidoZoom),
            // Colorful Butterchurn set (inverted colors) - moved after Kaleidoscope Zoom
            new MilkdropPresetEngine("Rainbow (Invert)", (k) => /rainbow|color|colour|spectrum|palette/i.test(k), { invert: true })
        ];

        function loadMode(index) {
            if(state.activeVisualizer) state.activeVisualizer.destroy();
            let idx = index;
            if(idx < 0) idx = modes.length - 1;
            if(idx >= modes.length) idx = 0;
            state.currentModeIdx = idx;
            state.activeVisualizer = modes[idx];
            // Persist last selected visualizer
            try {
                localStorage.setItem('lastModeIndex', String(idx));
                if (state.activeVisualizer && state.activeVisualizer.name) {
                    localStorage.setItem('lastModeName', state.activeVisualizer.name);
                }
            } catch(_) {}
            
            // UI Updates
            document.getElementById('mode-title').innerText = state.activeVisualizer.name;
            if(!(state.activeVisualizer && state.activeVisualizer.loadPreset)) {
                document.getElementById('mode-sub').innerText = "3D Interactive";
            }
            
            // Show/Hide Skip Button
            const skipBtn = document.getElementById('btn-skip-preset');
            if(state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') skipBtn.classList.remove('display-none');
            else skipBtn.classList.add('display-none');

            state.activeVisualizer.init();
            // Randomize bottom text color each time a mode loads
            setBottomTextRandomColor();
        }
        
        // Allow opening overlay by clicking the title area
        document.getElementById('mode-info').addEventListener('click', (e) => {
            e.stopPropagation();
            showOverlay();
        });

        // --- BINDINGS ---
        document.getElementById('btn-prev')?.addEventListener('click', () => { loadMode(state.currentModeIdx - 1); resetIdleTimer(); });
        document.getElementById('btn-next')?.addEventListener('click', () => { loadMode(state.currentModeIdx + 1); resetIdleTimer(); });
        const btnRadioEl = document.getElementById('btn-radio');
        if (btnRadioEl) btnRadioEl.addEventListener('click', playRadio);
        const btnMicEl = document.getElementById('btn-mic');
        if (btnMicEl) btnMicEl.addEventListener('click', useMic);
        const fileInputEl = document.getElementById('file-input');
        if (fileInputEl) fileInputEl.addEventListener('change', useFile);
        document.getElementById('btn-fullscreen')?.addEventListener('click', toggleFullscreen);
        const btnWebmPanelToggle = document.getElementById('btn-webm-panel-toggle');
        if (btnWebmPanelToggle) {
            btnWebmPanelToggle.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Toggle the Avatar/WebM Panel (which is now the right-side panel)
                if (typeof toggleBottomMenuPanel === 'function') {
                    toggleBottomMenuPanel();
                }
                resetIdleTimer();
            });
        }
        // Repurpose: WebM button opens Text-In panel instead of toggling WebM overlay
        if (webmBtn) {
            webmBtn.title = "Open Text-In Panel";
            webmBtn.addEventListener('click', (e) => { 
                e.preventDefault(); 
                e.stopPropagation(); 
                try { toggleTextInPanel(); } catch(_) {}
                resetIdleTimer(); 
            });
        }
        // Settings button now opens Mix Settings (right panel)
        function toggleMixPanel() {
            try {
                if (mixPanel.classList.contains('display-none') || !mixPanel.classList.contains('open')) {
                    try { refreshMixStationB(); } catch(_) {}
                    mixPanel.classList.remove('display-none');
                    requestAnimationFrame(() => { mixPanel.classList.add('open'); });
                } else {
                    mixPanel.classList.remove('open');
                    
                    // ADD THIS LINE: Prevent other panels from opening for 1.2 seconds
                    try { window.__panelGuardUntilMs = Date.now() + 1200; } catch(_) {}
                    
                    setTimeout(() => { mixPanel.classList.add('display-none'); }, 350);
                }
            } catch(_) {}
        }
        function showMicConfirm() {
            if (!micConfirm) { if (typeof useMic === 'function') useMic(); return; }
            micConfirm.style.display = 'flex';
        }
        function hideMicConfirm() {
            if (!micConfirm) return;
            micConfirm.style.display = 'none';
        }
        if (micOk) micOk.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            hideMicConfirm();
            try { useMic(); } catch(_) {}
        });
        if (micCancel) micCancel.addEventListener('click', (e) => {
            e.preventDefault(); e.stopPropagation();
            hideMicConfirm();
        });
        if (settingsBtn) {
            settingsBtn.title = "Mix Settings";
            settingsBtn.addEventListener('click', (e) => {
                e.preventDefault(); e.stopPropagation();
                toggleMixPanel();
                resetIdleTimer();
            });
        }
        if (mixClose) {
            mixClose.addEventListener('click', (e) => {
                e.preventDefault(); e.stopPropagation();
                mixPanel.classList.remove('open');
                
                // ADD THIS LINE: Prevent other panels from opening for 1.2 seconds
                try { window.__panelGuardUntilMs = Date.now() + 1200; } catch(_) {}
                
                setTimeout(() => { mixPanel.classList.add('display-none'); }, 350);
            });
        }
        // Populate second station select
        function refreshMixStationB() {
            if (!mixStationB) return;
            mixStationB.innerHTML = '';
            
            if (Array.isArray(stations) && stations.length > 0) {
                // Ensure index is valid
                if (typeof currentStationBIndex !== 'number' || currentStationBIndex < 0) {
                    currentStationBIndex = 0;
                }
                
                stations.forEach((s, i) => {
                    const opt = document.createElement('option');
                    opt.value = String(i);
                    opt.textContent = s.name || ('Station ' + (i+1));
                    mixStationB.appendChild(opt);
                });

                // RESTORE THE SAVED SELECTION
                mixStationB.value = String(currentStationBIndex);
            }
        }
        refreshMixStationB();
        // Crossfader handler (equal-power)
        function applyCrossfade(val) {
            const x = Math.max(0, Math.min(1, Number(val)||0));
            // Linear crossfade: exact 50/50 amplitude at midpoint
            const ga = 1 - x;
            const gb = x;
            if (state && state.streamAGain && state.streamBGain) {
                state.streamAGain.gain.value = ga;
                state.streamBGain.gain.value = gb;
            }
        }
        if (mixCross) {
            mixCross.addEventListener('input', () => applyCrossfade(mixCross.value));
            try { applyCrossfade(mixCross.value); } catch(_) {}
        }
        // Effect toggles
        function toggleFx(key, btn) {
            if (!state || !state.fx || !state.fx[key]) return;
            state.fx[key].on = !state.fx[key].on;
            if (btn) btn.classList.toggle('on', state.fx[key].on);
            rebuildEffectsChain();
        }
        if (fxLow) fxLow.addEventListener('click', () => toggleFx('low', fxLow));
        if (fxHigh) fxHigh.addEventListener('click', () => toggleFx('high', fxHigh));
        if (fxBass) fxBass.addEventListener('click', () => toggleFx('bass', fxBass));
        if (fxTreble) fxTreble.addEventListener('click', () => toggleFx('treble', fxTreble));
        if (fxEcho) {
            fxEcho.addEventListener('click', () => {
                // echo uses two nodes; we key off delay node's .on flag
                state.fx.echoDelay.on = !state.fx.echoDelay.on;
                state.fx.echoFeedback.on = state.fx.echoDelay.on;
                fxEcho.classList.toggle('on', state.fx.echoDelay.on);
                rebuildEffectsChain();
            });
        }
        if (fxDist) fxDist.addEventListener('click', () => toggleFx('distort', fxDist));
        if (fxArp) {
            fxArp.addEventListener('click', () => {
                state.fx.arp.on = !state.fx.arp.on;
                fxArp.classList.toggle('on', state.fx.arp.on);
                // Enable/disable modulation depth (map to +/- 600 Hz)
                state.fx.arp.lfoGain.gain.value = state.fx.arp.on ? 600 : 0;
                rebuildEffectsChain();
            });
        }
        if (fxTk) {
            fxTk.addEventListener('click', () => {
                state.fx.tk.on = !state.fx.tk.on;
                fxTk.classList.toggle('on', state.fx.tk.on);
                rebuildEffectsChain();
            });
        }
        // --- FIXED FX WAV LISTENER (Lightbulb) ---
        if (fxWav) {
            fxWav.addEventListener('click', (e) => {
                e.preventDefault();
                try { audioElSample.loop = !!sampleLoop; } catch(_) {}
                try { audioElSample.currentTime = 0; } catch(_) {}
                
                // Fix: Connect to mixInput (always on) instead of streamBGain
                try {
                    if (state.audioCtx) {
                        if (!state.sourceNodeSample) {
                            state.sourceNodeSample = state.audioCtx.createMediaElementSource(audioElSample);
                            state.sourceNodeSample.connect(state.mixInput);
                        }
                    }
                } catch(e) { console.warn(e); }

                audioElSample.play().then(()=>{ 
                    fxWav.classList.add('on'); 
                    setTimeout(()=>fxWav.classList.remove('on'), 300); 
                }).catch(()=>{});
            });
            fxWav.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                sampleLoop = !sampleLoop;
                try { audioElSample.loop = !!sampleLoop; } catch(_) {}
                fxWav.classList.toggle('on', sampleLoop);
            });
        }

        // --- FIXED BIND SAMPLE FUNCTION (Wav 1-6) ---
        function bindSample(btn, media, loopFlagKey, sourceKey) {
            if (!btn || !media) return;
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                try { media.loop = !!window[loopFlagKey]; } catch(_) {}
                try { media.currentTime = 0; } catch(_) {}
                
                // Fix: Connect to mixInput (always on) instead of streamBGain
                try {
                    if (state.audioCtx) {
                        if (!state[sourceKey]) {
                            state[sourceKey] = state.audioCtx.createMediaElementSource(media);
                            state[sourceKey].connect(state.mixInput);
                        }
                    }
                } catch(e) { console.warn(e); }
                
                media.play().then(()=>{ 
                    btn.classList.add('on'); 
                    setTimeout(()=>btn.classList.remove('on'), 300); 
                }).catch(()=>{});
            });
            btn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const nv = !window[loopFlagKey];
                window[loopFlagKey] = nv;
                try { media.loop = !!nv; } catch(_) {}
                btn.classList.toggle('on', nv);
            });
        }
        bindSample(fxWav1, audioElSample1, 'sampleLoop1', 'sourceNodeSample1');
        bindSample(fxWav2, audioElSample2, 'sampleLoop2', 'sourceNodeSample2');
        bindSample(fxWav3, audioElSample3, 'sampleLoop3', 'sourceNodeSample3');
        bindSample(fxWav4, audioElSample4, 'sampleLoop4', 'sourceNodeSample4');
        bindSample(fxWav5, audioElSample5, 'sampleLoop5', 'sourceNodeSample5');
        bindSample(fxWav6, audioElSample6, 'sampleLoop6', 'sourceNodeSample6');
        // Play/Stop B
        // Play/Stop B
        // Play/Stop B
        function playRadioB() {
            initAudio();
            let val = parseInt((mixStationB?.value)||'0', 10);
            if (isNaN(val)) val = 0;
            const idx = Math.max(0, Math.min(stations.length - 1, val));
            currentStationBIndex = idx; 
            const sel = stations[idx];
            if (!sel || !sel.url) return;

            const media = audioElB; 
            try { media.pause(); } catch(e) {}
            media.crossOrigin = "anonymous";
            media.src = sel.url;
            state.audioElB = media;

            try {
                if (!state.radioElementSourceB) {
                    state.radioElementSourceB = state.audioCtx.createMediaElementSource(media);
                }
                state.sourceNodeB = state.radioElementSourceB;
                try { state.sourceNodeB.disconnect(); } catch(e) {}
                
                // --- NEW ROUTING: Connect to EQ Chain B instead of direct Gain ---
                state.sourceNodeB.connect(state.eqB.high);
                
                rebuildEffectsChain();
                try { applyCrossfade(mixCross ? mixCross.value : 0); } catch(_) {}
            } catch(e) { console.warn("Web Audio setup failed:", e); }

            media.play().then(() => {
                updateMixBStatus();
            }).catch((e) => {
                console.warn("Stream B Playback Error:", e);
                updateMixBStatus();
            });
        }
        function stopRadioB() {
            // Stop the persistent DOM element
            if (audioElB) {
                try { audioElB.pause(); } catch(_) {}
                try { audioElB.removeAttribute('src'); } catch(_) {}
                try { audioElB.load(); } catch(_) {}
            }
            // We do not set state.audioElB to null here so the reference remains valid
            updateMixBStatus();
        }
        if (mixPlayB) mixPlayB.addEventListener('click', playRadioB);
        if (mixStopB) mixStopB.addEventListener('click', stopRadioB);
        // Monitor B status
        try {
            ['play','pause','ended','stalled','error','suspend','abort'].forEach(ev => {
                audioElB.addEventListener(ev, updateMixBStatus);
            });
        } catch(_) {}
        webmPrevBtn.addEventListener('click', () => { prevWebm(); resetIdleTimer(); });
        webmNextBtn.addEventListener('click', () => { nextWebm(); resetIdleTimer(); });
        // Remove legacy binding that opened the top menu; Mix Settings supersedes it.
		// Horizontal scroll wheel changes visual left/right (ignore when interacting with panels)
		document.addEventListener('wheel', (e) => {
			try {
				const horizIntent = (Math.abs(e.deltaX) > Math.abs(e.deltaY) ? Math.abs(e.deltaX) : (e.shiftKey ? Math.abs(e.deltaY) : 0));
				if (horizIntent > 5) {
					const inUi = !!(e.target && (e.target.closest('#top-menu-content') || e.target.closest('#settings-panel') || e.target.closest('#webm-settings-panel') || e.target.closest('#bottom-avatar-content')));
					if (!inUi) {
						// One step per gesture: lock during momentum and unlock after wheel quiets down
						if (!window.__wheelNavLocked) {
							window.__wheelNavLocked = true;
							if ((e.deltaX > 0) || (e.shiftKey && e.deltaY > 0)) loadMode(state.currentModeIdx + 1);
							else loadMode(state.currentModeIdx - 1);
							if (typeof resetIdleTimer === 'function') resetIdleTimer();
						}
						// Reset unlock timer to release lock shortly after wheel stops
						if (window.__wheelNavUnlockId) clearTimeout(window.__wheelNavUnlockId);
						window.__wheelNavUnlockId = setTimeout(() => { window.__wheelNavLocked = false; }, 220);
						e.preventDefault();
					}
				}
			} catch(_) {}
		}, { passive: false });
        settingsCloseBtn.addEventListener('click', () => { 
            if (settingsPanelTimer) { clearTimeout(settingsPanelTimer); settingsPanelTimer = null; }
            settingsPanel.classList.add('display-none');
            settingsPanel.style.opacity = '';
            settingsPanel.style.pointerEvents = '';
        });
        function scheduleSettingsPanelClose() {
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            settingsPanelTimer = setTimeout(() => {
                settingsPanel.style.opacity = '0';
                settingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { 
                    settingsPanel.classList.add('display-none'); 
                    settingsPanel.style.opacity = '';
                    settingsPanel.style.pointerEvents = '';
                }, 1200);
            }, 30000);
        }
        settingsApplyBtn.addEventListener('click', () => {
            // Read and clamp settings
            const minS = Math.max(3, Math.min(120, Number(inpShuffleMin.value) || 12));
            const maxS = Math.max(5, Math.min(180, Number(inpShuffleMax.value) || 25));
            const trans = Math.max(0, Math.min(10, Number(inpTransition.value) || 2.7));
            const px = Math.max(0.5, Math.min(3, Number(inpPixelRatio.value) || 1));
            visualSettings.shuffleMinSec = minS;
            visualSettings.shuffleMaxSec = maxS;
            visualSettings.transitionSec = trans;
            visualSettings.pixelRatio = px;
            // Apply if active is v2
            if(state.activeVisualizer && state.activeVisualizer instanceof MilkdropEngineV2) {
                state.activeVisualizer.applySettings?.();
            }
        });
        
        // Skip Preset Button Logic
        document.getElementById('btn-skip-preset').addEventListener('click', () => {
            if(state.activeVisualizer && state.activeVisualizer.nextPreset) {
                state.activeVisualizer.nextPreset();
            }
        });

        // --- RADIO: Load stations and UI ---
        async function loadStations() {
            try {
                const resp = await fetch('radio.txt');
                const txt = await resp.text();
                stations.length = 0;
                txt.split('\n').forEach((line) => {
                    const raw = line.trim();
                    if(!raw) return;
                    const parts = raw.split('|');
                    if(parts.length >= 2) {
                        const name = parts[0].trim();
                        const url = parts.slice(1).join('|').trim();
                        stations.push({ name, url });
                    }
                });
                // Make the first station the default selection if none chosen yet
                if ((typeof currentStationIndex !== 'number' || currentStationIndex < 0) && stations.length > 0) {
                    currentStationIndex = 0;
                    if (radioInputEl) radioInputEl.value = stations[0].url;
                }
                renderStationList();
                try { refreshMixStationB(); } catch(_) {}
            } catch(e) {
                console.warn('Failed to load radio.txt', e);
            }
        }

        function renderStationList() {
            radioListEl.innerHTML = '';
            stations.forEach((s, i) => {
                const item = document.createElement('div');
                item.className = 'radio-item';
                item.dataset.index = String(i);
                if(i === currentStationIndex) item.classList.add('active');
                const nameEl = document.createElement('div');
                nameEl.textContent = s.name;
                const goEl = document.createElement('div');
                goEl.textContent = 'âž¤';
                item.appendChild(nameEl);
                item.appendChild(goEl);
                item.addEventListener('click', () => {
                    setStation(i);
                });
                radioListEl.appendChild(item);
            });
        }

        function setStation(index) {
            if(index < 0 || index >= stations.length) return;
            // Push current station into history if switching to a different one
            if (!suppressHistoryPush && currentStationIndex !== -1 && currentStationIndex !== index) {
                // Avoid consecutive duplicates
                if (stationHistory.length === 0 || stationHistory[stationHistory.length - 1] !== currentStationIndex) {
                    stationHistory.push(currentStationIndex);
                    // Cap history size to the last 5 stations
                    if (stationHistory.length > 5) stationHistory.shift();
                }
            }
            currentStationIndex = index;
            const s = stations[index];
            if (radioInputEl) radioInputEl.value = s.url;
            showStationBanner(s.name);
            updateStationActiveHighlight();
            playRadio();
        }

        function updateStationActiveHighlight() {
            const children = Array.from(radioListEl.children);
            children.forEach((el) => {
                const idx = Number(el.dataset.index || -1);
                if(idx === currentStationIndex) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function pickRandomStation() {
            if(stations.length === 0) return;
            let idx = currentStationIndex;
            if(stations.length === 1) idx = 0;
            else {
                while(idx === currentStationIndex) {
                    idx = Math.floor(Math.random() * stations.length);
                }
            }
            setStation(idx);
        }

        function showRadioPanel() { 
            // Legacy panel removed: open top menu instead
            try { openTopMenuPanel(); } catch(e) {}
            if (!radioPanel) return;
            radioPanel.classList.remove('display-none'); 
            radioPanel.style.opacity = '1';
            radioPanel.style.pointerEvents = 'auto';
            scheduleRadioPanelClose();
        }
        function goPreviousStation() {
            // Pop from history; if empty, go random as a fail-safe
            if (!Array.isArray(stationHistory) || stationHistory.length === 0) {
                pickRandomStation();
                return;
            }
            const prevIdx = stationHistory.pop();
            if (typeof prevIdx === 'number' && prevIdx >= 0 && prevIdx < stations.length) {
                suppressHistoryPush = true;
                try {
                    setStation(prevIdx);
                } finally {
                    suppressHistoryPush = false;
                }
            } else {
                pickRandomStation();
            }
        }
        function hideRadioPanel() { 
            if (radioPanelTimer) { clearTimeout(radioPanelTimer); radioPanelTimer = null; }
            try { closeTopMenuPanel(); } catch(e) {}
            if (!radioPanel) return;
            radioPanel.classList.add('display-none'); 
            radioPanel.style.opacity = '';
            radioPanel.style.pointerEvents = '';
        }
        function toggleRadioPanel() {
            // Toggle top menu now
            try { toggleTopMenuPanel(); } catch(e) {}
            if (!radioPanel) return;
            if(radioPanel.classList.contains('display-none')) showRadioPanel();
            else hideRadioPanel();
        }
        function scheduleRadioPanelClose() {
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            radioPanelTimer = setTimeout(() => {
                if (radioPanel) {
                    radioPanel.style.opacity = '0';
                    radioPanel.style.pointerEvents = 'none';
                }
                setTimeout(() => { hideRadioPanel(); }, 1200);
            }, 30000);
        }

        // --- TEXT-IN PANEL & OVERLAY ---
        function showTextInPanel() {
            if (!textInPanel) return;
            textInPanel.classList.remove('display-none');
            void textInPanel.offsetWidth;
            textInPanel.classList.add('open');
        }
        function hideTextInPanel() {
            if (!textInPanel) return;
            textInPanel.classList.remove('open');
            setTimeout(() => { textInPanel.classList.add('display-none'); }, 350);
        }
        function toggleTextInPanel() {
            if (!textInPanel) return;
            if (textInPanel.classList.contains('display-none') || !textInPanel.classList.contains('open')) showTextInPanel();
            else hideTextInPanel();
        }
        function applyTextStyles(el, cfg) {
            if (!el || !cfg) return;
            el.style.fontFamily = cfg.font;
            el.style.color = cfg.color;
            el.style.fontSize = cfg.size + 'px';
            el.style.webkitTextStroke = (cfg.border > 0 ? (cfg.border + 'px ' + cfg.borderColor) : '0px transparent');
            const glowPx = Math.max(0, cfg.glow|0);
            
            // --- FIX START: Use correct config flag instead of wrong DOM element ---
            const useRandomGlowColor = (typeof cfg.glowColorRandom === 'boolean') 
                                        ? cfg.glowColorRandom 
                                        : (tiGlowColorRandCheck ? tiGlowColorRandCheck.checked : false);

            const glowColor = useRandomGlowColor
                ? randomGlowColor()
                : (
                    cfg.glowColor && /^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(cfg.glowColor)
                        ? cfg.glowColor
                        : cfg.color
                  );
            // --- FIX END ---

            const glow = glowPx > 0 ? `0 0 ${glowPx}px ${glowColor}` : '';
            const strokeShadow = (cfg.border > 0) ? `0 0 ${Math.max(1,cfg.border)}px ${cfg.borderColor}` : '';
            el.style.textShadow = [glow, strokeShadow].filter(Boolean).join(', ');
            el.style.filter = '';
        }
        function getTextConfigFromUi() {
            return {
                text: (tiText?.value || '').trim() || ' ',
                font: tiFont?.value || "'Segoe UI', sans-serif",
                color: tiColor?.value || '#ffffff',
                colorRandom: !!(tiColorRandCheck?.checked),
                size: Math.max(16, Math.min(200, Number(tiSize?.value)||64)),
                sizeMin: Math.max(0, Number(tiSizeRMin?.value) || Number(tiSize?.min) || 16),
                sizeMax: Math.max(0, Number(tiSizeRMax?.value) || Number(tiSize?.max) || 200),
                sizeRandom: !!(tiSizeRand?.checked),
                xPercent: Math.max(0, Math.min(100, Number(tiX?.value)||50)),
                xMin: Math.max(0, Number(tiXRMin?.value) || Number(tiX?.min) || 0),
                xMax: Math.max(0, Number(tiXRMax?.value) || Number(tiX?.max) || 100),
                xRandom: !!(tiXRand?.checked),
                border: Math.max(0, Math.min(10, Number(tiBorder?.value)||0)),
                borderMin: Math.max(0, Number(tiBorderRMin?.value) || Number(tiBorder?.min) || 0),
                borderMax: Math.max(0, Number(tiBorderRMax?.value) || Number(tiBorder?.max) || 10),
                borderRandom: !!(tiBorderRand?.checked),
                borderColor: tiBorderColor?.value || '#000000',
                borderColorRandom: !!(tiBorderColorRandCheck?.checked),
                glow: Math.max(0, Math.min(50, Number(tiGlow?.value)||0)),
                glowMin: Math.max(0, Number(tiGlowRMin?.value) || Number(tiGlow?.min) || 0),
                glowMax: Math.max(0, Number(tiGlowRMax?.value) || Number(tiGlow?.max) || 50),
                glowRandom: !!(tiGlowRand?.checked),
                glowColor: tiGlowColor?.value || '',
                // --- FIX: Added this line to capture the checkbox state ---
                glowColorRandom: !!(tiGlowColorRandCheck?.checked),
                // ---------------------------------------------------------
                fontRandom: !!(tiFontRand?.checked),
                flash: !!(tiFlash?.checked),
                flashSpeed: Math.max(0, Math.min(5, Number(tiFlashSpeed?.value)||1)),
                flashSpeedMin: Math.max(0, Number(tiFlashSpeedRMin?.value) || Number(tiFlashSpeed?.min) || 0),
                flashSpeedMax: Math.max(0, Number(tiFlashSpeedRMax?.value) || Number(tiFlashSpeed?.max) || 5),
                flashSpeedRandom: !!(tiFlashSpeedRand?.checked),
                speed: Math.max(25, Math.min(900, Number(tiSpeed?.value)||25)),
                speedMin: Math.max(0, Number(tiSpeedRMin?.value) || Number(tiSpeed?.min) || 25),
                speedMax: Math.max(0, Number(tiSpeedRMax?.value) || Number(tiSpeed?.max) || 900),
                speedRandom: !!(tiSpeedRand?.checked)
            };
        }
        function updateTextInPreview() {
            const cfg = getTextConfigFromUi();
            if (tiPreview) {
                tiPreview.textContent = cfg.text;
                applyTextStyles(tiPreview, cfg);
                try { tiPreview.style.setProperty('font-family', cfg.font, 'important'); } catch(_) {}
                // Reflect selected font in the input so the user types in the chosen style
                try { if (tiText) tiText.style.setProperty('font-family', cfg.font, 'important'); } catch(_) {}
                // Disable inputs when random toggles are on
                if (tiSize && tiSizeRand) tiSize.disabled = !!tiSizeRand.checked;
                if (tiX && tiXRand) tiX.disabled = !!tiXRand.checked;
                if (tiBorder && tiBorderRand) tiBorder.disabled = !!tiBorderRand.checked;
                if (tiBorderColor && tiBorderColorRandCheck) tiBorderColor.disabled = !!tiBorderColorRandCheck.checked;
                if (tiGlow && tiGlowRand) tiGlow.disabled = !!tiGlowRand.checked;
                if (tiFont && tiFontRand) tiFont.disabled = !!tiFontRand.checked;
                if (tiColor && tiColorRandCheck) tiColor.disabled = !!tiColorRandCheck.checked;
                const tiSpeed = document.getElementById('ti-speed');
                if (tiSpeed && tiSpeedRand) tiSpeed.disabled = !!tiSpeedRand.checked;
                if (tiFlashSpeed && tiFlashSpeedRand) tiFlashSpeed.disabled = !!tiFlashSpeedRand.checked;
                // Toggle sub-range visibility based on Random checkboxes
                const toggleSub = (rmin, rmax, on) => {
                    if (!rmin || !rmax) return;
                    const container = rmin.closest('.range-sub');
                    if (container) container.style.display = on ? 'block' : 'none';
                };
                toggleSub(tiSizeRMin, tiSizeRMax, !!(tiSizeRand && tiSizeRand.checked));
                toggleSub(tiXRMin, tiXRMax, !!(tiXRand && tiXRand.checked));
                toggleSub(tiBorderRMin, tiBorderRMax, !!(tiBorderRand && tiBorderRand.checked));
                toggleSub(tiGlowRMin, tiGlowRMax, !!(tiGlowRand && tiGlowRand.checked));
                toggleSub(tiFlashSpeedRMin, tiFlashSpeedRMax, !!(tiFlashSpeedRand && tiFlashSpeedRand.checked));
                toggleSub(tiSpeedRMin, tiSpeedRMax, !!(tiSpeedRand && tiSpeedRand.checked));
            }
        }
        // lock/unlock shortcuts when focusing inside Text-In
        if (textInPanel) {
            textInPanel.addEventListener('focusin', () => { shortcutsLocked = true; }, true);
            textInPanel.addEventListener('focusout', (e) => {
                try {
                    const next = e.relatedTarget;
                    if (!(textInPanel.contains(next))) shortcutsLocked = false;
                } catch(_) { shortcutsLocked = false; }
            }, true);
        }
        // stop bubbling of keydown events from inputs inside panel
        [tiText, tiFont, tiColor, tiSize, tiBorder, tiBorderColor, tiGlow, tiFlashSpeed, tiSpeed].forEach(el => {
            if (el) el.addEventListener('keydown', (ev) => ev.stopPropagation());
        });
        if (tiFont) tiFont.addEventListener('change', updateTextInPreview);
        // Auto-disable random when user adjusts specific controls
        if (tiSize) tiSize.addEventListener('input', () => { if (tiSizeRand && tiSizeRand.checked) { tiSizeRand.checked = false; updateTextInPreview(); } });
        if (tiX) tiX.addEventListener('input', () => { if (tiXRand && tiXRand.checked) { tiXRand.checked = false; updateTextInPreview(); } });
        if (tiBorder) tiBorder.addEventListener('input', () => { if (tiBorderRand && tiBorderRand.checked) { tiBorderRand.checked = false; updateTextInPreview(); } });
        if (tiGlow) tiGlow.addEventListener('input', () => { if (tiGlowRand && tiGlowRand.checked) { tiGlowRand.checked = false; updateTextInPreview(); } });
        if (tiGlowColorRandBtn) tiGlowColorRandBtn.addEventListener('click', (e) => { e.preventDefault(); if (tiGlowColor) { tiGlowColor.value = randomHexColor(); updateTextInPreview(); } });
        if (tiGlowColor) tiGlowColor.addEventListener('input', updateTextInPreview);
        if (tiBorderColor) tiBorderColor.addEventListener('input', () => { if (tiBorderColorRandCheck && tiBorderColorRandCheck.checked) { tiBorderColorRandCheck.checked = false; updateTextInPreview(); } });
        if (tiFlashSpeed) tiFlashSpeed.addEventListener('input', () => { if (tiFlashSpeedRand && tiFlashSpeedRand.checked) { tiFlashSpeedRand.checked = false; updateTextInPreview(); } });
        if (tiFont) tiFont.addEventListener('input', () => { if (tiFontRand && tiFontRand.checked) { tiFontRand.checked = false; updateTextInPreview(); } });
        const tiSpeedEl = document.getElementById('ti-speed');
        if (tiSpeedEl) tiSpeedEl.addEventListener('input', () => { if (tiSpeedRand && tiSpeedRand.checked) { tiSpeedRand.checked = false; updateTextInPreview(); } });
        // Dual-range helpers for random bounds
        function bindDualRange(minEl, maxEl, overallMin, overallMax, step) {
            if (!minEl || !maxEl) return;
            const clamp = () => {
                let a = Number(minEl.value), b = Number(maxEl.value);
                if (isNaN(a)) a = overallMin; if (isNaN(b)) b = overallMax;
                a = Math.max(overallMin, Math.min(overallMax, a));
                b = Math.max(overallMin, Math.min(overallMax, b));
                if (a > b) { const t = a; a = b; b = t; }
                minEl.value = String(a);
                maxEl.value = String(b);
                updateTextInPreview();
            };
            minEl.addEventListener('input', clamp);
            maxEl.addEventListener('input', clamp);
            clamp();
        }
        bindDualRange(tiSizeRMin, tiSizeRMax, 16, 200, 1);
        bindDualRange(tiXRMin, tiXRMax, 0, 100, 1);
        bindDualRange(tiBorderRMin, tiBorderRMax, 0, 10, 1);
        bindDualRange(tiGlowRMin, tiGlowRMax, 0, 50, 1);
        bindDualRange(tiFlashSpeedRMin, tiFlashSpeedRMax, 0, 5, 0.1);
        bindDualRange(tiSpeedRMin, tiSpeedRMax, 25, 900, 1);
        if (tiColor) tiColor.addEventListener('input', () => { if (tiColorRandCheck && tiColorRandCheck.checked) { tiColorRandCheck.checked = false; updateTextInPreview(); } });
        // Enter to send while in text field
        if (tiText) {
            tiText.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const cfg = getTextConfigFromUi();
                    spawnRisingText(cfg);
                }
            });
        }
        // Randomize colors via small buttons
        if (tiColorRandBtn) {
            tiColorRandBtn.addEventListener('click', (e) => {
                e.preventDefault();
                try { tiColor.value = randomHexColor(); } catch(_) {}
                updateTextInPreview();
            });
        }
        if (tiBorderColorRandBtn) {
            tiBorderColorRandBtn.addEventListener('click', (e) => {
                e.preventDefault();
                try { tiBorderColor.value = randomHexColor(); } catch(_) {}
                updateTextInPreview();
            });
        }
        function spawnRisingText(cfg) {
            const layer = textOverlayLayer;
            if (!layer) return;
            // Apply randomizations
            try {
                if (cfg.colorRandom) {
                    cfg.color = randomHexColor();
                }
                if (cfg.fontRandom && tiFont && tiFont.options && tiFont.options.length > 0) {
                    const idx = Math.floor(Math.random() * tiFont.options.length);
                    cfg.font = tiFont.options[idx].value || cfg.font;
                }
                if (cfg.borderRandom && tiBorder) {
                    const min = Math.max(0, Number(cfg.borderMin) || Number(tiBorder.min) || 0);
                    const max = Math.max(min, Number(cfg.borderMax) || Number(tiBorder.max) || 10);
                    cfg.border = Math.floor(min + Math.random() * (max - min + 1));
                }
                if (cfg.borderColorRandom) {
                    cfg.borderColor = randomHexColor();
                }
                if (cfg.glowRandom && tiGlow) {
                    const minG = Math.max(0, Number(cfg.glowMin) || Number(tiGlow.min) || 0);
                    const maxG = Math.max(minG, Number(cfg.glowMax) || Number(tiGlow.max) || 50);
                    cfg.glow = Math.floor(minG + Math.random() * (maxG - minG + 1));
                }
                // Flash on/off random removed per new request; only speed random here
                if (cfg.speedRandom) {
                    const minS = Math.max(0, Number(cfg.speedMin) || 25);
                    const maxS = Math.max(minS, Number(cfg.speedMax) || 900);
                    cfg.speed = Math.floor(minS + Math.random() * (maxS - minS + 1));
                }
                if (cfg.flashSpeedRandom && tiFlashSpeed) {
                    const minFS = Math.max(0, Number(cfg.flashSpeedMin) || Number(tiFlashSpeed.min) || 0);
                    const maxFS = Math.max(minFS, Number(cfg.flashSpeedMax) || Number(tiFlashSpeed.max) || 5);
                    cfg.flashSpeed = (minFS + Math.random() * (maxFS - minFS));
                }
            } catch(_) {}
            const el = document.createElement('div');
            el.className = 'rising-text';
            el.textContent = cfg.text;
            applyTextStyles(el, cfg);
            try { el.style.setProperty('font-family', cfg.font, 'important'); } catch(_) {}
            // compute horizontal origin
            let xPct = Number(cfg.xPercent || 50);
            if (cfg.xRandom) {
                xPct = Math.random() * 100;
            }
            // compute size
            if (cfg.sizeRandom) {
                const min = Math.max(16, Number(tiSize?.min) || 16);
                const max = Math.max(min, Number(tiSize?.max) || 200);
                cfg.size = Math.floor(min + Math.random() * (max - min + 1));
                try { el.style.fontSize = cfg.size + 'px'; } catch(_) {}
            }
            const startY = window.innerHeight + 20;
            el.style.top = startY + 'px';
            el.style.left = xPct + 'vw';
            layer.appendChild(el);
            const item = { el, cfg, y: startY, start: performance.now(), last: performance.now() };
            activeTextOverlays.push(item);
            if (!textOverlayAnimId) requestTextOverlayFrame();
        }
        function requestTextOverlayFrame() {
            textOverlayAnimId = requestAnimationFrame(stepTextOverlays);
        }
        function stepTextOverlays(ts) {
            for (let i = activeTextOverlays.length - 1; i >= 0; i--) {
                const it = activeTextOverlays[i];
                const dt = Math.max(0, (ts - it.last) / 1000);
                it.last = ts;
                it.y -= it.cfg.speed * dt;
                it.el.style.transform = `translate(-50%, 0)`;
                it.el.style.top = it.y + 'px';
                const progress = Math.max(0, Math.min(1, ( (window.innerHeight + 20) - it.y ) / window.innerHeight ));
                let opacity = 1 - progress;
                if (it.cfg.flash && it.cfg.flashSpeed > 0) {
                    const phase = (ts - it.start) / 1000 * it.cfg.flashSpeed * Math.PI * 2;
                    const mod = 0.5 + 0.5 * Math.sin(phase);
                    opacity *= (0.6 + 0.4 * mod);
                }
                it.el.style.opacity = String(Math.max(0, Math.min(1, opacity)));
                if (it.y + 100 < 0 || opacity <= 0.02) {
                    try { it.el.remove(); } catch(_) {}
                    activeTextOverlays.splice(i, 1);
                }
            }
            if (activeTextOverlays.length > 0) requestTextOverlayFrame();
            else { cancelAnimationFrame(textOverlayAnimId); textOverlayAnimId = null; }
        }
        // bind preview updates
        [tiText, tiFont, tiColor, tiSize, tiSizeRand, tiX, tiXRand, tiBorder, tiBorderColor, tiGlow, tiFlash, tiFlashSpeed, tiSpeed, tiSpeedRand].forEach(el => {
            if (el) el.addEventListener('input', updateTextInPreview);
        });
        if (tiFont) tiFont.addEventListener('change', updateTextInPreview);
        // If user touches size/x sliders, turn off random check automatically
        if (tiSize) tiSize.addEventListener('input', () => { if (tiSizeRand && tiSizeRand.checked) { tiSizeRand.checked = false; updateTextInPreview(); } });
        if (tiX) tiX.addEventListener('input', () => { if (tiXRand && tiXRand.checked) { tiXRand.checked = false; updateTextInPreview(); } });
        if (tiSend) tiSend.addEventListener('click', () => { const cfg = getTextConfigFromUi(); spawnRisingText(cfg); });
        if (tiClose) tiClose.addEventListener('click', (e) => { e.preventDefault(); e.stopPropagation(); hideTextInPanel(); });
        updateTextInPreview();
        // Auto send controls
        function setTextAuto(on) {
            textAutoOn = !!on;
            if (textAutoTimer) { clearInterval(textAutoTimer); textAutoTimer = null; }
            if (tiAutoBtn) tiAutoBtn.classList.toggle('on', textAutoOn);
            if (textAutoOn) {
                let iv = Math.max(100, Math.min(10000, Number(tiAutoInterval?.value) || 1000));
                if (tiAutoInterval) tiAutoInterval.value = String(iv);
                textAutoTimer = setInterval(() => {
                    try {
                        const cfg = getTextConfigFromUi();
                        spawnRisingText(cfg);
                    } catch(_) {}
                }, iv);
            }
        }
        if (tiAutoBtn) tiAutoBtn.addEventListener('click', () => setTextAuto(!textAutoOn));
        if (tiAutoInterval) tiAutoInterval.addEventListener('input', () => { if (textAutoOn) setTextAuto(true); });
// ðŸŽ² One-shot random glow colour
tiGlowColorRandBtn.addEventListener('click', () => {
    tiGlowColor.value = randomGlowColor();
});
        function showStationBanner(text) {
            stationBanner.textContent = text || '';
            if(!text) return;
            stationBanner.classList.remove('display-none');
            stationBanner.style.opacity = '1';
            stationBanner.style.pointerEvents = 'auto';
            // Auto-hide after a short display even if no mouse movement occurs
            if (stationBannerTimer) { clearTimeout(stationBannerTimer); stationBannerTimer = null; }
            stationBannerTimer = setTimeout(() => {
                stationBanner.style.opacity = '0';
                stationBanner.style.pointerEvents = 'none';
            }, 3000);
        }

        function deriveTitleFromUrl(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch {
                return url;
            }
        }

        // Swap: left-click now opens panel; right-click picks random (guard missing quick button)
        if (radioQuickBtn) {
            radioQuickBtn.title = "Left-click: choose â€¢ Right-click: random station";
            radioQuickBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleRadioPanel();
            });
            radioQuickBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                pickRandomStation();
                // Keep the radio button visible for 10s after right-click shuffle
                radioQuickBtn.style.opacity = '1';
                radioQuickBtn.style.pointerEvents = 'auto';
                radioQuickHoldUntil = Date.now() + 10000;
                if (radioQuickHoldTimeout) { clearTimeout(radioQuickHoldTimeout); radioQuickHoldTimeout = null; }
                radioQuickHoldTimeout = setTimeout(() => {
                    radioQuickHoldUntil = 0;
                    // Only hide if UI is idle (layer opacity is 0)
                    if (uiLayer.style.opacity === '0') {
                        radioQuickBtn.style.opacity = '0';
                        radioQuickBtn.style.pointerEvents = 'none';
                    }
                }, 10000);
            });
        }
        // Station banner now triggers random station
        stationBanner.title = "Click: random station";
        stationBanner.addEventListener('click', (e) => {
            e.stopPropagation();
            pickRandomStation();
        });
        document.addEventListener('click', (e) => {
            if (radioPanel && !radioPanel.classList.contains('display-none')) {
                if(!radioPanel.contains(e.target) && e.target !== radioQuickBtn) {
                    hideRadioPanel();
                }
            }
        });

        // Drag Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            // Accept only for ProjectM (either version)
            const active = state.activeVisualizer;
            if(!(active instanceof MilkdropEngine) && !(active instanceof MilkdropEngineV2)) {
                return alert("Switch to ProjectM (v1 or v2) first");
            }
            const file = e.dataTransfer.files[0];
            if(!file) return;
            const lower = file.name.toLowerCase();
            if(lower.endsWith('.milk')) {
                alert("Raw .milk files are not directly supported. Please convert to butterchurn JSON first.");
                return;
            }
            const reader = new FileReader();
            reader.onload = (ev) => active.loadCustomMilk?.(ev.target.result);
            reader.readAsText(file);
        });

        // Keyboard shortcuts
        function handleGlobalKeydown(e) {
            try {
                if (shortcutsLocked) return;
                const ae = document.activeElement;
                if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA' || ae.tagName === 'SELECT' || ae.isContentEditable || (ae.closest && ae.closest('#textin-panel')))) {
                    return;
                }
            } catch(_) {}
            if (e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            } else if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                var resetBtn = document.getElementById('btn-webm-reset');
                if (resetBtn) { resetBtn.click(); }
            } else if (e.key === 'c' || e.key === 'C') {
                // ProjectM: next visual preset
                if (state && state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') {
                    e.preventDefault();
                    state.activeVisualizer.nextPreset();
                }
            } else if (e.key === 'Escape') {
                // Close any open panels first; if none open, return to start
                e.preventDefault();
                let closed = false;
                try {
                    // Mic confirm
                    if (!closed && micConfirm && micConfirm.style.display === 'flex') {
                        hideMicConfirm();
                        closed = true;
                    }
                    // Mix panel
                    if (mixPanel && !mixPanel.classList.contains('display-none') && mixPanel.classList.contains('open')) {
                        toggleMixPanel();
                        closed = true;
                    }
                    // Text-In panel
                    if (!closed && textInPanel && !textInPanel.classList.contains('display-none') && textInPanel.classList.contains('open')) {
                        hideTextInPanel();
                        closed = true;
                    }
                    // Top menu
                    if (!closed && typeof isTopMenuOpen === 'function' && isTopMenuOpen()) {
                        try { closeTopMenuPanel(); } catch(_) {}
                        closed = true;
                    }
                    // WebM settings
                    if (!closed && webmSettingsPanel && !webmSettingsPanel.classList.contains('display-none')) {
                        try { hideWebmSettingsPanel(); } catch(_) {}
                        closed = true;
                    }
                    // Visualizer settings panel
                    if (!closed && settingsPanel && !settingsPanel.classList.contains('display-none')) {
                        settingsPanel.classList.add('display-none');
                        settingsPanel.style.opacity = '';
                        settingsPanel.style.pointerEvents = '';
                        closed = true;
                    }
                } catch(_) {}
                if (!closed) {
                    stopAllAndShowStart();
                }
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                adjustWebmPosition(-2, 0);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                adjustWebmPosition(2, 0);
            } else if (e.key === 'v' || e.key === 'V') {
                // Next random station
                e.preventDefault();
                if (stations && stations.length > 0) pickRandomStation();
			} else if (e.key === 'b' || e.key === 'B') {
				// Previous station (true history up to 5, then random)
				e.preventDefault();
                goPreviousStation();
            } else if (e.key === 't' || e.key === 'T') {
                // Toggle Text-In panel
                e.preventDefault();
                try { toggleTextInPanel(); } catch(_) {}
            } else if (e.key === 'r' || e.key === 'R') {
                // Toggle Top Menu panel
                e.preventDefault();
                try { toggleTopMenuPanel(); } catch(_) {}
            } else if (e.key === 'm' || e.key === 'M') {
                // Toggle Mix Settings panel
                e.preventDefault();
                try { toggleMixPanel(); } catch(_) {}
            } else if (e.key === 'g' || e.key === 'G') {
                // Toggle WebM Settings panel
                e.preventDefault();
                try { toggleWebmSettingsPanel(); } catch(_) {}
            } else if (e.key === 'i' || e.key === 'I') {
                // Send Text-In immediately
                e.preventDefault();
                try {
                    const cfg = getTextConfigFromUi();
                    spawnRisingText(cfg);
                } catch(_) {}
            } else if (e.code === 'Space' || e.key === ' ') {
                // Play/pause current radio (A)
                e.preventDefault();
                try {
                    if (audioEl) {
                        if (audioEl.paused) audioEl.play().catch(()=>{});
                        else audioEl.pause();
                    }
                } catch(_) {}
            } else if (e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                if(!webmOn) {
                    if(webmList.length === 0) {
                        loadWebmList().finally(() => {
                            if(webmList.length > 0) showWebm();
                        });
                    } else {
                        showWebm();
                    }
                } else {
                    hideWebm();
                }
            } else if (e.key === 'q' || e.key === 'Q') {
                e.preventDefault();
                adjustWebmSpeed(-0.1);
            } else if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                adjustWebmSpeed(+0.1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                adjustWebmPosition(0, -2);
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                adjustWebmPosition(0, 2);
            } else if (e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                if (webmOn) prevWebm();
            } else if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                if (webmOn) nextWebm();
            } else if (e.key === 'z' || e.key === 'Z') {
                e.preventDefault();
                adjustWebmOpacity(-0.05);
            } else if (e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                adjustWebmOpacity(0.05);
            } else if (e.key === '=') {
                e.preventDefault();
                adjustWebmScale(2);
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                adjustWebmScale(-2);
            }
            // Visual mode navigation with comma/period
            else if (e.key === ',') {
                e.preventDefault();
                loadMode(state.currentModeIdx - 1);
            } else if (e.key === '.') {
                e.preventDefault();
                loadMode(state.currentModeIdx + 1);
            }
        }
        try {
            document.addEventListener('keydown', handleGlobalKeydown, false);
        } catch(e) {}

        // Bootstrap station list
        loadStations();
        // Preload webm list (best-effort)
        loadWebmList();

        // --- WEBM HELPERS ---
        async function loadWebmList() {
            try {
                // Try a manifest first
                const resp = await fetch('webm/webms.txt', { cache: 'no-store' });
                if(resp.ok) {
                    const txt = await resp.text();
                    const files = txt.split('\n').map(s => s.trim()).filter(Boolean);
                    webmList = files.map(f => f.startsWith('webm/') ? f : `webm/${f}`);
                    webmIndex = 0;
                    return;
                }
            } catch {}
            // Try directory listing parse (best-effort)
            try {
                const dirResp = await fetch('webm/', { cache: 'no-store' });
                if(dirResp.ok) {
                    const html = await dirResp.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const anchors = Array.from(doc.querySelectorAll('a,link'));
                    const found = anchors.map(a => a.getAttribute('href') || '').filter(href => /\.webm(\?.*)?$/i.test(href));
                    if(found.length > 0) {
                        const normalized = found.map(f => f.startsWith('webm/') ? f : `webm/${f.replace(/^\//,'')}`);
                        // Deduplicate
                        webmList = Array.from(new Set(normalized));
                        webmIndex = 0;
                        return;
                    }
                }
            } catch {}
            // Fallback to known files
            const defaults = ['webm/red.webm', 'webm/grn.webm'];
            webmList = defaults;
            webmIndex = 0;
        }

        function showWebm() {
            if(webmList.length === 0) return;
            webmOn = true;
            setWebm(webmIndex);
            webmOverlayEl.classList.remove('display-none');
            // Allow interaction on overlay (for dblclick/gestures)
            try { webmOverlayEl.style.pointerEvents = 'auto'; } catch(_) {}
            webmPrevBtn.classList.remove('display-none');
            webmNextBtn.classList.remove('display-none');
            applyWebmSettings();
            // resume auto if enabled
            if (webmAutoOn) scheduleWebmAuto();
        }

        function hideWebm() {
            webmOn = false;
            webmOverlayEl.classList.add('display-none');
            // Disable overlay interaction when hidden
            try { webmOverlayEl.style.pointerEvents = 'none'; } catch(_) {}
            webmPrevBtn.classList.add('display-none');
            webmNextBtn.classList.add('display-none');
            try { webmVideoEl.pause(); } catch {}
            try { webmVideoLeftEl.pause(); } catch {}
            try { webmVideoRightEl.pause(); } catch {}
            webmVideoEl.src = '';
            webmVideoLeftEl.src = '';
            webmVideoRightEl.src = '';
            // stop auto when hidden
            cancelWebmAuto();
        }

        function setWebm(index) {
            if(webmList.length === 0) return;
            if(index < 0) index = webmList.length - 1;
            if(index >= webmList.length) index = 0;
            webmIndex = index;
            const src = webmList[webmIndex];
            if(webmVideoEl.src.endsWith(src)) return;
            webmVideoEl.src = src;
            webmVideoEl.muted = true;
            webmVideoEl.loop = true;
            webmVideoEl.playsInline = true;
            webmVideoEl.autoplay = true;
            webmVideoEl.play().catch(()=>{ /* ignore */ });
            // mirror to duplicates
            [webmVideoLeftEl, webmVideoRightEl].forEach(v => {
                v.src = src;
                v.muted = true; v.loop = true; v.playsInline = true; v.autoplay = true;
                v.playbackRate = webmSettings.playbackRate;
                v.style.opacity = String(webmSettings.opacity);
                v.play().catch(()=>{});
            });
            // Ensure current settings are applied consistently to the main video and duplicates
            applyWebmSettings();
        }

        function nextWebm() { setWebm(webmIndex + 1); }
        function prevWebm() { setWebm(webmIndex - 1); }
        // --- WebM Auto Random ---
        function scheduleWebmAuto() {
            cancelWebmAuto();
            const delay = (30 + Math.random() * 30) * 1000; // 30-60s
            webmAutoTimer = setTimeout(() => {
                if (webmOn && webmList.length > 0) {
                    nextWebm();
                }
                scheduleWebmAuto();
            }, delay);
        }
        function cancelWebmAuto() {
            if (webmAutoTimer) { clearTimeout(webmAutoTimer); webmAutoTimer = null; }
        }
        function setWebmAuto(on) {
            webmAutoOn = !!on;
            const autoBtn = document.getElementById('btn-webm-auto');
            if (autoBtn) { autoBtn.textContent = 'Auto'; autoBtn.classList.toggle('on', webmAutoOn); }
            const autoBtn2 = document.getElementById('avatar-btn-auto');
            if (autoBtn2) { autoBtn2.textContent = 'Auto'; autoBtn2.classList.toggle('on', webmAutoOn); }
            if (webmAutoOn) scheduleWebmAuto(); else cancelWebmAuto();
        }
        
        function toggleWebmSettingsPanel() {
            if(webmSettingsPanel.classList.contains('display-none')) {
                webmSettingsPanel.classList.remove('display-none');
                webmSettingsPanel.style.display = 'block';
                webmSettingsPanel.style.opacity = '1';
                webmSettingsPanel.style.pointerEvents = 'auto';
                scheduleWebmSettingsClose();
                // sync inputs
                inpWebmScale.value = String(webmSettings.scaleVw);
                inpWebmX.value = String(webmSettings.posXvw);
                inpWebmY.value = String(webmSettings.posYvh);
                inpWebmRot.value = String(webmSettings.rotationDeg);
                inpWebmSpeed.value = String(webmSettings.playbackRate);
                inpWebmOpacity.value = String(webmSettings.opacity);
                inpWebmDup.value = String(webmSettings.duplicates);
            } else {
                hideWebmSettingsPanel();
            }
        }
        function hideWebmSettingsPanel() {
            if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
            webmSettingsPanel.classList.add('display-none');
            webmSettingsPanel.style.display = 'none';
            webmSettingsPanel.style.opacity = '';
            webmSettingsPanel.style.pointerEvents = '';
        }

        // --- Top Menu Panel helpers ---
        function isTopMenuOpen() {
            const p = document.getElementById('top-menu-panel');
            return !!(p && !p.classList.contains('display-none') && p.classList.contains('open'));
        }
        function openTopMenuPanel() {
            // Prevent opening if a recent panel close just happened
            try { if (window.__panelGuardUntilMs && Date.now() < window.__panelGuardUntilMs) return; } catch(_) {}
            const p = document.getElementById('top-menu-panel');
            if (!p) return;
            // Populate fields
            try {
                const urlEl = document.getElementById('station-url');
                if (urlEl) {
                    let current = '';
                    try { current = audioEl?.src || ''; } catch(_) {}
                    if (!current && typeof currentStationIndex === 'number' && currentStationIndex >= 0 && stations[currentStationIndex]) {
                        current = stations[currentStationIndex].url || '';
                    }
                    urlEl.value = current || '';
                }
                const sel = document.getElementById('webm-select');
                if (sel) {
                    sel.innerHTML = '';
                    if (Array.isArray(webmList) && webmList.length > 0) {
                        webmList.forEach((pth, idx) => {
                            const opt = document.createElement('option');
                            opt.value = String(idx);
                            opt.textContent = (pth || '').split('/').pop() || pth || ('Item ' + (idx+1));
                            if (typeof webmIndex === 'number' && idx === webmIndex) opt.selected = true;
                            sel.appendChild(opt);
                        });
                    } else {
                        const opt = document.createElement('option');
                        opt.value = '0';
                        opt.textContent = '(load list)';
                        sel.appendChild(opt);
                    }
                }
                // Ensure volume slider is visible when opening the panel
                const vs = document.getElementById('volume-slider-container');
                if (vs) vs.style.display = 'flex';
            } catch(_) {}
            p.classList.remove('display-none');
            requestAnimationFrame(() => { p.classList.add('open'); });
        }
        function closeTopMenuPanel() {
            const p = document.getElementById('top-menu-panel');
            if (!p) return;
            p.classList.remove('open');
            try { window.__panelGuardUntilMs = Date.now() + 1200; } catch(_) {}
            setTimeout(() => { p.classList.add('display-none'); }, 350);
        }
        function toggleTopMenuPanel() {
            if (isTopMenuOpen()) closeTopMenuPanel(); else openTopMenuPanel();
        }
        // Bind top menu controls
        (function bindTopMenuControls(){
            try {
                const btnClose = document.getElementById('btn-topmenu-close');
                if (btnClose) btnClose.addEventListener('click', (e)=>{ e.stopPropagation(); closeTopMenuPanel(); });
                const btnPlay = document.getElementById('topmenu-play');
                if (btnPlay) btnPlay.addEventListener('click', (e)=>{ 
                    e.stopPropagation();
                    const urlEl = document.getElementById('station-url');
                    if (urlEl && typeof playRadio === 'function') {
                        if (typeof radioInputEl !== 'undefined' && radioInputEl) radioInputEl.value = urlEl.value;
                        playRadio();
                    }
                });
				// Visualization settings apply from top menu
                const tmMin = document.getElementById('tm-inp-shuffle-min');
                const tmMax = document.getElementById('tm-inp-shuffle-max');
                const tmTrans = document.getElementById('tm-inp-transition');
                const tmPx = document.getElementById('tm-inp-pixelratio');
                const tmApply = document.getElementById('tm-btn-apply');
                // Initialize with current values if available
                try {
                    if (tmMin) tmMin.value = String(visualSettings.shuffleMinSec ?? 30);
                    if (tmMax) tmMax.value = String(visualSettings.shuffleMaxSec ?? 60);
                    if (tmTrans) tmTrans.value = String(visualSettings.transitionSec ?? 2.7);
                    if (tmPx) tmPx.value = String(visualSettings.pixelRatio ?? 1);
                } catch(_){}
                if (tmApply) tmApply.addEventListener('click', () => {
                    try {
                        const minS = Math.max(3, Math.min(120, Number(tmMin?.value) || 30));
                        const maxS = Math.max(5, Math.min(180, Number(tmMax?.value) || 60));
                        const trans = Math.max(0, Math.min(10, Number(tmTrans?.value) || 2.7));
                        const px = Math.max(0.5, Math.min(3, Number(tmPx?.value) || 1));
                        visualSettings.shuffleMinSec = minS;
                        visualSettings.shuffleMaxSec = maxS;
                        visualSettings.transitionSec = trans;
                        visualSettings.pixelRatio = px;
                        if(state.activeVisualizer && state.activeVisualizer instanceof MilkdropEngineV2) {
                            state.activeVisualizer.applySettings?.();
                        }
                    } catch(e) {}
                });
				const btnPrevSt = document.getElementById('topmenu-prev-station');
                const btnNextSt = document.getElementById('topmenu-next-station');
                if (btnPrevSt) btnPrevSt.addEventListener('click', (e)=>{ e.stopPropagation(); if (typeof setStation === 'function') setStation((currentStationIndex - 1 + stations.length) % stations.length); });
                if (btnNextSt) btnNextSt.addEventListener('click', (e)=>{ e.stopPropagation(); if (typeof setStation === 'function') setStation((currentStationIndex + 1) % stations.length); });
				const btnPrevVis = document.getElementById('topmenu-prev-visual');
                const btnNextVis = document.getElementById('topmenu-next-visual');
                if (btnPrevVis) btnPrevVis.addEventListener('click', (e)=>{ e.stopPropagation(); loadMode(state.currentModeIdx - 1); });
                if (btnNextVis) btnNextVis.addEventListener('click', (e)=>{ e.stopPropagation(); loadMode(state.currentModeIdx + 1); });
            } catch(e) {}
        })();
        // expose for inline handlers
        window.hideWebmSettingsPanel = hideWebmSettingsPanel;
        function scheduleWebmSettingsClose() {
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            webmSettingsTimer = setTimeout(() => {
                webmSettingsPanel.style.opacity = '0';
                webmSettingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { hideWebmSettingsPanel(); }, 1200);
            }, 30000);
        }
        if (webmCloseBtn) {
            webmCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
            // Support pointerdown for cases where click is swallowed by other handlers
            webmCloseBtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
            // Also close on right-click/contextmenu for consistency with toggle behavior
            webmCloseBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
        }
        // Event delegation fallback in case the button is replaced dynamically
        webmSettingsPanel.addEventListener('click', (e) => {
            const t = e.target;
            if (!t) return;
            const btn = (t.id === 'btn-webm-close') ? t : (t.closest ? t.closest('#btn-webm-close') : null);
            if (btn) {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            }
        });
        webmSettingsPanel.addEventListener('pointerdown', (e) => {
            const t = e.target;
            if (!t) return;
            const btn = (t.id === 'btn-webm-close') ? t : (t.closest ? t.closest('#btn-webm-close') : null);
            if (btn) {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            }
        });
        // Allow closing the Avatar Settings with Escape for reliability
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !webmSettingsPanel.classList.contains('display-none')) {
                hideWebmSettingsPanel();
            }
        });
        // Close when clicking outside the avatar settings panel
        document.addEventListener('click', (e) => {
            if (webmSettingsPanel.classList.contains('display-none')) return;
            const target = e.target;
            // If click is inside the panel, ignore
            if (webmSettingsPanel.contains(target)) return;
            // Otherwise, close
            hideWebmSettingsPanel();
        }, true);
        document.getElementById('btn-webm-reset').addEventListener('click', () => {
            webmSettings.scaleVw = 50;
            webmSettings.posXvw = 50;
            webmSettings.posYvh = 50;
            webmSettings.rotationDeg = 0;
            webmSettings.playbackRate = 1.0;
            webmSettings.opacity = 0.82;
            webmSettings.duplicates = 0;
            inpWebmScale.value = '50';
            inpWebmX.value = '50';
            inpWebmY.value = '50';
            inpWebmRot.value = '0';
            inpWebmSpeed.value = '1.0';
            inpWebmOpacity.value = '0.82';
            inpWebmDup.value = '0';
            applyWebmSettings();
        });
        // Live-change on input
        function updateWebmSettingsFromInputs() {
            webmSettings.scaleVw = Number(inpWebmScale.value) || 50;
            webmSettings.posXvw = Number(inpWebmX.value) || 50;
            webmSettings.posYvh = Number(inpWebmY.value) || 50;
            webmSettings.rotationDeg = Number(inpWebmRot.value) || 0;
            webmSettings.playbackRate = Math.max(0.1, Math.min(4, Number(inpWebmSpeed.value) || 1));
            webmSettings.opacity = Math.max(0, Math.min(1, Number(inpWebmOpacity.value) || 1));
            webmSettings.duplicates = Math.max(0, Math.min(2, Math.floor(Number(inpWebmDup.value) || 0)));
            applyWebmSettings();
            scheduleWebmSettingsClose();
        }
        [inpWebmScale, inpWebmX, inpWebmY, inpWebmRot, inpWebmSpeed, inpWebmOpacity, inpWebmDup].forEach(el => {
            el.addEventListener('input', updateWebmSettingsFromInputs);
        });
        // Bind auto toggle
        const btnWebmAuto = document.getElementById('btn-webm-auto');
        if (btnWebmAuto) {
            btnWebmAuto.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                setWebmAuto(!webmAutoOn);
            });
        }
        function applyWebmSettings() {
            // central
            webmVideoEl.style.width = `${webmSettings.scaleVw}vw`;
            webmOverlayEl.style.left = `${webmSettings.posXvw}vw`;
            webmOverlayEl.style.top = `${webmSettings.posYvh}vh`;
            webmOverlayEl.style.transform = `translate(-50%, -50%)`;
            webmVideoEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
            webmVideoEl.style.opacity = String(webmSettings.opacity);
            try { webmVideoEl.playbackRate = webmSettings.playbackRate; } catch {}
            // duplicates
            const dup = webmSettings.duplicates;
            const offsetVw = webmSettings.scaleVw * 0.6;
            if(dup >= 1) {
                webmVideoLeftEl.classList.remove('display-none');
                webmVideoLeftEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoLeftEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoLeftEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoLeftEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoLeftEl.classList.add('display-none');
            }
            if(dup >= 2) {
                webmVideoRightEl.classList.remove('display-none');
                webmVideoRightEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoRightEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoRightEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoRightEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoRightEl.classList.add('display-none');
            }
            // Position duplicates relative to overlay center using absolute positioning containers
            // We'll position by setting margins on the left/right elements
            webmVideoEl.style.display = 'block';
            webmVideoLeftEl.style.display = dup >= 1 ? 'block' : 'none';
            webmVideoRightEl.style.display = dup >= 2 ? 'block' : 'none';
            // Reset any existing margins
            webmVideoEl.style.margin = '0';
            webmVideoLeftEl.style.margin = '0';
            webmVideoRightEl.style.margin = '0';
            // Arrange: left video shifted left by offset, right shifted right by offset, overlapping allowed
            webmVideoLeftEl.style.position = 'absolute';
            webmVideoRightEl.style.position = 'absolute';
            webmVideoEl.style.position = 'relative';
            webmVideoLeftEl.style.left = `-${offsetVw}vw`;
            webmVideoLeftEl.style.top = `0`;
            webmVideoRightEl.style.left = `${offsetVw}vw`;
            webmVideoRightEl.style.top = `0`;
        }
        // --- MODE SHUFFLE ---
        function setModeShuffle(on) {
            modeShuffleOn = on;
            if(modeShuffleTimer) { clearTimeout(modeShuffleTimer); modeShuffleTimer = null; }
            if(modeShuffleOn) {
                scheduleModeShuffle();
                stationBanner.classList.add('shuffle-on');
            }
            if(!modeShuffleOn) {
                stationBanner.classList.remove('shuffle-on');
            }
        }
        function scheduleModeShuffle() {
            if(!modeShuffleOn) return;
            modeShuffleTimer = setTimeout(() => {
                loadMode(state.currentModeIdx + 1);
                scheduleModeShuffle();
            }, 30000);
        }

    </script>
<!-- TEXT-IN AUTO shortcut (Y key) -->
    <script>
    document.addEventListener('keydown', (e) => {
        // Ignore typing in inputs / text areas
        const tag = document.activeElement?.tagName;
        if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

        // Ignore modifier keys
        if (e.ctrlKey || e.metaKey || e.altKey) return;

        // Y key toggles TEXT-IN Auto
        if (e.key === 'y' || e.key === 'Y') {
            const autoBtn = document.getElementById('ti-auto');
            if (!autoBtn) return;

            autoBtn.click(); // reuse existing logic
            e.preventDefault();
        }
    });
    </script>
	<div id="border-frame"></div>
</body>
</html>