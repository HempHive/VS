<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OmnI: Tomorrow</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon"/>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: white; cursor: none; }
        
        /* Layout */
        #canvas-container { 
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; 
            overflow: hidden;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlays */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; backdrop-filter: blur(10px);
            cursor: default;
        }

        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            min-height: clamp(88px, 12vh, 160px);
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 clamp(12px, 3vw, 40px); box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,1), transparent);
            z-index: 50;
            transition: opacity 1s ease-in-out;
            opacity: 1;
        }

        /* Center Control Group */
        .center-controls {
            display: flex; align-items: center; justify-content: center;
            gap: clamp(10px, 2vw, 24px); flex-wrap: wrap;
        }

        /* Interactive Elements */
        .interactive { pointer-events: auto; cursor: pointer; }

        h1 { font-weight: 200; letter-spacing: 8px; text-transform: uppercase; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.2); text-align: center; }

        .control-group {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;
        }

        .btn-main {
            padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 13px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            border-radius: 4px; min-width: 150px;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); border-color: #fff; }

        /* Secondary Icon Buttons (Fullscreen / Skip) */
        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            font-size: clamp(18px, 2.5vw, 28px); padding: 10px; transition: 0.2s; display: flex; align-items: center;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.2); text-shadow: 0 0 10px #fff; }

        .radio-input {
            padding: 15px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #0f0; 
            width: 320px; font-family: monospace;
        }

        /* Navigation Arrows */
        .nav-btn {
            font-size: clamp(36px, 6vw, 64px); opacity: 0.3; transition: 0.3s; user-select: none; padding: clamp(10px, 2vh, 20px);
        }
        .nav-btn:hover { opacity: 1; text-shadow: 0 0 15px #fff; transform: scale(1.1); }

        #mode-info { text-align: center; min-width: clamp(180px, 25vw, 360px); }
        #mode-title { font-size: clamp(18px, 2.2vw, 28px); font-weight: 600; display: block; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #mode-sub { font-size: clamp(10px, 1.2vw, 14px); color: #aaa; font-family: monospace; letter-spacing: 1px; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; margin: 0 auto;}

        .hidden { opacity: 0 !important; pointer-events: none; }
        .display-none { display: none !important; }
        
        #loading-status { color: #0ff; margin-top: 20px; font-family: monospace; font-size: 12px; height: 20px; }

        /* Quick Radio Button (Top-right) */
        #radio-quick {
            position: absolute; top: 14px; right: 14px;
            z-index: 80;
            width: 40px; height: 40px;
            background-color: transparent;
            background-image: url('radio.png');
            background-repeat: no-repeat;
            background-position: center center;
            background-size: contain;
            border: none;
            cursor: pointer;
            user-select: none;
            transition: opacity 1s ease-in-out;
        }
        #radio-quick:hover {
            filter: brightness(1.15);
        }
        
        /* Shuffle Toggle (Top-left) */
        #shuffle-toggle {
            position: absolute; top: 58px; left: 14px;
            z-index: 80;
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.9);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(6px);
            transition: opacity 1s ease-in-out, filter 0.2s;
            font-size: 20px;
        }
        #shuffle-toggle:hover { filter: brightness(1.15); }
        #shuffle-toggle.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }

        /* Radio Panel */
        #radio-panel {
            position: absolute; top: 54px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 1s ease-in-out;
        }
        #radio-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #radio-list { padding: 8px; }
        .radio-item {
            padding: 10px 12px; margin: 6px 0; border-radius: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.12);
            cursor: pointer; transition: 0.15s;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 13px;
        }
        .radio-item:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.08) inset;
        }
        .radio-item.active {
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212,175,55,0.3) inset, 0 0 16px rgba(212,175,55,0.15);
            background: rgba(212,175,55,0.08);
        }

        /* Station Banner (Top-left) */
        #station-banner {
            position: absolute; top: 14px; left: 14px;
            z-index: 80;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-size: 13px;
            letter-spacing: 0.5px;
            pointer-events: auto;
            transition: opacity 1s ease-in-out;
            max-width: min(60vw, 720px);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        #station-banner.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }
        
        /* Settings Panel */
        #settings-panel {
            position: absolute; bottom: 160px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #settings-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #settings-content { padding: 12px; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 10px 0; }
        .settings-row label { font-size: 12px; color: #ccc; }
        .settings-row input[type="number"] { width: 96px; padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); color: #fff; border-radius: 4px; }
        .settings-row input[type="range"] { flex: 1; }
        
        /* Unified slider styling (transparent tracks) */
        #settings-panel input[type="range"],
        #webm-settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            background: transparent;
            cursor: pointer;
        }
        /* WebKit track */
        #settings-panel input[type="range"]::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* WebKit thumb */
        #settings-panel input[type="range"]::-webkit-slider-thumb,
        #webm-settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            margin-top: -4px;
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Firefox track */
        #settings-panel input[type="range"]::-moz-range-track,
        #webm-settings-panel input[type="range"]::-moz-range-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* Firefox progress (filled portion) */
        #settings-panel input[type="range"]::-moz-range-progress,
        #webm-settings-panel input[type="range"]::-moz-range-progress {
            height: 6px;
            background: rgba(212,175,55,0.28); /* subtle gold on filled part */
            border-radius: 6px 0 0 6px;
        }
        /* Firefox thumb */
        #settings-panel input[type="range"]::-moz-range-thumb,
        #webm-settings-panel input[type="range"]::-moz-range-thumb {
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Hover/active states to increase opacity */
        #settings-panel input[type="range"]:hover::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:hover::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:active::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.28);
        }
        #settings-panel input[type="range"]:hover::-moz-range-track,
        #webm-settings-panel input[type="range"]:hover::-moz-range-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-moz-range-track,
        #webm-settings-panel input[type="range"]:active::-moz-range-track {
            background: rgba(255,255,255,0.28);
        }
        .settings-note { font-size: 11px; color: #8aa; margin-top: 8px; line-height: 1.35; }
        .settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .btn-small {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
            font-size: 12px; letter-spacing: 1px; border-radius: 4px;
        }
        .btn-small:hover { background: #fff; color: #000; }
        
        /* WebM Overlay */
        #webm-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 45;
            pointer-events: none;
        }
        #webm-overlay video {
            width: 50vw; height: auto; display: block;
            pointer-events: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        .webm-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            z-index: 60;
            font-size: 56px; color: rgba(255,255,255,0.7);
            background: transparent; border: none; padding: 12px; cursor: pointer;
            transition: opacity 1s ease-in-out, transform 0.2s;
            opacity: 1;
        }
        .webm-nav:hover { color: #fff; text-shadow: 0 0 15px #fff; transform: translateY(-50%) scale(1.1); }
        #webm-prev { left: 14px; }
        #webm-next { right: 14px; }
        
        /* WebM Settings Panel (mirror of settings-panel) */
        #webm-settings-panel {
            position: absolute; bottom: 160px; left: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #webm-settings-panel h3 {
            margin: 0; font-weight: 500; font-size: 14px;
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #webm-settings-panel .panel-head {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.12);
        }
        #webm-settings-content { padding: 12px; }
        .settings-row input[type="range"] { flex: 1; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "butterchurn": "https://esm.sh/butterchurn@2.6.0",
                "butterchurn-presets": "https://esm.sh/butterchurn-presets@2.4.7",
                "lodash": "https://esm.sh/lodash@4.17.21"
            }
        }
    </script>
</head>
<body>

    <!-- START SCREEN -->
    <div id="overlay">
        <h1>OmnI</h1>
        
        <div class="control-group">
            <!-- DEFAULT RADIO URL: BigFM Tomorrowland -->
            <input type="text" id="radio-url" class="radio-input interactive" value="https://stream.bigfm.de/tomorrowland/mp3-128/" placeholder="Paste Stream URL">
            <button class="btn-main interactive" id="btn-radio">‚ñ∂ Start Radio</button>
        </div>

        <div class="control-group">
            <button class="btn-main interactive" id="btn-mic">Use Microphone</button>
            <button class="btn-main interactive" id="btn-file" onclick="document.getElementById('file-input').click()">Load Local MP3</button>
            <input type="file" id="file-input" accept="audio/*" style="display:none">
        </div>

        <div id="loading-status">Select a source to begin</div>
    </div>

    <!-- HUD (Fades out when idle) -->
    <div id="ui-layer" class="hidden">
        <div class="nav-btn interactive" id="btn-prev">‚ùÆ</div>

        <div class="center-controls">
            <!-- SKIP PRESET BUTTON (Only for ProjectM) -->
            <button class="icon-btn interactive display-none" id="btn-skip-preset" title="Next Visual Preset">‚è≠</button>
            <!-- WEBM TOGGLE -->
            <button class="icon-btn interactive" id="btn-webm" title="Toggle WebM Overlay">ü™©</button>

            <!-- TITLE INFO -->
            <div id="mode-info">
                <span id="mode-title">INIT</span>
                <span id="mode-sub">Engine Ready</span>
            </div>

            <!-- SETTINGS BUTTON -->
            <button class="icon-btn interactive" id="btn-settings" title="Visualizer Settings">‚öôÔ∏è</button>
            
            <!-- FULLSCREEN BUTTON -->
            <button class="icon-btn interactive" id="btn-fullscreen" title="Toggle Fullscreen">‚õ∂</button>
        </div>

        <div class="nav-btn interactive" id="btn-next">‚ùØ</div>
    </div>

    <div id="canvas-container"></div>
    <audio id="radio-element" crossorigin="anonymous"></audio>
    <!-- Quick Radio Button and Panel -->
    <div id="radio-quick" class="interactive" role="button" aria-label="Radio control" title="Left-click: random station ‚Ä¢ Right-click: choose"></div>
    <div id="radio-panel" class="display-none">
        <h3>Radio Stations</h3>
        <div id="radio-list"></div>
    </div>
    <div id="station-banner" class="display-none"></div>
    
    <!-- WebM Overlay + Nav -->
    <div id="webm-overlay" class="display-none">
        <video id="webm-video" muted loop playsinline></video>
        <video id="webm-video-left" muted loop playsinline class="display-none"></video>
        <video id="webm-video-right" muted loop playsinline class="display-none"></video>
    </div>
    <button id="webm-prev" class="webm-nav display-none" title="Previous video">‚ùÆ</button>
    <button id="webm-next" class="webm-nav display-none" title="Next video">‚ùØ</button>
    
    <!-- Settings Panel -->
    <div id="settings-panel" class="display-none">
        <h3>Visualizer Settings</h3>
        <div id="settings-content">
            <div class="settings-row">
                <label for="inp-shuffle-min">Shuffle min (s)</label>
                <input id="inp-shuffle-min" type="range" min="3" max="120" step="1" value="30">
            </div>
            <div class="settings-row">
                <label for="inp-shuffle-max">Shuffle max (s)</label>
                <input id="inp-shuffle-max" type="range" min="5" max="180" step="1" value="60">
            </div>
            <div class="settings-row">
                <label for="inp-transition">Transition (s)</label>
                <input id="inp-transition" type="range" min="0" max="10" step="0.1" value="2.7">
            </div>
            <div class="settings-row">
                <label for="inp-pixelratio">Pixel Ratio</label>
                <input id="inp-pixelratio" type="range" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="settings-note">Settings apply to ProjectM v2. Shuffle times are randomized between min and max. Transition affects preset morph duration. Pixel ratio applies on next init.</div>
            <div class="settings-actions">
                <button class="btn-small" id="btn-settings-apply">Apply</button>
                <button class="btn-small" id="btn-settings-close">Close</button>
            </div>
        </div>
    </div>
    
    <!-- WebM Settings Panel -->
    <div id="webm-settings-panel" class="display-none">
        <div class="panel-head">
            <h3>AVATER SETTINGS</h3>
            <button class="btn-small" id="btn-webm-reset" title="Reset to defaults">Reset</button>
        </div>
        <div id="webm-settings-content">
            <div class="settings-row">
                <label for="inp-webm-scale">Size (vw)</label>
                <input id="inp-webm-scale" type="range" min="10" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-x">X (vw)</label>
                <input id="inp-webm-x" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-y">Y (vh)</label>
                <input id="inp-webm-y" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-rot">Rotate (deg)</label>
                <input id="inp-webm-rot" type="range" min="-180" max="180" step="1" value="0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-speed">Speed</label>
                <input id="inp-webm-speed" type="range" min="0.1" max="4" step="0.1" value="1.0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-opacity">Opacity</label>
                <input id="inp-webm-opacity" type="range" min="0" max="1" step="0.01" value="0.82">
            </div>
            <div class="settings-row">
                <label for="inp-webm-dup">Duplicates (0-2)</label>
                <input id="inp-webm-dup" type="range" min="0" max="2" step="1" value="0">
            </div>
            <div class="settings-actions">
                <button class="btn-small" id="btn-webm-apply">Apply</button>
                <button class="btn-small" id="btn-webm-close">Close</button>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        import butterchurn from 'butterchurn';
        import butterchurnPresets from 'butterchurn-presets';

        // --- GLOBAL STATE ---
        const state = {
            audioCtx: null,
            sourceNode: null,
            analyserNode: null,
            isPlaying: false,
            currentModeIdx: 0,
            activeVisualizer: null,
            idleTimer: null,
            mediaStream: null
        };

        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('loading-status');
        const uiLayer = document.getElementById('ui-layer');
        const radioQuickBtn = document.getElementById('radio-quick');
        const radioPanel = document.getElementById('radio-panel');
        const radioListEl = document.getElementById('radio-list');
        const radioInputEl = document.getElementById('radio-url');
        const audioEl = document.getElementById('radio-element');
        const stationBanner = document.getElementById('station-banner');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsBtn = document.getElementById('btn-settings');
        const settingsApplyBtn = document.getElementById('btn-settings-apply');
        const settingsCloseBtn = document.getElementById('btn-settings-close');
        const inpShuffleMin = document.getElementById('inp-shuffle-min');
        const inpShuffleMax = document.getElementById('inp-shuffle-max');
        const inpTransition = document.getElementById('inp-transition');
        const inpPixelRatio = document.getElementById('inp-pixelratio');
        const webmOverlayEl = document.getElementById('webm-overlay');
        const webmVideoEl = document.getElementById('webm-video');
        const webmVideoLeftEl = document.getElementById('webm-video-left');
        const webmVideoRightEl = document.getElementById('webm-video-right');
        const webmBtn = document.getElementById('btn-webm');
        const webmPrevBtn = document.getElementById('webm-prev');
        const webmNextBtn = document.getElementById('webm-next');
        const webmSettingsPanel = document.getElementById('webm-settings-panel');
        const webmApplyBtn = document.getElementById('btn-webm-apply');
        const webmCloseBtn = document.getElementById('btn-webm-close');
        const inpWebmScale = document.getElementById('inp-webm-scale');
        const inpWebmX = document.getElementById('inp-webm-x');
        const inpWebmY = document.getElementById('inp-webm-y');
        const inpWebmRot = document.getElementById('inp-webm-rot');
        const inpWebmSpeed = document.getElementById('inp-webm-speed');
        const inpWebmOpacity = document.getElementById('inp-webm-opacity');
        const inpWebmDup = document.getElementById('inp-webm-dup');
        const stations = [];
        let currentStationIndex = -1;
        let panelIdleTimer = null;
        let webmList = [];
        let webmIndex = 0;
        let webmOn = false;
        let radioPanelTimer = null;
        let settingsPanelTimer = null;
        let webmSettingsTimer = null;
        // Hold the radio button visible after right-click random selection
        let radioQuickHoldUntil = 0;
        let radioQuickHoldTimeout = null;
        const webmSettings = {
            scaleVw: 50,
            posXvw: 50,
            posYvh: 50,
            rotationDeg: 0,
            playbackRate: 1.0,
            opacity: 0.82,
            duplicates: 0
        };
        let modeShuffleOn = false;
        let modeShuffleTimer = null;
        
        // Settings state (for ProjectM v2)
        const visualSettings = {
            shuffleMinSec: 30,
            shuffleMaxSec: 60,
            transitionSec: 2.7,
            pixelRatio: 1
        };

        // --- UI UTILS ---
        function resetIdleTimer() {
            uiLayer.style.opacity = '1';
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            if(!stationBanner.classList.contains('display-none')) {
                stationBanner.style.opacity = '1';
                stationBanner.style.pointerEvents = 'auto';
            }
            if(!radioPanel.classList.contains('display-none')) {
                radioPanel.style.opacity = '1';
                radioPanel.style.pointerEvents = 'auto';
            }
            // Show webm nav when overlay is active
            if(webmOn && !webmOverlayEl.classList.contains('display-none')) {
                webmPrevBtn.style.opacity = '1';
                webmNextBtn.style.opacity = '1';
                webmPrevBtn.style.pointerEvents = 'auto';
                webmNextBtn.style.pointerEvents = 'auto';
            }
            document.body.style.cursor = 'default';
            if (state.idleTimer) clearTimeout(state.idleTimer);
            if (panelIdleTimer) clearTimeout(panelIdleTimer);
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            if(state.isPlaying) {
                state.idleTimer = setTimeout(() => {
                    uiLayer.style.opacity = '0';
                    // Honor hold window after right-click
                    if (Date.now() >= radioQuickHoldUntil) {
                        radioQuickBtn.style.opacity = '0';
                        radioQuickBtn.style.pointerEvents = 'none';
                    }
                    if(!stationBanner.classList.contains('display-none')) {
                        stationBanner.style.opacity = '0';
                        stationBanner.style.pointerEvents = 'none';
                    }
                    // Hide webm nav
                    webmPrevBtn.style.opacity = '0';
                    webmNextBtn.style.opacity = '0';
                    webmPrevBtn.style.pointerEvents = 'none';
                    webmNextBtn.style.pointerEvents = 'none';
                    document.body.style.cursor = 'none';
                }, 3000);
                // Panels fade out and close after 30s if open
                if(!radioPanel.classList.contains('display-none')) scheduleRadioPanelClose();
                if(!settingsPanel.classList.contains('display-none')) scheduleSettingsPanelClose();
                if(!webmSettingsPanel.classList.contains('display-none')) scheduleWebmSettingsClose();
            }
        }
        window.addEventListener('mousemove', resetIdleTimer);
        window.addEventListener('click', resetIdleTimer);

        // Updated Fullscreen Logic with forced Resize Trigger
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => forceResize(), 200);
                }).catch(err => console.log(err));
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().then(() => {
                        setTimeout(() => forceResize(), 200);
                    });
                }
            }
        }

        function forceResize() {
            if(state.activeVisualizer && state.activeVisualizer.onResize) {
                state.activeVisualizer.onResize();
            }
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyserNode = state.audioCtx.createAnalyser();
                state.analyserNode.fftSize = 2048; 
            }
            if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
        }
        
        // Enable/disable start controls (radio/mic/file/url)
        function setStartControlsEnabled(enabled) {
            const btnRadio = document.getElementById('btn-radio');
            const btnMic = document.getElementById('btn-mic');
            const btnFile = document.getElementById('btn-file');
            const urlInput = document.getElementById('radio-url');
            [btnRadio, btnMic, btnFile, urlInput].forEach(el => {
                if(!el) return;
                if(enabled) {
                    el.removeAttribute('disabled');
                    el.setAttribute('tabindex', '0');
                } else {
                    el.setAttribute('disabled', 'true');
                    el.setAttribute('tabindex', '-1');
                }
            });
        }
        function showOverlay() {
            const overlay = document.getElementById('overlay');
            overlay.classList.remove('hidden');
            setStartControlsEnabled(true);
        }
        function hideOverlay() {
            const overlay = document.getElementById('overlay');
            overlay.classList.add('hidden');
            setStartControlsEnabled(false);
        }

        function playRadio() {
            initAudio();
            const url = radioInputEl.value;
            
            statusEl.innerText = "Connecting to Stream...";
            // Update banner title
            if(currentStationIndex >= 0 && stations[currentStationIndex] && stations[currentStationIndex].url === url) {
                showStationBanner(stations[currentStationIndex].name);
            } else {
                showStationBanner(deriveTitleFromUrl(url));
            }
            
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaElementSource(audioEl);
                state.sourceNode.connect(state.analyserNode);
                state.analyserNode.connect(state.audioCtx.destination);
                if(!state.isPlaying) startGame();
            }).catch(e => {
                statusEl.innerText = "Stream Error: CORS or Format.";
                alert("Stream failed to play. The radio station might be blocking browser visualizers.");
            });
        }

        async function useMic() {
            initAudio();
            statusEl.innerText = "Requesting Mic Access...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaStreamSource(stream);
                state.mediaStream = stream;
                state.sourceNode.connect(state.analyserNode);
                startGame();
            } catch(e) { statusEl.innerText = "Error: " + e.message; }
        }

        function useFile(e) {
            initAudio();
            const file = e.target.files[0];
            if(!file) return;
            statusEl.innerText = "Decoding...";
            const reader = new FileReader();
            reader.onload = (ev) => {
                state.audioCtx.decodeAudioData(ev.target.result, (buffer) => {
                    if(state.sourceNode) state.sourceNode.stop();
                    state.sourceNode = state.audioCtx.createBufferSource();
                    state.sourceNode.buffer = buffer;
                    state.sourceNode.loop = true;
                    state.sourceNode.connect(state.analyserNode);
                    state.analyserNode.connect(state.audioCtx.destination);
                    state.sourceNode.start(0);
                    startGame();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function startGame() {
            state.isPlaying = true;
            hideOverlay();
            document.getElementById('ui-layer').classList.remove('hidden');
            loadMode(0); // Start with ProjectM
            resetIdleTimer();
        }

function stopAllAndShowStart() {
    // Stop active visualizer
    if (state.activeVisualizer && typeof state.activeVisualizer.destroy === 'function') {
        try { state.activeVisualizer.destroy(); } catch(e) {}
    }
    state.activeVisualizer = null;
    // Stop audio sources
    try {
        if (state.sourceNode) {
            try { state.sourceNode.disconnect(); } catch(e) {}
            try { if (typeof state.sourceNode.stop === 'function') state.sourceNode.stop(0); } catch(e) {}
            state.sourceNode = null;
        }
        if (state.mediaStream) {
            try { state.mediaStream.getTracks().forEach(t => t.stop()); } catch(e) {}
            state.mediaStream = null;
        }
        if (audioEl) {
            try { audioEl.pause(); } catch(e) {}
            try { audioEl.currentTime = 0; } catch(e) {}
            try { audioEl.src = ''; audioEl.load(); } catch(e) {}
        }
    } catch (err) { /* ignore */ }
    // Hide player UI and other overlays, show start overlay
    document.getElementById('ui-layer').classList.add('hidden');
    if (typeof hideRadioPanel === 'function') { try { hideRadioPanel(); } catch(e) {} }
    const sb = document.getElementById('station-banner');
    if (sb) { sb.classList.add('display-none'); }
    if (typeof hideWebm === 'function' && typeof webmOn !== 'undefined' && webmOn) {
        try { hideWebm(); } catch(e) {}
    }
    state.isPlaying = false;
    showOverlay();
}
        // --- ENGINE: BUTTERCHURN ---
        class MilkdropEngine {
            constructor() {
                this.name = "ProjectM / Milkdrop";
                this.presets = butterchurnPresets.getPresets();
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null; // Track canvas reference
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                
                // FIX: Explicitly set canvas attributes to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                container.appendChild(this.canvas);

                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                const key = this.presetKeys[idx];
                this.visualizer.loadPreset(this.presets[key], 2.7); 
                document.getElementById('mode-sub').innerText = key;
            }

            nextPreset() {
                // Pick a random preset different from current
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 30;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 60;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }
            
            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                } catch(e) { alert("Invalid JSON"); }
            }

            onResize() { 
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    // FIX: Update attributes AND renderer
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: BUTTERCHURN v2 (Enhanced) ---
        class MilkdropEngineV2 {
            constructor() {
                this.name = "ProjectM v2";
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null;
                this.transitionSec = visualSettings.transitionSec;
                // Use global preset map directly (largest available pack)
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                container.appendChild(this.canvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if(this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                document.getElementById('mode-sub').innerText = key;
            }

            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, Number(visualSettings.transitionSec) || 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                } catch(e) { alert("Invalid JSON"); }
            }

            nextPreset() {
                if(this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            applySettings() {
                // Restart scheduling with new shuffle window
                this.restartCycle();
                // Transition seconds will be used on next loadPreset call automatically
            }

            onResize() {
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: THREE.JS ---
        class ThreeEngine {
            constructor(name, sceneFn) {
                this.name = name;
                this.sceneFn = sceneFn;
                this.resizeHandler = this.onResize.bind(this);
            }

            init() {
                container.innerHTML = '';
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 4;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio); // Sharpness
                container.appendChild(this.renderer.domElement);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);
                this.updateFn = this.sceneFn(this.scene, this.camera, this.composer);
                
                window.addEventListener('resize', this.resizeHandler);
                this.animate();
            }

            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                state.analyserNode.getByteFrequencyData(this.dataArray);
                if(this.updateFn) this.updateFn(this.dataArray, performance.now());
                this.composer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                window.removeEventListener('resize', this.resizeHandler);
                this.renderer.dispose();
                container.innerHTML = '';
            }
        }

        // --- SCENES ---
        const sceneSphere = (scene) => {
            const geo = new THREE.IcosahedronGeometry(1.8, 30);
            const mat = new THREE.MeshPhysicalMaterial({ wireframe: true, color: 0x00ff00, emissive: 0x004400 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            return (data, time) => {
                const bass = data[20]/255; 
                const t = time*0.0005;
                mesh.rotation.y += 0.005; 
                mesh.scale.setScalar(1 + bass*0.5); 
                mesh.material.color.setHSL(t%1, 1, 0.5);
            };
        };

        const sceneTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const count = 40;
            const meshes = [];
            for(let i=0; i<count; i++){
                const geo = new THREE.TorusGeometry(1+(i*0.5), 0.05, 8, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);
                meshes.push(mesh);
            }
            scene.add(group);
            return (data, time) => {
                const step = Math.floor(data.length/count);
                for(let i=0; i<count; i++){
                    const val = data[i*step]/255;
                    meshes[i].scale.setScalar(1 + val);
                    meshes[i].material.color.setHSL(val + (time*0.0002), 1, 0.5);
                    meshes[i].rotation.z += 0.01 * (i%2?1:-1);
                }
                camera.position.z = 25 + Math.sin(time*0.001)*5;
                camera.rotation.z = time * 0.0005;
            };
        };

        const sceneBars = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const numBars = 64;
            const spacing = 0.25;
            for(let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = (i - numBars/2) * spacing;
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0x00ffff, 1.2, 50);
            point.position.set(0, 5, 5);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / numBars);
                const t = time * 0.0008;
                for(let i = 0; i < numBars; i++) {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 3.0;
                    bars[i].scale.y = h;
                    bars[i].position.y = h * 0.25;
                    const hue = (i / numBars + t) % 1;
                    bars[i].material.color.setHSL(hue, 1, 0.5);
                    bars[i].material.emissive.setHSL(hue, 1, 0.2);
                }
                group.rotation.y = Math.sin(t * 0.5) * 0.2;
            };
        };

        // High-energy neon sphere variants
        const sceneElectroSphere = (scene, camera) => {
            const geo = new THREE.IcosahedronGeometry(1.6, 64);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.8, roughness: 0.2, emissive: 0x000000 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            const base = geo.attributes.position.array.slice();
            const noise = new SimplexNoise();
            const light = new THREE.PointLight(0x66ccff, 2.2, 40);
            light.position.set(2, 2, 4);
            scene.add(new THREE.AmbientLight(0xffffff, 0.25), light);
            camera.position.z = 5;
            return (data, time) => {
                const t = time*0.0007;
                const arr = geo.attributes.position.array;
                const bass = data[8]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = base[i], y = base[i+1], z = base[i+2];
                    const n = noise.noise3d(x*0.8 + t*0.9, y*0.8 - t*0.7, z*0.8 + t*0.6);
                    const scale = 1.0 + n*(0.12 + bass*0.8);
                    arr[i] = x*scale; arr[i+1] = y*scale; arr[i+2] = z*scale;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.rotation.y += 0.01 + bass*0.06;
                mesh.rotation.x += 0.004;
                const hue = (t*0.3 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.55);
                light.intensity = 1.8 + bass*3.2;
            };
        };

        const scenePhotonShell = (scene, camera) => {
            // Points on a sphere shell
            const num = 4000;
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const u = Math.random();
                const v = Math.random();
                const theta = 2*Math.PI*u;
                const phi = Math.acos(2*v-1);
                const r = 1.8;
                positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
                positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                positions[i*3+2] = r*Math.cos(phi);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            // Orbiting rings
            const rings = [];
            for(let i=0;i<3;i++){
                const ring = new THREE.TorusGeometry(2.0 + i*0.15, 0.03, 12, 200);
                const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
                const tor = new THREE.Mesh(ring, m);
                scene.add(tor);
                rings.push(tor);
            }
            camera.position.z = 6;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[10]/255;
                points.rotation.y = t*0.4 + bass*0.6;
                points.rotation.x = Math.sin(t*0.4)*0.2;
                const hue = (t*0.2 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.6);
                mat.size = 0.03 + bass*0.15;
                rings.forEach((r, i) => {
                    r.rotation.x = t*(i+1);
                    r.rotation.y = t*(i+1)*0.6;
                    r.material.color.setHSL((hue + i*0.1)%1, 1, 0.6);
                    r.material.opacity = 0.4 + bass*0.5;
                });
            };
        };

        const scenePulseOrb = (scene, camera) => {
            const layers = [];
            for(let i=0;i<3;i++){
                const geo = new THREE.SphereGeometry(1.5 + i*0.2, 64, 64);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true });
                mat.blending = THREE.AdditiveBlending;
                mat.depthWrite = false;
                const mesh = new THREE.Mesh(geo, mat);
                layers.push(mesh);
                scene.add(mesh);
            }
            const light = new THREE.PointLight(0xffffff, 1.2, 60);
            light.position.set(0, 0, 8);
            scene.add(new THREE.AmbientLight(0xffffff, 0.25), light);
            camera.position.z = 7;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                const mid = data[24]/255;
                layers.forEach((m, i) => {
                    const hue = (t*0.15 + i*0.15) % 1;
                    m.material.color.setHSL(hue, 1, 0.6);
                    const s = 1.0 + bass*(0.6 + i*0.2) + Math.sin(t*2 + i)*0.05;
                    m.scale.setScalar(s);
                    m.rotation.y += 0.003 + mid*0.02 + i*0.002;
                    m.rotation.x += 0.002 + i*0.001;
                    m.material.opacity = 0.25 + bass*(0.3 + i*0.15);
                });
                light.intensity = 1.0 + bass*3.0;
            };
        };

        // New scenes
        const sceneStarfield = (scene, camera) => {
            const stars = [];
            const geo = new THREE.SphereGeometry(0.02, 6, 6);
            for(let i=0;i<1200;i++){
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: Math.random()*0.8+0.2 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                scene.add(m); stars.push(m);
            }
            camera.position.z = 6;
            return (data, time) => {
                const bass = data[8]/255;
                const t = time*0.0002;
                stars.forEach((s, i) => {
                    s.position.z += 0.02 + bass*0.3;
                    if(s.position.z > 40) s.position.z = -40;
                    const hue = (i/1200 + t) % 1;
                    s.material.color.setHSL(hue, 0.7, 0.6);
                });
                camera.rotation.z = Math.sin(t*2)*0.1;
            };
        };

        const sceneWaveGrid = (scene, camera) => {
            const gridSize = 64;
            const spacing = 0.2;
            const group = new THREE.Group();
            const planes = [];
            for(let x=0;x<gridSize;x++){
                for(let y=0;y<gridSize;y++){
                    const geo = new THREE.PlaneGeometry(0.18, 0.18);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set((x - gridSize/2)*spacing, (y - gridSize/2)*spacing, 0);
                    group.add(p);
                    planes.push(p);
                }
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / gridSize);
                const t = time * 0.0015;
                planes.forEach((p, idx) => {
                    const i = idx % gridSize;
                    const j = Math.floor(idx / gridSize);
                    const v = data[(i*step) % data.length]/255;
                    p.position.z = Math.sin(i*0.2 + j*0.25 + t*4) * (0.1 + v*0.8);
                    const hue = (v + (i+j)/ (gridSize*2) + t*0.2)%1;
                    p.material.color.setHSL(hue, 1, 0.5);
                    p.material.opacity = 0.35 + v*0.65;
                });
                group.rotation.x = Math.sin(t*0.2)*0.4;
                group.rotation.y = Math.cos(t*0.25)*0.4;
            };
        };

        const sceneParticles = (scene, camera) => {
            const num = 1500;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                positions[i*3+0] = (Math.random()-0.5)*40;
                positions[i*3+1] = (Math.random()-0.5)*40;
                positions[i*3+2] = (Math.random()-0.5)*40;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 10;
            return (data, time) => {
                const bass = data[4]/255;
                points.rotation.y += 0.001 + bass*0.01;
                points.rotation.x += 0.0006;
                const hue = (time*0.0001)%1;
                points.material.color.setHSL(hue, 1, 0.6);
                points.material.size = 0.05 + bass*0.25;
            };
        };

        // --- Additional Tunnel Variants ---
        const sceneNeonTunnel = (scene, camera) => {
            const rings = [];
            const count = 36;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(2.5, 0.08, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.4;
                rings.push(m);
                scene.add(m);
            }
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[8]/255;
                rings.forEach((r, i) => {
                    r.position.z += 0.12 + bass*0.6;
                    if(r.position.z > 3.5) r.position.z -= count*1.4;
                    const hue = ((i/count) + time*0.0002) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.rotation.x = time*0.0006 + i*0.03;
                });
                camera.rotation.z = Math.sin(time*0.0006)*0.15;
            };
        };

        const sceneTwistTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const segs = [];
            for(let i=0;i<90;i++){
                const geo = new THREE.CylinderGeometry(2.2, 2.2, 0.4, 60, 1, true);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff66ff, wireframe: true, transparent: true, opacity: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*0.9;
                m.rotation.z = i*0.1;
                group.add(m);
                segs.push(m);
            }
            scene.add(group);
            camera.position.z = 3.5;
            return (data, time) => {
                const mid = data[24]/255;
                segs.forEach((s, i) => {
                    s.position.z += 0.08 + mid*0.5;
                    if(s.position.z > 2.5) s.position.z -= 90*0.9;
                    s.rotation.z += 0.003 + mid*0.03;
                    const hue = ((i/90) + time*0.00015) % 1;
                    s.material.color.setHSL(hue, 1, 0.6);
                    s.material.opacity = 0.25 + mid*0.75;
                });
                group.rotation.y = Math.sin(time*0.0005)*0.3;
            };
        };

        const sceneParticleTunnel = (scene, camera) => {
            const num = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const r = 2 + Math.random()*2.5;
                const a = Math.random()*Math.PI*2;
                const z = -Math.random()*60;
                positions[i*3+0] = Math.cos(a)*r;
                positions[i*3+1] = Math.sin(a)*r;
                positions[i*3+2] = z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 3;
            return (data, time) => {
                const bass = data[6]/255;
                const arr = geo.attributes.position.array;
                for(let i=0;i<arr.length;i+=3){
                    arr[i+2] += 0.22 + bass*1.6;
                    if(arr[i+2] > 2.5) arr[i+2] -= 62.5;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0002)%1;
                mat.color.setHSL(hue, 1, 0.7);
                points.rotation.z += 0.001 + bass*0.02;
            };
        };

        const sceneGalaxy = (scene, camera) => {
            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            for(let i=0;i<count;i++){
                const r = Math.random() * 20;
                const angle = Math.random()*Math.PI*2;
                const arm = ((i%2) * 2 - 1) * (r*0.1);
                const x = Math.cos(angle + arm) * r;
                const y = (Math.random()-0.5) * 2;
                const z = Math.sin(angle + arm) * r;
                positions[i*3+0] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                const c = new THREE.Color().setHSL((r/20)*0.6 + 0.2, 1, 0.6);
                colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 16;
            return (data, time) => {
                const bass = data[10]/255;
                points.rotation.z = time*0.0001 + bass*0.2;
                mat.size = 0.04 + bass*0.18;
            };
        };

        const sceneKaleidoRings = (scene, camera) => {
            const group = new THREE.Group();
            const rings = [];
            for(let i=0;i<14;i++){
                const geo = new THREE.TorusGeometry(0.8 + i*0.35, 0.04, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const torus = new THREE.Mesh(geo, mat);
                group.add(torus);
                rings.push(torus);
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / rings.length);
                const t = time*0.0006;
                rings.forEach((r, i) => {
                    const v = data[i*step]/255;
                    r.rotation.x = t*(i%3+1);
                    r.rotation.y = -t*(i%2+1);
                    r.material.color.setHSL(((i/rings.length)+t)%1, 1, 0.55);
                    r.material.opacity = 0.3 + v*0.7;
                    r.scale.setScalar(1 + v*0.4);
                });
                group.rotation.z = Math.sin(t*2)*0.3;
            };
        };

        const sceneTerrain = (scene, camera) => {
            const size = 80;
            const segments = 120;
            const geo = new THREE.PlaneGeometry(size, size, segments, segments);
            const mat = new THREE.MeshStandardMaterial({ color: 0x4444ff, wireframe: false, metalness: 0.2, roughness: 0.9, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2.5;
            scene.add(mesh);
            const light = new THREE.PointLight(0x88ccff, 2, 120);
            light.position.set(0, 20, 20);
            scene.add(light, new THREE.AmbientLight(0xffffff, 0.35));
            const noise = new SimplexNoise();
            camera.position.set(0, 10, 22);
            return (data, time) => {
                const arr = geo.attributes.position.array;
                const t = time*0.0003;
                const bass = data[20]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = arr[i+0];
                    const y = arr[i+1];
                    const n = noise.noise3d(x*0.05, y*0.05, t)*2.0;
                    arr[i+2] = n + bass*3.0;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.material.color.setHSL((t*0.2 + bass*0.3)%1, 0.8, 0.5);
                light.intensity = 1.5 + bass*2.5;
            };
        };

        const sceneHexGrid = (scene, camera) => {
            const group = new THREE.Group();
            const hexes = [];
            const radius = 0.25;
            const rows = 22, cols = 22;
            for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                    const x = (c + (r%2?0.5:0)) * radius*1.8 - cols*radius*0.9;
                    const y = r * radius*1.6 - rows*radius*0.8;
                    const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 6, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, metalness: 0.1, roughness: 0.7 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x, y, 0);
                    m.rotation.x = Math.PI/2;
                    group.add(m);
                    hexes.push(m);
                }
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xff66ff, 1.6, 60);
            light.position.set(0, 0, 10);
            scene.add(light, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / hexes.length) || 1;
                const t = time*0.001;
                hexes.forEach((h, i) => {
                    const v = data[(i*step)%data.length]/255;
                    h.scale.z = 0.4 + v*2.8;
                    const hue = (v*0.6 + ((i%cols)/cols) + t*0.1)%1;
                    h.material.color.setHSL(hue, 1, 0.5);
                    h.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z = Math.sin(t*0.5)*0.2;
            };
        };

        const sceneRibbons = (scene, camera) => {
            const group = new THREE.Group();
            const ribbons = [];
            const createRibbon = (color) => {
                const points = [];
                for(let i=0;i<80;i++){
                    points.push(new THREE.Vector3(i*0.08, Math.sin(i*0.2)*0.4, 0));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tube = new THREE.TubeGeometry(curve, 200, 0.03, 8, false);
                const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.2, emissive: 0x000000 });
                const mesh = new THREE.Mesh(tube, mat);
                return mesh;
            };
            for(let i=0;i<6;i++){
                const hue = i/6;
                const col = new THREE.Color().setHSL(hue, 1, 0.6);
                const m = createRibbon(col);
                m.position.y = (i-3)*0.4;
                m.position.x = -3;
                group.add(m);
                ribbons.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.6), group);
            const light = new THREE.PointLight(0x66ffff, 2, 40);
            light.position.set(0, 2, 8);
            scene.add(light);
            camera.position.set(0, 2, 10);
            return (data, time) => {
                const bass = data[12]/255;
                const t = time*0.0012;
                ribbons.forEach((m, i) => {
                    m.rotation.y = t*(i%3+1);
                    m.rotation.x = Math.sin(t + i)*0.3;
                    m.position.x = -3 + Math.sin(t*0.7 + i)*2.5 + bass*2.0;
                });
                group.rotation.z = Math.sin(t*0.6)*0.2;
                light.intensity = 1.2 + bass*2.0;
            };
        };

        // --- Infinity Pattern Tunnels ---
        const sceneInfinityTunnel = (scene, camera, composer) => {
            const rings = [];
            const count = 64;
            const baseRadius = 2.2;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(baseRadius, 0.06, 12, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.0;
                rings.push(m);
                scene.add(m);
            }
            const after = new AfterimagePass(0.88);
            composer.addPass(after);
            camera.position.z = 4;
            return (data, time) => {
                const t = time * 0.001;
                const bass = data[10]/255;
                rings.forEach((r, i) => {
                    // Figure-eight cross-section via Lissajous pattern
                    const phase = (i*0.22) + t*1.2;
                    r.position.x = Math.sin(phase) * (baseRadius * 0.6);
                    r.position.y = Math.sin(phase*2.0) * (baseRadius * 0.35);
                    r.position.z += 0.18 + bass*0.8;
                    if(r.position.z > 2.5) r.position.z -= count*1.0;
                    const hue = ((i/count) + t*0.05) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.material.opacity = 0.35 + bass*0.6;
                    r.rotation.x = phase*0.2;
                    r.rotation.y = -phase*0.15;
                });
                camera.rotation.z = Math.sin(t*0.8)*0.2;
            };
        };

        const sceneInfinityMirror = (scene, camera, composer) => {
            const frames = [];
            const count = 40;
            for(let i=0;i<count;i++){
                const geo = new THREE.RingGeometry(0.8, 3.0, 6, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.z = -i*1.4;
                frames.push(ring);
                scene.add(ring);
            }
            const after = new AfterimagePass(0.9);
            composer.addPass(after);
            camera.position.z = 3.8;
            return (data, time) => {
                const t = time*0.001;
                const mid = data[24]/255;
                frames.forEach((f, i) => {
                    f.position.z += 0.14 + mid*0.7;
                    if(f.position.z > 2.5) f.position.z -= count*1.4;
                    const s = 0.9 + Math.sin(i*0.2 + t*2.0)*0.08 + mid*0.2;
                    f.scale.set(s, s, s);
                    f.rotation.z = t*0.7 + i*0.05;
                    const hue = ((i/count) + t*0.1) % 1;
                    f.material.color.setHSL(hue, 1, 0.65);
                    f.material.opacity = 0.3 + mid*0.7;
                });
            };
        };
        // --- Kaleidoscope Shader ---
        const KaleidoShader = {
            uniforms: {
                tDiffuse: { value: null },
                sides: { value: 6.0 },
                angle: { value: 0.0 },
                rotation: { value: 0.0 },
                time: { value: 0.0 },
                gain: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float sides;
                uniform float angle;
                uniform float rotation;
                uniform float time;
                uniform float gain;
                varying vec2 vUv;
                
                float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
                float noise(vec2 p){
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f*f*(3.0-2.0*f);
                    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
                }
                float fbm(vec2 p){
                    float v = 0.0;
                    float a = 0.5;
                    for(int i=0;i<5;i++){
                        v += a * noise(p);
                        p = p * 2.0 + vec2(23.1, 17.7);
                        a *= 0.5;
                    }
                    return v;
                }
                vec3 palette(float t){
                    return 0.5 + 0.5*cos(6.2831853*(vec3(0.0,0.33,0.67) + t));
                }
                vec4 fractalColor(vec2 uv){
                    // Centered uv for fractal evolution
                    vec2 q = uv - 0.5;
                    float r = length(q);
                    float ang = atan(q.y, q.x);
                    vec2 p = vec2(cos(ang), sin(ang)) * (r * 2.2);
                    float f = fbm(p * 1.8 + vec2(time*0.15, -time*0.11 + gain*0.3));
                    vec3 col = palette(f + r*0.25 + gain*0.2);
                    // Radial darkening to avoid bright center
                    float vign = smoothstep(0.95, 0.3, r);
                    return vec4(col * vign, 1.0);
                }
                void main() {
                    vec2 uv = vUv - 0.5;
                    float r = length(uv);
                    float a = atan(uv.y, uv.x) + rotation;
                    float sector = 6.28318530718 / max(1.0, sides);
                    a = mod(a, sector);
                    a = abs(a - sector * 0.5);
                    a += angle;
                    vec2 pos = vec2(cos(a), sin(a)) * r;
                    vec2 sampleUv = pos + 0.5;
                    bool inBounds = all(greaterThanEqual(sampleUv, vec2(0.0))) && all(lessThanEqual(sampleUv, vec2(1.0)));
                    vec4 src = texture2D(tDiffuse, clamp(sampleUv, 0.0, 1.0));
                    vec4 fractCol = fractalColor(sampleUv);
                    // Blend: use fractal when out-of-bounds, otherwise softly mix by radial factor to eliminate white cores
                    float mixAmt = smoothstep(0.0, 0.35, r) * 0.7 + gain*0.2;
                    vec4 col = mix(src, fractCol, mixAmt);
                    if(!inBounds){
                        col = fractCol;
                    }
                    gl_FragColor = col;
                }
            `
        };

        const RadialZoomShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    vec2 toCenter = center - vUv;
                    float offset = strength * 0.02;
                    for (float t = 0.0; t <= 1.0; t += 0.1) {
                        vec2 sampleUv = vUv + toCenter * t * offset;
                        color += texture2D(tDiffuse, sampleUv);
                        total += 1.0;
                    }
                    gl_FragColor = color / total;
                }
            `
        };

        // Helper: build a simple colorful source for kaleidoscope
        function buildKaleidoSource(scene) {
            const group = new THREE.Group();
            const num = 24;
            for(let i=0;i<num;i++){
                const hue = i/num;
                const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6) });
                const geo = new THREE.TorusKnotGeometry(0.5 + (i%6)*0.05, 0.12, 90, 18, 2 + (i%3), 3 + (i%4));
                const m = new THREE.Mesh(geo, mat);
                m.position.set(Math.cos(i)*2.2, Math.sin(i*1.3)*1.2, -1 - (i%5)*0.2);
                m.rotation.x = i*0.2;
                m.rotation.y = i*0.15;
                group.add(m);
            }
            scene.add(group);
            return group;
        }

        const sceneKaleido = (sides) => (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            pass.uniforms.sides.value = sides;
            composer.addPass(pass);
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[12]/255;
                group.rotation.y = time*0.0006 + bass*0.2;
                group.rotation.x = Math.sin(time*0.0004)*0.3;
                pass.uniforms.rotation.value = time*0.0002 + bass*0.6;
                pass.uniforms.angle.value = Math.sin(time*0.0005)*0.5;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = bass;
            };
        };

        const sceneKaleidoSpiral = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            composer.addPass(pass);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[6]/255;
                pass.uniforms.sides.value = 5.0 + Math.floor((Math.sin(time*0.0007)+1.0)*3.5); // 5..12
                pass.uniforms.rotation.value = time*0.00035 + bass*0.8;
                pass.uniforms.angle.value = Math.cos(time*0.0006)*0.8;
                group.rotation.y += 0.002 + bass*0.02;
                group.rotation.z = Math.sin(time*0.0003)*0.4;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = (data[12]+data[24])/(2.0*255.0);
            };
        };

        const sceneKaleidoLayered = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const k1 = new ShaderPass(KaleidoShader);
            const k2 = new ShaderPass(KaleidoShader);
            k1.uniforms.sides.value = 7.0;
            k2.uniforms.sides.value = 11.0;
            composer.addPass(k1);
            composer.addPass(k2);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[10]/255;
                group.rotation.x = time*0.0005;
                group.rotation.y = Math.sin(time*0.0003)*0.4;
                k1.uniforms.rotation.value = time*0.0002 + bass*0.5;
                k2.uniforms.rotation.value = -time*0.00025 + bass*0.7;
                k1.uniforms.angle.value = Math.sin(time*0.0004)*0.6;
                k2.uniforms.angle.value = Math.cos(time*0.00045)*0.6;
                k1.uniforms.time.value = time*0.001;
                k2.uniforms.time.value = time*0.001;
                const g = (data[6]+data[12]+data[24])/(3.0*255.0);
                k1.uniforms.gain.value = g;
                k2.uniforms.gain.value = g*0.8;
            };
        };

        const sceneKaleidoZoom = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const kaleido = new ShaderPass(KaleidoShader);
            const zoom = new ShaderPass(RadialZoomShader);
            composer.addPass(kaleido);
            composer.addPass(zoom);
            camera.position.z = 4.5;
            return (data, time) => {
                const bass = data[14]/255;
                group.rotation.y = time*0.0005 + bass*0.3;
                kaleido.uniforms.sides.value = 10.0;
                kaleido.uniforms.rotation.value = time*0.00025;
                zoom.uniforms.center.value.set(0.5, 0.5);
                zoom.uniforms.strength.value = 0.1 + bass*0.6;
                kaleido.uniforms.time.value = time*0.001;
                kaleido.uniforms.gain.value = (data[10]+data[14]+data[18])/(3.0*255.0);
            };
        };

        // --- Self-Replicating / Fractal Scenes ---
        const sceneMengerSponge = (scene, camera) => {
            const depth = 2; // keep counts reasonable
            const positions = [];
            function addLevel(center, size, d){
                if(d === 0){
                    positions.push({ center, size });
                    return;
                }
                const step = size / 3;
                for(let x=0;x<3;x++){
                    for(let y=0;y<3;y++){
                        for(let z=0;z<3;z++){
                            // Skip the center cross sections
                            const mid = (x===1) + (y===1) + (z===1);
                            if(mid >= 2) continue;
                            const nx = center.x + (x-1)*step;
                            const ny = center.y + (y-1)*step;
                            const nz = center.z + (z-1)*step;
                            addLevel(new THREE.Vector3(nx, ny, nz), step, d-1);
                        }
                    }
                }
            }
            addLevel(new THREE.Vector3(0,0,0), 6, depth);
            const count = positions.length;
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.3, roughness: 0.6, emissive: 0x000000 });
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            const dummy = new THREE.Object3D();
            positions.forEach((p, i) => {
                dummy.position.copy(p.center);
                dummy.scale.setScalar(p.size * 0.95);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            });
            mesh.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(6, 8, 10);
            scene.add(light, mesh);
            camera.position.set(0, 0, 14);
            return (data, time) => {
                const g = (data[6]+data[12]+data[24])/(3*255);
                mesh.rotation.x = time*0.0003 + g*0.4;
                mesh.rotation.y = time*0.0004 + g*0.5;
                mat.emissiveIntensity = 0.2 + g*2.0;
                const hue = (time*0.00008 + g*0.3) % 1;
                mat.color.setHSL(hue, 0.7, 0.6);
            };
        };

        const sceneSierpinskiTetra = (scene, camera) => {
            // Base tetra geometry
            const r = 1;
            const v = [
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1),
                new THREE.Vector3(1, -1, -1)
            ];
            const base = new THREE.TetrahedronGeometry(r, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff88aa, metalness: 0.2, roughness: 0.7 });
            const depth = 4;
            const transforms = [];
            function add(level, center, scale){
                if(level === 0){
                    transforms.push({ center, scale });
                    return;
                }
                const s = scale * 0.5;
                for(let i=0;i<4;i++){
                    add(level-1, new THREE.Vector3(
                        center.x + v[i].x * s,
                        center.y + v[i].y * s,
                        center.z + v[i].z * s
                    ), s);
                }
            }
            add(depth, new THREE.Vector3(0,0,0), 3.0);
            const inst = new THREE.InstancedMesh(base, mat, transforms.length);
            const dummy = new THREE.Object3D();
            transforms.forEach((t, i) => {
                dummy.position.copy(t.center);
                dummy.scale.setScalar(t.scale);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.PointLight(0xff66ff, 2.4, 100);
            light.position.set(6, 6, 12);
            scene.add(light, inst);
            camera.position.set(0, 0, 16);
            return (data, time) => {
                const bass = data[8]/255;
                inst.rotation.y = time*0.00035 + bass*0.6;
                inst.rotation.x = time*0.0002;
                const hue = (time*0.00012) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                light.intensity = 1.4 + bass*3.0;
            };
        };

        const sceneGameOfLife = (scene, camera) => {
            const W = 128, H = 128;
            const cells = new Uint8Array(W*H);
            const nextCells = new Uint8Array(W*H);
            // random init
            for(let i=0;i<W*H;i++){ cells[i] = Math.random() < 0.15 ? 1 : 0; }
            const data = new Uint8Array(W*H*3);
            const tex = new THREE.DataTexture(data, W, H, THREE.RGBFormat);
            tex.needsUpdate = true;
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.95 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), mat);
            scene.add(plane);
            camera.position.z = 10;
            function step() {
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        let n = 0;
                        for(let dy=-1;dy<=1;dy++){
                            for(let dx=-1;dx<=1;dx++){
                                if(dx===0 && dy===0) continue;
                                const nx = (x+dx+W)%W;
                                const ny = (y+dy+H)%H;
                                n += cells[ny*W + nx];
                            }
                        }
                        const c = cells[idx];
                        nextCells[idx] = (c===1 && (n===2 || n===3)) || (c===0 && n===3) ? 1 : 0;
                    }
                }
                cells.set(nextCells);
            }
            let acc = 0;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3*255);
                // step a few times per second + boost with audio
                acc += 0.016 + g*0.05;
                while(acc > 0.1){ step(); acc -= 0.1; }
                // write texture
                const t = time*0.0002;
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        const alive = cells[idx];
                        const i3 = idx*3;
                        const hue = (t + x/W*0.3 + y/H*0.2) % 1;
                        const c = alive ? hue : 0.0;
                        // hsv to rgb approx via palette
                        const r = 0.5 + 0.5*Math.cos(6.2831*(c + 0.0));
                        const gch = 0.5 + 0.5*Math.cos(6.2831*(c + 0.33));
                        const b = 0.5 + 0.5*Math.cos(6.2831*(c + 0.67));
                        data[i3+0] = Math.floor(r*255);
                        data[i3+1] = Math.floor(gch*255);
                        data[i3+2] = Math.floor(b*255);
                    }
                }
                tex.needsUpdate = true;
                plane.rotation.z = Math.sin(time*0.0003)*0.2;
                plane.scale.setScalar(1.0 + g*0.3);
            };
        };

        // Mandelbrot (shader)
        const sceneMandelbrot = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                center: { value: new THREE.Vector2(-0.5, 0.0) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 center;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 c = center + uv / zoom;
                        vec2 z = vec2(0.0);
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            float x = (z.x*z.x - z.y*z.y) + c.x;
                            float y = (2.0*z.x*z.y) + c.y;
                            z = vec2(x,y);
                            if(dot(z,z) > 4.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.5), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                const baseZoom = 0.85 + Math.sin(time*0.0001)*0.15;
                uni.zoom.value = 1.5 + baseZoom * (1.0 + g*4.0);
                uni.center.value.set(-0.5 + Math.sin(time*0.00008)*0.15, Math.cos(time*0.00006)*0.1);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Julia Set (shader)
        const sceneJulia = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                c: { value: new THREE.Vector2(-0.70176, -0.3842) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 c;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 z = uv / zoom * 2.0;
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                            if(dot(z,z) > 16.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.55), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[8]+audio[16]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                uni.zoom.value = 1.4 + 0.6*Math.sin(time*0.0002) + g*2.2;
                const ang = time*0.00015;
                uni.c.value.set(Math.cos(ang)*0.7, Math.sin(ang*1.3)*0.5);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Barnsley Fern (points)
        const sceneBarnsleyFern = (scene, camera) => {
            const num = 30000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x66ff99, size: 0.03, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 8;
            let x = 0, y = 0;
            function step() {
                const r = Math.random();
                let nx, ny;
                if (r < 0.01) { nx = 0.0; ny = 0.16*y; }
                else if (r < 0.86) { nx = 0.85*x + 0.04*y; ny = -0.04*x + 0.85*y + 1.6; }
                else if (r < 0.93) { nx = 0.2*x - 0.26*y; ny = 0.23*x + 0.22*y + 1.6; }
                else { nx = -0.15*x + 0.28*y; ny = 0.26*x + 0.24*y + 0.44; }
                x = nx; y = ny;
            }
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                for (let i=0;i<num;i++) {
                    step();
                    positions[i*3+0] = x*1.6 - 2.0;
                    positions[i*3+1] = y*1.6 - 3.0;
                    positions[i*3+2] = 0;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0001 + g*0.5) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                points.rotation.z = Math.sin(time*0.0003)*0.1;
                points.scale.setScalar(1.0 + g*0.2);
            };
        };

        // Lorenz Attractor (line)
        const sceneLorenz = (scene, camera) => {
            const maxPts = 6000;
            const positions = new Float32Array(maxPts*3);
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            camera.position.z = 30;
            let x = 0.01, y = 0.0, z = 0.0;
            const dt = 0.005;
            const sigma = 10.0, rho = 28.0, beta = 8.0/3.0;
            let idx = 0;
            return (audio, time) => {
                const g = (audio[10]+audio[18])/(2.0*255.0);
                for (let k=0;k<10;k++) {
                    const dx = sigma*(y - x);
                    const dy = x*(rho - z) - y;
                    const dz = x*y - beta*z;
                    x += dx*dt;
                    y += dy*dt;
                    z += dz*dt;
                    positions[idx*3+0] = x;
                    positions[idx*3+1] = y;
                    positions[idx*3+2] = z - 20.0;
                    idx = (idx + 1) % maxPts;
                }
                geo.attributes.position.needsUpdate = true;
                line.rotation.y = time*0.0002 + g*0.4;
                line.rotation.x = Math.sin(time*0.0003)*0.2;
                const hue = (time*0.00008 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
            };
        };

        // Sierpinski Carpet (instanced)
        const sceneSierpinskiCarpet = (scene, camera) => {
            const depth = 4;
            const squares = [];
            function add(level, cx, cy, size) {
                if (level === 0) { squares.push({ cx, cy, size }); return; }
                const s3 = size/3;
                for (let dx=-1; dx<=1; dx++){
                    for (let dy=-1; dy<=1; dy++){
                        if (dx === 0 && dy === 0) continue;
                        add(level-1, cx + dx*s3, cy + dy*s3, s3);
                    }
                }
            }
            add(depth, 0, 0, 6);
            const geo = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const inst = new THREE.InstancedMesh(geo, mat, squares.length);
            const dummy = new THREE.Object3D();
            squares.forEach((s, i) => {
                dummy.position.set(s.cx, s.cy, 0);
                dummy.scale.set(s.size*0.95, s.size*0.95, 1);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(inst);
            camera.position.z = 10;
            return (audio, time) => {
                const g = (audio[4]+audio[12]+audio[28])/(3.0*255.0);
                const hue = (time*0.00015 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
                inst.rotation.z = Math.sin(time*0.0003)*0.2;
                inst.scale.setScalar(1.0 + g*0.25);
            };
        };

        // --- Emoji Helpers and Scenes ---
        function createEmojiTexture(char) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '200px Apple Color Emoji, Noto Color Emoji, Segoe UI Emoji, EmojiOne Mozilla, Twemoji Mozilla, Segoe UI Symbol, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(char, size/2, size/2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const EMOJIS = ['üéµ','‚ú®','üî•','üí´','üåà','üí•','‚ù§Ô∏è','üåÄ','üåü','ü§ñ','üéß','üéâ','üéá','üõ∞Ô∏è','ü™ê','‚ö°Ô∏è'];

        const sceneEmojiSwarm = (scene, camera) => {
            const sprites = [];
            const velocities = [];
            const count = 240;
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            for(let i=0;i<count;i++){
                const tex = textures[i % textures.length];
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                const spr = new THREE.Sprite(mat);
                spr.position.set((Math.random()-0.5)*18, (Math.random()-0.5)*10, (Math.random()-0.5)*12);
                const s = Math.random()*0.7 + 0.3;
                spr.scale.set(s, s, 1);
                sprites.push(spr);
                velocities.push(new THREE.Vector3((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03));
                scene.add(spr);
            }
            camera.position.z = 8;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                sprites.forEach((s, i) => {
                    const v = velocities[i];
                    // Simple cohesion toward origin + slight orbit
                    const toCenter = s.position.clone().multiplyScalar(-0.002);
                    v.add(toCenter);
                    v.x += Math.sin(t + i*0.1)*0.001;
                    v.y += Math.cos(t*0.8 + i*0.07)*0.001;
                    s.position.add(v);
                    // Wrap bounds
                    if(s.position.x > 10) s.position.x = -10;
                    if(s.position.x < -10) s.position.x = 10;
                    if(s.position.y > 6) s.position.y = -6;
                    if(s.position.y < -6) s.position.y = 6;
                    if(s.position.z > 8) s.position.z = -8;
                    if(s.position.z < -8) s.position.z = 8;
                    // Pulse size with bass
                    const base = 0.3 + (i%5)*0.04;
                    const pulse = base + bass*0.8;
                    s.scale.set(pulse, pulse, 1);
                    s.material.opacity = 0.6 + bass*0.4;
                });
                camera.rotation.z = Math.sin(t*0.4)*0.1;
            };
        };

        const sceneEmojiOrbits = (scene, camera) => {
            const group = new THREE.Group();
            scene.add(group);
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            const rings = [];
            for(let r=0;r<5;r++){
                const ringGroup = new THREE.Group();
                const num = 18 + r*6;
                const radius = 2.0 + r*1.2;
                for(let i=0;i<num;i++){
                    const tex = textures[(i+r) % textures.length];
                    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                    const spr = new THREE.Sprite(mat);
                    const a = (i/num)*Math.PI*2;
                    spr.position.set(Math.cos(a)*radius, Math.sin(a)*radius, -r*0.4);
                    const s = 0.25 + r*0.08;
                    spr.scale.set(s, s, 1);
                    ringGroup.add(spr);
                }
                group.add(ringGroup);
                rings.push({ group: ringGroup, radius });
            }
            camera.position.z = 8;
            return (data, time) => {
                const bass = data[8]/255;
                const mid = data[24]/255;
                rings.forEach((r, i) => {
                    r.group.rotation.z += 0.002 + bass*0.02 + i*0.0005;
                    r.group.position.z = Math.sin(time*0.0006 + i)*0.6;
                    r.group.children.forEach((spr, j) => {
                        spr.material.rotation = time*0.0004 + j*0.05;
                        const s = spr.scale.x;
                        const pulse = s * (1.0 + mid*0.8*Math.sin(time*0.004 + j));
                        spr.scale.set(pulse, pulse, 1);
                    });
                });
                group.rotation.x = Math.sin(time*0.0004)*0.2;
                group.rotation.y = Math.cos(time*0.0003)*0.2;
            };
        };

        // --- MASTER CONTROL ---
        const modes = [
            new MilkdropEngine(),
            new MilkdropEngineV2(),
            new ThreeEngine("Neon Sphere", sceneSphere),
            new ThreeEngine("Electro Sphere", sceneElectroSphere),
            new ThreeEngine("Photon Shell", scenePhotonShell),
            new ThreeEngine("Pulse Orb", scenePulseOrb),
            new ThreeEngine("Cyber Tunnel", sceneTunnel),
            new ThreeEngine("Audio Bars", sceneBars),
            new ThreeEngine("Starfield", sceneStarfield),
            new ThreeEngine("Wave Grid", sceneWaveGrid),
            new ThreeEngine("Particles", sceneParticles),
            new ThreeEngine("Infinity Tunnel", sceneInfinityTunnel),
            new ThreeEngine("Infinity Mirror", sceneInfinityMirror),
            new ThreeEngine("Neon Tunnel", sceneNeonTunnel),
            new ThreeEngine("Twist Tunnel", sceneTwistTunnel),
            new ThreeEngine("Particle Tunnel", sceneParticleTunnel),
            new ThreeEngine("Galaxy", sceneGalaxy),
            new ThreeEngine("Kaleido Rings", sceneKaleidoRings),
            new ThreeEngine("Terrain", sceneTerrain),
            new ThreeEngine("Hex Grid", sceneHexGrid),
            new ThreeEngine("Ribbons", sceneRibbons),
            new ThreeEngine("Mandelbrot", sceneMandelbrot),
            new ThreeEngine("Julia Set", sceneJulia),
            new ThreeEngine("Barnsley Fern", sceneBarnsleyFern),
            new ThreeEngine("Lorenz Attractor", sceneLorenz),
            new ThreeEngine("Sierpinski Carpet", sceneSierpinskiCarpet),
            new ThreeEngine("Emoji Swarm", sceneEmojiSwarm),
            new ThreeEngine("Emoji Orbits", sceneEmojiOrbits),
            new ThreeEngine("Kaleidoscope 6", sceneKaleido(6)),
            new ThreeEngine("Kaleidoscope 8", sceneKaleido(8)),
            new ThreeEngine("Kaleidoscope 12", sceneKaleido(12)),
            new ThreeEngine("Kaleidoscope Spiral", sceneKaleidoSpiral),
            new ThreeEngine("Kaleidoscope Layered", sceneKaleidoLayered),
            new ThreeEngine("Kaleidoscope Zoom", sceneKaleidoZoom)
        ];

        function loadMode(index) {
            if(state.activeVisualizer) state.activeVisualizer.destroy();
            let idx = index;
            if(idx < 0) idx = modes.length - 1;
            if(idx >= modes.length) idx = 0;
            state.currentModeIdx = idx;
            state.activeVisualizer = modes[idx];
            
            // UI Updates
            document.getElementById('mode-title').innerText = state.activeVisualizer.name;
            if(!(state.activeVisualizer && state.activeVisualizer.loadPreset)) {
                document.getElementById('mode-sub').innerText = "3D Interactive";
            }
            
            // Show/Hide Skip Button
            const skipBtn = document.getElementById('btn-skip-preset');
            if(state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') skipBtn.classList.remove('display-none');
            else skipBtn.classList.add('display-none');

            state.activeVisualizer.init();
        }
        
        // Allow opening overlay by clicking the title area
        document.getElementById('mode-info').addEventListener('click', (e) => {
            e.stopPropagation();
            showOverlay();
        });

        // --- BINDINGS ---
        document.getElementById('btn-prev').addEventListener('click', () => { loadMode(state.currentModeIdx - 1); resetIdleTimer(); });
        document.getElementById('btn-next').addEventListener('click', () => { loadMode(state.currentModeIdx + 1); resetIdleTimer(); });
        document.getElementById('btn-radio').addEventListener('click', playRadio);
        document.getElementById('btn-mic').addEventListener('click', useMic);
        document.getElementById('file-input').addEventListener('change', useFile);
        document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
        // WebM toggle and nav
        webmBtn.addEventListener('click', () => {
            if(!webmOn) {
                if(webmList.length === 0) {
                    // Ensure list is loaded then show
                    loadWebmList().finally(() => {
                        if(webmList.length > 0) showWebm();
                        else alert('No WebM files found in webm/.');
                    });
                } else {
                    showWebm();
                }
            } else {
                hideWebm();
            }
        });
        webmBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleWebmSettingsPanel();
        });
        webmPrevBtn.addEventListener('click', () => { prevWebm(); resetIdleTimer(); });
        webmNextBtn.addEventListener('click', () => { nextWebm(); resetIdleTimer(); });
        settingsBtn.addEventListener('click', () => {
            if(settingsPanel.classList.contains('display-none')) {
                settingsPanel.classList.remove('display-none');
                settingsPanel.style.opacity = '1';
                settingsPanel.style.pointerEvents = 'auto';
                scheduleSettingsPanelClose();
            } else {
                if (settingsPanelTimer) { clearTimeout(settingsPanelTimer); settingsPanelTimer = null; }
                settingsPanel.classList.add('display-none');
                settingsPanel.style.opacity = '';
                settingsPanel.style.pointerEvents = '';
            }
        });
        settingsCloseBtn.addEventListener('click', () => { 
            if (settingsPanelTimer) { clearTimeout(settingsPanelTimer); settingsPanelTimer = null; }
            settingsPanel.classList.add('display-none');
            settingsPanel.style.opacity = '';
            settingsPanel.style.pointerEvents = '';
        });
        function scheduleSettingsPanelClose() {
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            settingsPanelTimer = setTimeout(() => {
                settingsPanel.style.opacity = '0';
                settingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { 
                    settingsPanel.classList.add('display-none'); 
                    settingsPanel.style.opacity = '';
                    settingsPanel.style.pointerEvents = '';
                }, 1200);
            }, 30000);
        }
        settingsApplyBtn.addEventListener('click', () => {
            // Read and clamp settings
            const minS = Math.max(3, Math.min(120, Number(inpShuffleMin.value) || 12));
            const maxS = Math.max(5, Math.min(180, Number(inpShuffleMax.value) || 25));
            const trans = Math.max(0, Math.min(10, Number(inpTransition.value) || 2.7));
            const px = Math.max(0.5, Math.min(3, Number(inpPixelRatio.value) || 1));
            visualSettings.shuffleMinSec = minS;
            visualSettings.shuffleMaxSec = maxS;
            visualSettings.transitionSec = trans;
            visualSettings.pixelRatio = px;
            // Apply if active is v2
            if(state.activeVisualizer && state.activeVisualizer instanceof MilkdropEngineV2) {
                state.activeVisualizer.applySettings?.();
            }
        });
        
        // Skip Preset Button Logic
        document.getElementById('btn-skip-preset').addEventListener('click', () => {
            if(state.activeVisualizer && state.activeVisualizer.nextPreset) {
                state.activeVisualizer.nextPreset();
            }
        });

        // --- RADIO: Load stations and UI ---
        async function loadStations() {
            try {
                const resp = await fetch('radio.txt');
                const txt = await resp.text();
                stations.length = 0;
                txt.split('\n').forEach((line) => {
                    const raw = line.trim();
                    if(!raw) return;
                    const parts = raw.split('|');
                    if(parts.length >= 2) {
                        const name = parts[0].trim();
                        const url = parts.slice(1).join('|').trim();
                        stations.push({ name, url });
                    }
                });
                renderStationList();
            } catch(e) {
                console.warn('Failed to load radio.txt', e);
            }
        }

        function renderStationList() {
            radioListEl.innerHTML = '';
            stations.forEach((s, i) => {
                const item = document.createElement('div');
                item.className = 'radio-item';
                item.dataset.index = String(i);
                if(i === currentStationIndex) item.classList.add('active');
                const nameEl = document.createElement('div');
                nameEl.textContent = s.name;
                const goEl = document.createElement('div');
                goEl.textContent = '‚û§';
                item.appendChild(nameEl);
                item.appendChild(goEl);
                item.addEventListener('click', () => {
                    setStation(i);
                });
                radioListEl.appendChild(item);
            });
        }

        function setStation(index) {
            if(index < 0 || index >= stations.length) return;
            currentStationIndex = index;
            const s = stations[index];
            radioInputEl.value = s.url;
            showStationBanner(s.name);
            updateStationActiveHighlight();
            playRadio();
        }

        function updateStationActiveHighlight() {
            const children = Array.from(radioListEl.children);
            children.forEach((el) => {
                const idx = Number(el.dataset.index || -1);
                if(idx === currentStationIndex) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function pickRandomStation() {
            if(stations.length === 0) return;
            let idx = currentStationIndex;
            if(stations.length === 1) idx = 0;
            else {
                while(idx === currentStationIndex) {
                    idx = Math.floor(Math.random() * stations.length);
                }
            }
            setStation(idx);
        }

        function showRadioPanel() { 
            radioPanel.classList.remove('display-none'); 
            radioPanel.style.opacity = '1';
            radioPanel.style.pointerEvents = 'auto';
            scheduleRadioPanelClose();
        }
        function hideRadioPanel() { 
            if (radioPanelTimer) { clearTimeout(radioPanelTimer); radioPanelTimer = null; }
            radioPanel.classList.add('display-none'); 
            radioPanel.style.opacity = '';
            radioPanel.style.pointerEvents = '';
        }
        function toggleRadioPanel() {
            if(radioPanel.classList.contains('display-none')) showRadioPanel();
            else hideRadioPanel();
        }
        function scheduleRadioPanelClose() {
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            radioPanelTimer = setTimeout(() => {
                radioPanel.style.opacity = '0';
                radioPanel.style.pointerEvents = 'none';
                setTimeout(() => { hideRadioPanel(); }, 1200);
            }, 30000);
        }

        function showStationBanner(text) {
            stationBanner.textContent = text || '';
            if(!text) return;
            stationBanner.classList.remove('display-none');
            stationBanner.style.opacity = '1';
        }

        function deriveTitleFromUrl(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch {
                return url;
            }
        }

        // Swap: left-click now opens panel; right-click picks random
        radioQuickBtn.title = "Left-click: choose ‚Ä¢ Right-click: random station";
        radioQuickBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleRadioPanel();
        });
        radioQuickBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pickRandomStation();
            // Keep the radio button visible for 10s after right-click shuffle
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            radioQuickHoldUntil = Date.now() + 10000;
            if (radioQuickHoldTimeout) { clearTimeout(radioQuickHoldTimeout); radioQuickHoldTimeout = null; }
            radioQuickHoldTimeout = setTimeout(() => {
                radioQuickHoldUntil = 0;
                // Only hide if UI is idle (layer opacity is 0)
                if (uiLayer.style.opacity === '0') {
                    radioQuickBtn.style.opacity = '0';
                    radioQuickBtn.style.pointerEvents = 'none';
                }
            }, 10000);
        });
        // Station banner toggles shuffle
        stationBanner.title = "Click: toggle visual shuffle";
        stationBanner.addEventListener('click', (e) => {
            e.stopPropagation();
            setModeShuffle(!modeShuffleOn);
        });
        document.addEventListener('click', (e) => {
            if(!radioPanel.classList.contains('display-none')) {
                if(!radioPanel.contains(e.target) && e.target !== radioQuickBtn) {
                    hideRadioPanel();
                }
            }
        });

        // Drag Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            // Accept only for ProjectM (either version)
            const active = state.activeVisualizer;
            if(!(active instanceof MilkdropEngine) && !(active instanceof MilkdropEngineV2)) {
                return alert("Switch to ProjectM (v1 or v2) first");
            }
            const file = e.dataTransfer.files[0];
            if(!file) return;
            const lower = file.name.toLowerCase();
            if(lower.endsWith('.milk')) {
                alert("Raw .milk files are not directly supported. Please convert to butterchurn JSON first.");
                return;
            }
            const reader = new FileReader();
            reader.onload = (ev) => active.loadCustomMilk?.(ev.target.result);
            reader.readAsText(file);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            } else if (e.key === 's' || e.key === 'S') {
                if (state.activeVisualizer?.nextPreset) {
                    state.activeVisualizer.nextPreset();
                }
            } else if (e.key === 'Escape') {
                stopAllAndShowStart();
            } else if (e.key === 'Arrow Left' || e.key === 'ArrowLeft') {
                if (webmOn) prevWebm();
            } else if (e.key === 'ArrowRight' || e.key === 'Arrow Right') {
                if (webmOn) nextWebm();
            }
        });

        // Bootstrap station list
        loadStations();
        // Preload webm list (best-effort)
        loadWebmList();

        // --- WEBM HELPERS ---
        async function loadWebmList() {
            try {
                // Try a manifest first
                const resp = await fetch('webm/webms.txt', { cache: 'no-store' });
                if(resp.ok) {
                    const txt = await resp.text();
                    const files = txt.split('\n').map(s => s.trim()).filter(Boolean);
                    webmList = files.map(f => f.startsWith('webm/') ? f : `webm/${f}`);
                    webmIndex = 0;
                    return;
                }
            } catch {}
            // Try directory listing parse (best-effort)
            try {
                const dirResp = await fetch('webm/', { cache: 'no-store' });
                if(dirResp.ok) {
                    const html = await dirResp.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const anchors = Array.from(doc.querySelectorAll('a,link'));
                    const found = anchors.map(a => a.getAttribute('href') || '').filter(href => /\.webm(\?.*)?$/i.test(href));
                    if(found.length > 0) {
                        const normalized = found.map(f => f.startsWith('webm/') ? f : `webm/${f.replace(/^\//,'')}`);
                        // Deduplicate
                        webmList = Array.from(new Set(normalized));
                        webmIndex = 0;
                        return;
                    }
                }
            } catch {}
            // Fallback to known files
            const defaults = ['webm/red.webm', 'webm/grn.webm'];
            webmList = defaults;
            webmIndex = 0;
        }

        function showWebm() {
            if(webmList.length === 0) return;
            webmOn = true;
            setWebm(webmIndex);
            webmOverlayEl.classList.remove('display-none');
            webmPrevBtn.classList.remove('display-none');
            webmNextBtn.classList.remove('display-none');
            applyWebmSettings();
        }

        function hideWebm() {
            webmOn = false;
            webmOverlayEl.classList.add('display-none');
            webmPrevBtn.classList.add('display-none');
            webmNextBtn.classList.add('display-none');
            try { webmVideoEl.pause(); } catch {}
            try { webmVideoLeftEl.pause(); } catch {}
            try { webmVideoRightEl.pause(); } catch {}
            webmVideoEl.src = '';
            webmVideoLeftEl.src = '';
            webmVideoRightEl.src = '';
        }

        function setWebm(index) {
            if(webmList.length === 0) return;
            if(index < 0) index = webmList.length - 1;
            if(index >= webmList.length) index = 0;
            webmIndex = index;
            const src = webmList[webmIndex];
            if(webmVideoEl.src.endsWith(src)) return;
            webmVideoEl.src = src;
            webmVideoEl.muted = true;
            webmVideoEl.loop = true;
            webmVideoEl.playsInline = true;
            webmVideoEl.autoplay = true;
            webmVideoEl.play().catch(()=>{ /* ignore */ });
            // mirror to duplicates
            [webmVideoLeftEl, webmVideoRightEl].forEach(v => {
                v.src = src;
                v.muted = true; v.loop = true; v.playsInline = true; v.autoplay = true;
                v.playbackRate = webmSettings.playbackRate;
                v.style.opacity = String(webmSettings.opacity);
                v.play().catch(()=>{});
            });
        }

        function nextWebm() { setWebm(webmIndex + 1); }
        function prevWebm() { setWebm(webmIndex - 1); }
        
        function toggleWebmSettingsPanel() {
            if(webmSettingsPanel.classList.contains('display-none')) {
                webmSettingsPanel.classList.remove('display-none');
                webmSettingsPanel.style.opacity = '1';
                webmSettingsPanel.style.pointerEvents = 'auto';
                scheduleWebmSettingsClose();
                // sync inputs
                inpWebmScale.value = String(webmSettings.scaleVw);
                inpWebmX.value = String(webmSettings.posXvw);
                inpWebmY.value = String(webmSettings.posYvh);
                inpWebmRot.value = String(webmSettings.rotationDeg);
                inpWebmSpeed.value = String(webmSettings.playbackRate);
                inpWebmOpacity.value = String(webmSettings.opacity);
                inpWebmDup.value = String(webmSettings.duplicates);
            } else {
                hideWebmSettingsPanel();
            }
        }
        function hideWebmSettingsPanel() {
            if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
            webmSettingsPanel.classList.add('display-none');
            webmSettingsPanel.style.opacity = '';
            webmSettingsPanel.style.pointerEvents = '';
        }
        function scheduleWebmSettingsClose() {
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            webmSettingsTimer = setTimeout(() => {
                webmSettingsPanel.style.opacity = '0';
                webmSettingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { hideWebmSettingsPanel(); }, 1200);
            }, 30000);
        }
        webmCloseBtn.addEventListener('click', hideWebmSettingsPanel);
        document.getElementById('btn-webm-reset').addEventListener('click', () => {
            webmSettings.scaleVw = 50;
            webmSettings.posXvw = 50;
            webmSettings.posYvh = 50;
            webmSettings.rotationDeg = 0;
            webmSettings.playbackRate = 1.0;
            webmSettings.opacity = 0.82;
            webmSettings.duplicates = 0;
            inpWebmScale.value = '50';
            inpWebmX.value = '50';
            inpWebmY.value = '50';
            inpWebmRot.value = '0';
            inpWebmSpeed.value = '1.0';
            inpWebmOpacity.value = '0.82';
            inpWebmDup.value = '0';
            applyWebmSettings();
        });
        webmApplyBtn.addEventListener('click', () => {
            webmSettings.scaleVw = Number(inpWebmScale.value) || 50;
            webmSettings.posXvw = Number(inpWebmX.value) || 50;
            webmSettings.posYvh = Number(inpWebmY.value) || 50;
            webmSettings.rotationDeg = Number(inpWebmRot.value) || 0;
            webmSettings.playbackRate = Math.max(0.1, Math.min(4, Number(inpWebmSpeed.value) || 1));
            webmSettings.opacity = Math.max(0, Math.min(1, Number(inpWebmOpacity.value) || 1));
            webmSettings.duplicates = Math.max(0, Math.min(2, Math.floor(Number(inpWebmDup.value) || 0)));
            // Force center X when duplicates == 2
            if (webmSettings.duplicates === 2) {
                webmSettings.posXvw = 50;
                inpWebmX.value = '50';
            }
            applyWebmSettings();
            scheduleWebmSettingsClose();
        });
        // Live-change on input (with special-case for duplicates)
        [inpWebmScale, inpWebmX, inpWebmY, inpWebmRot, inpWebmSpeed, inpWebmOpacity, inpWebmDup].forEach(el => {
            el.addEventListener('input', () => {
                if (el === inpWebmDup) {
                    const dupVal = Math.max(0, Math.min(2, Math.floor(Number(inpWebmDup.value) || 0)));
                    if (dupVal === 2) {
                        // Force center X when duplicates == 2
                        webmSettings.posXvw = 50;
                        inpWebmX.value = '50';
                    }
                }
                webmApplyBtn.click();
            });
        });
        function applyWebmSettings() {
            // central
            webmVideoEl.style.width = `${webmSettings.scaleVw}vw`;
            const centralized = (webmSettings.duplicates === 2);
            if (centralized) {
                // Force X to center both in settings and UI
                webmSettings.posXvw = 50;
                if (inpWebmX) inpWebmX.value = '50';
            }
            const leftVw = centralized ? 50 : webmSettings.posXvw;
            webmOverlayEl.style.left = `${leftVw}vw`;
            webmOverlayEl.style.top = `${webmSettings.posYvh}vh`;
            webmOverlayEl.style.transform = `translate(-50%, -50%)`;
            webmVideoEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
            webmVideoEl.style.opacity = String(webmSettings.opacity);
            try { webmVideoEl.playbackRate = webmSettings.playbackRate; } catch {}
            // duplicates
            const dup = webmSettings.duplicates;
            const offsetVw = webmSettings.scaleVw * 0.6;
            if(dup >= 1) {
                webmVideoLeftEl.classList.remove('display-none');
                webmVideoLeftEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoLeftEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoLeftEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoLeftEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoLeftEl.classList.add('display-none');
            }
            if(dup >= 2) {
                webmVideoRightEl.classList.remove('display-none');
                webmVideoRightEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoRightEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoRightEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoRightEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoRightEl.classList.add('display-none');
            }
            // Position duplicates relative to overlay center using absolute positioning containers
            // We'll position by setting margins on the left/right elements
            webmVideoEl.style.display = 'block';
            webmVideoLeftEl.style.display = dup >= 1 ? 'block' : 'none';
            webmVideoRightEl.style.display = dup >= 2 ? 'block' : 'none';
            // Reset any existing margins
            webmVideoEl.style.margin = '0';
            webmVideoLeftEl.style.margin = '0';
            webmVideoRightEl.style.margin = '0';
            // Arrange: left video shifted left by offset, right shifted right by offset, overlapping allowed
            webmVideoLeftEl.style.position = 'absolute';
            webmVideoRightEl.style.position = 'absolute';
            webmVideoEl.style.position = 'relative';
            webmVideoLeftEl.style.left = `-${offsetVw}vw`;
            webmVideoLeftEl.style.top = `0`;
            webmVideoRightEl.style.left = `${offsetVw}vw`;
            webmVideoRightEl.style.top = `0`;
        }
        // --- MODE SHUFFLE ---
        function setModeShuffle(on) {
            modeShuffleOn = on;
            if(modeShuffleTimer) { clearTimeout(modeShuffleTimer); modeShuffleTimer = null; }
            if(modeShuffleOn) {
                scheduleModeShuffle();
                stationBanner.classList.add('shuffle-on');
            }
            if(!modeShuffleOn) {
                stationBanner.classList.remove('shuffle-on');
            }
        }
        function scheduleModeShuffle() {
            if(!modeShuffleOn) return;
            modeShuffleTimer = setTimeout(() => {
                loadMode(state.currentModeIdx + 1);
                scheduleModeShuffle();
            }, 30000);
        }

    </script>
</body>
</html>