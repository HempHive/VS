<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OmnI: Tomorrow</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon"/>
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <style>
		body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Quicksand', sans-serif; color: white; cursor: none; }
		/* Ensure Quicksand applies across the UI */
		*, *::before, *::after { font-family: 'Quicksand', sans-serif !important; }
        
        /* Layout */
        #canvas-container { 
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; 
            overflow: hidden;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
		/* UI Overlays */
        #overlay {
			position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; backdrop-filter: blur(10px);
            cursor: default;
        }
		/* Lighter overlay when background GIF is present so it doesn't look too dark */
		#overlay.bg-lite {
			background: rgba(0,0,0,0.4);
		}
		/* Disable backdrop blur when tiling pta.gif to keep it crisp */
		#overlay.no-blur {
			backdrop-filter: none !important;
			-webkit-backdrop-filter: none !important;
		}
		/* Overlay border glow (random color set via --glowColor) */
		#overlay.glow-on {
			box-shadow: inset 0 0 60px var(--glowColor, #66ccff), 0 0 120px var(--glowColor, #66ccff);
			animation: borderGlow 2400ms ease-in-out infinite alternate;
			position: relative; /* allow border frame layering */
			border-radius: 70px; /* more rounded corners as requested */
		}
		/* Volume slider (top-center, fades like other overlays) */
		#volume-slider-container {
			position: fixed; top: 14px; left: 50%; transform: translateX(-50%);
			width: 80vw; height: 32px;
			display: none; /* hidden on start overlay; shown after playback starts */
			align-items: center; justify-content: center; z-index: 80;
			pointer-events: auto; opacity: 1; transition: opacity 1s ease-in-out;
		}
		#volume-slider {
			-webkit-appearance: none; appearance: none; width: 100%; height: 14px;
			background: rgba(255,255,255,0.08); /* almost transparent track */
			cursor: pointer; border-radius: 7px;
		}
		/* Thumb */
		#volume-slider::-webkit-slider-thumb {
			-webkit-appearance: none; appearance: none;
			width: 56px; height: 56px; border-radius: 50%;
			background: transparent url('vol.png') center center / 100% 100% no-repeat;
			border: none;
			margin-top: -21px;
		}
		#volume-slider::-moz-range-thumb {
			width: 56px; height: 56px; border-radius: 50%;
			background: transparent url('vol.png') center center / 100% 100% no-repeat;
			border: none;
		}
		/* Full-screen rounded border frame over everything */
		#border-frame {
			/* Offset by half the stroke so it extends inside and outside evenly */
			/* Push slightly further to ensure full edge coverage */
			position: fixed; top: -22.5px; left: -22.5px; right: -22.5px; bottom: -22.5px;
			/* Use a repeating GIF around the edge instead of solid black */
			border: 45px solid transparent;
			border-image-source: url('tap.gif');
			border-image-slice: 45;
			border-image-repeat: round;
			border-radius: 55px;
			/* variables for curved dissolve */
			--frameOuter: 55px;       /* matches border-radius */
			--frameStroke: 45px;      /* matches border width */
			--dissolve: 10px;         /* inner fade thickness */
			--innerR: calc(var(--frameOuter) - var(--frameStroke)); /* inner corner radius */
			--overlap: 10px;          /* push dissolve outward by a few more pixels */
			--cornerSpan: calc(var(--innerR) + var(--dissolve) + var(--overlap)); /* span consumed by corner */
			box-sizing: border-box;
			pointer-events: none;
			z-index: 100000; /* ensure frame sits above overlay glow */
			opacity: 0;
			transition: opacity 600ms ease;
		}
		#border-frame.visible { opacity: 1; }
		/* Curved inner dissolve at the inside edge of the frame */
		#border-frame::after {
			content: none; /* remove dissolve overlay */
		}
		/* Corner seam cover: solid black caps to guarantee no color gap shows */
		#border-frame::before {
			content: none; /* remove seam caps when dissolve is disabled */
		}
		@keyframes borderGlow {
			0% { box-shadow: inset 0 0 24px var(--glowColor, #66ccff), 0 0 40px var(--glowColor, #66ccff); }
			100% { box-shadow: inset 0 0 90px var(--glowColor, #66ccff), 0 0 160px var(--glowColor, #66ccff); }
		}
		/* OMNI logo shimmer */
		#logo-omni {
			color: transparent !important; /* ensure background-clip shows through */
			position: relative; display: inline-block;
			font-weight: 700;
			letter-spacing: 10px;
			text-transform: uppercase;
			margin-bottom: 30px;
			font-size: clamp(48px, 9vw, 140px);
			text-shadow: 0 0 20px rgba(255,255,255,0.15), 0 0 24px var(--glowColor, rgba(102,204,255,0.6)), 0 0 48px var(--glowColor, rgba(102,204,255,0.35));
		}
		/* Per-letter pattern fill */
		#logo-omni .logo-letter {
			display: inline-block;
			color: transparent;
			-webkit-text-fill-color: transparent;
			-webkit-background-clip: text;
			background-clip: text;
			background-image: url('pat.gif');
			background-repeat: no-repeat; /* reuse but do not tile */
			background-position: center center;
			background-size: cover; /* fill the glyph area */
		}
		#logo-omni.logo-animate {
			animation: omniShimmer 1400ms ease forwards;
		}
		/* Persistent glow pulse around OMNI */
		#logo-omni.logo-glow {
			animation: logoGlow 2400ms ease-in-out infinite alternate;
		}
		@keyframes logoGlow {
			0% { text-shadow: 0 0 3px rgba(255,255,255,0.2), 0 0 8px var(--glowColor, #66ccff), 0 0 16px var(--glowColor, #66ccff); }
			100% { text-shadow: 0 0 16px rgba(255,255,255,0.4), 0 0 36px var(--glowColor, #66ccff), 0 0 76px var(--glowColor, #66ccff); }
		}
		@keyframes omniShimmer {
			0% { opacity: 0; transform: translateY(8px) scale(0.98); color: var(--omniColor, #66ccff); text-shadow: 0 0 0 var(--omniColor, #66ccff); }
			35% { opacity: 1; transform: translateY(0) scale(1.0); color: var(--omniColor, #66ccff); text-shadow: 0 0 16px var(--omniColor, #66ccff), 0 0 28px var(--omniColor, #66ccff); }
			70% { color: #dfefff; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
			100% { color: #ffffff; text-shadow: 0 0 0 rgba(255,255,255,0); }
		}
        /* Digital transition when starting visuals */
        #overlay.digital-out {
            animation: digitalOut 520ms ease forwards;
        }
        @keyframes digitalOut {
            0% { opacity: 1; transform: none; filter: none; }
            15% { transform: translateY(-2px) skewX(-2deg); filter: contrast(120%) saturate(110%); }
            30% { transform: translateY(1px) skewX(2deg); filter: contrast(140%) saturate(120%); }
            55% { opacity: 0.6; transform: translateY(-1px) skewX(-1deg); }
            75% { opacity: 0.25; transform: translateY(0) skewX(0deg); filter: contrast(160%) saturate(130%); }
            100% { opacity: 0; transform: none; filter: none; }
        }

        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%;
            min-height: clamp(88px, 12vh, 160px);
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 clamp(12px, 3vw, 40px); box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,1), transparent);
            z-index: 50;
            transition: opacity 1s ease-in-out;
            opacity: 1;
        }

        /* Center Control Group */
        .center-controls {
            display: flex; align-items: center; justify-content: center;
            gap: clamp(8px, 2vw, 24px); 
            flex-wrap: nowrap;
            flex: 1 1 auto;
            min-width: 0; /* allow shrinking */
        }

        /* Interactive Elements */
        .interactive { pointer-events: auto; cursor: pointer; }

        h1 { font-weight: 200; letter-spacing: 8px; text-transform: uppercase; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.2); text-align: center; }

        .control-group {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;
        }

        .btn-main {
            padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 13px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            border-radius: 4px; min-width: 150px;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); border-color: #fff; }

        /* Secondary Icon Buttons (Fullscreen / Skip) */
        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            font-size: clamp(18px, 2.5vw, 28px); padding: 10px; transition: 0.2s; display: flex; align-items: center;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.2); text-shadow: 0 0 10px #fff; }
        /* Precise hitbox for the WebM close (‚úï) button */
        #btn-webm-close {
            width: 32px; height: 32px;
            display: inline-flex; align-items: center; justify-content: center;
            padding: 0; line-height: 1; font-size: 20px;
            cursor: pointer; user-select: none;
        }

		.radio-input {
			padding: 15px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #0f0; 
			width: 320px;
		}

        /* Navigation Arrows */
        .nav-btn {
            font-size: clamp(36px, 6vw, 64px); opacity: 0.3; transition: 0.3s; user-select: none; padding: clamp(10px, 2vh, 20px);
        }
        .nav-btn:hover { opacity: 1; text-shadow: 0 0 15px #fff; transform: scale(1.1); }

        #mode-info { 
            text-align: center; 
            min-width: 0; 
            white-space: nowrap; 
            overflow: hidden; 
            text-overflow: ellipsis; 
            flex: 1 1 auto; 
        }
        #mode-title { 
            font-size: clamp(16px, 2vw, 26px); 
            font-weight: 600; 
            display: inline; 
            letter-spacing: 2px; 
            margin-right: 8px; 
            text-shadow: 0 0 10px rgba(0,0,0,0.5); 
        }
		#mode-sub { 
			font-size: clamp(10px, 1.2vw, 14px); 
			color: #aaa; 
			letter-spacing: 1px; 
			display: inline; 
		}

        .hidden { opacity: 0 !important; pointer-events: none; }
        .display-none { display: none !important; }
        
		#loading-status { color: #0ff; margin-top: 20px; font-size: 12px; height: 20px; }

        /* Quick Radio Button (Top-right) */
        #radio-quick {
            position: absolute; 
            top: 14px; 
            right: 14px;
            z-index: 80;
            width: 80px; height: 80px;
            background-color: transparent;
            background-image: url('radio.png');
            background-repeat: no-repeat;
            background-position: center center;
            background-size: contain;
            border: none;
            cursor: pointer;
            user-select: none;
            transition: opacity 1s ease-in-out;
        }
        #radio-quick:hover {
            filter: brightness(1.15);
        }
		/* Hide the radio quick button whenever the start overlay is visible */
		#overlay:not(.hidden) ~ #radio-quick { 
			display: none !important; 
		}
		/* Top bar container to align shuffle, volume, and radio buttons */
		#top-bar {
			position: fixed; top: 10px; left: 14px; right: 14px;
			display: none; z-index: 80;
			display: flex; align-items: center; gap: 12px;
			pointer-events: auto; opacity: 1; transition: opacity 1s ease-in-out;
		}
		/* Normalize children inside the top bar */
		#top-bar #shuffle-toggle,
		#top-bar #radio-quick {
			position: static !important;
			margin: 0;
			border: none;
			box-shadow: none;
		}
		/* Scale down buttons within the top bar to prevent overlap */
		#top-bar #shuffle-toggle {
			width: 40px !important; height: 40px !important;
			font-size: 24px !important;
		}
		#top-bar #radio-quick {
			width: 40px !important; height: 40px !important;
			background-size: contain !important;
		}
		#top-bar #volume-slider-container {
			position: static; width: auto; height: 64px;
			flex: 1 1 auto; display: flex;
			min-width: 360px; /* ensure space between buttons */
		}
        
        /* Shuffle Toggle (Top-left) */
        #shuffle-toggle {
            position: absolute; 
            top: clamp(24px, 12vh, 140px); 
            left: 14px;
            z-index: 80;
            width: 80px; height: 80px;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5);
            color: rgba(255,255,255,0.9);
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 6px;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(6px);
            transition: opacity 1s ease-in-out, filter 0.2s;
            font-size: 36px;
        }
        #shuffle-toggle:hover { filter: brightness(1.15); }
        #shuffle-toggle.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }

        /* Radio Panel */
        #radio-panel {
            position: absolute; top: 54px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 1s ease-in-out;
        }
        #radio-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #radio-list { padding: 8px; }
        .radio-item {
            padding: 10px 12px; margin: 6px 0; border-radius: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.12);
            cursor: pointer; transition: 0.15s;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 13px;
        }
        .radio-item:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.08) inset;
        }
        .radio-item.active {
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212,175,55,0.3) inset, 0 0 16px rgba(212,175,55,0.15);
            background: rgba(212,175,55,0.08);
        }

        /* Station Banner (Top-left) */
        #station-banner {
            position: absolute; top: 14px; left: 14px;
            z-index: 80;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-size: 18px;
            letter-spacing: 0.5px;
            pointer-events: auto;
            transition: opacity 1s ease-in-out;
            max-width: min(60vw, 720px);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        #station-banner.shuffle-on {
            border: 1px solid rgba(212,175,55,0.6);
            box-shadow: 0 0 16px rgba(212,175,55,0.25);
        }
        
        /* Settings Panel */
        #settings-panel {
            position: absolute; bottom: 160px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #settings-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #settings-content { padding: 12px; }
        .settings-row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 10px 0; }
        .settings-row label { font-size: 12px; color: #ccc; }
        .settings-row input[type="number"] { width: 96px; padding: 6px 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.15); color: #fff; border-radius: 4px; }
        .settings-row input[type="range"] { flex: 1; }
        
        /* Unified slider styling (transparent tracks) */
        #settings-panel input[type="range"],
        #webm-settings-panel input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 16px;
            background: transparent;
            cursor: pointer;
        }
        /* WebKit track */
        #settings-panel input[type="range"]::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]::-webkit-slider-runnable-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* WebKit thumb */
        #settings-panel input[type="range"]::-webkit-slider-thumb,
        #webm-settings-panel input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            margin-top: -4px;
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Firefox track */
        #settings-panel input[type="range"]::-moz-range-track,
        #webm-settings-panel input[type="range"]::-moz-range-track {
            height: 6px;
            background: rgba(255,255,255,0.14);
            border-radius: 6px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08);
        }
        /* Firefox progress (filled portion) */
        #settings-panel input[type="range"]::-moz-range-progress,
        #webm-settings-panel input[type="range"]::-moz-range-progress {
            height: 6px;
            background: rgba(212,175,55,0.28); /* subtle gold on filled part */
            border-radius: 6px 0 0 6px;
        }
        /* Firefox thumb */
        #settings-panel input[type="range"]::-moz-range-thumb,
        #webm-settings-panel input[type="range"]::-moz-range-thumb {
            width: 14px; height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.85);
            border: 1px solid rgba(255,255,255,0.35);
            box-shadow: 0 0 8px rgba(0,0,0,0.25);
        }
        /* Hover/active states to increase opacity */
        #settings-panel input[type="range"]:hover::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:hover::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-webkit-slider-runnable-track,
        #webm-settings-panel input[type="range"]:active::-webkit-slider-runnable-track {
            background: rgba(255,255,255,0.28);
        }
        #settings-panel input[type="range"]:hover::-moz-range-track,
        #webm-settings-panel input[type="range"]:hover::-moz-range-track {
            background: rgba(255,255,255,0.2);
        }
        #settings-panel input[type="range"]:active::-moz-range-track,
        #webm-settings-panel input[type="range"]:active::-moz-range-track {
            background: rgba(255,255,255,0.28);
        }
        .settings-note { font-size: 11px; color: #8aa; margin-top: 8px; line-height: 1.35; }
        .settings-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 12px; }
        .btn-small {
            padding: 8px 12px; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.08); color: #fff;
            font-size: 12px; letter-spacing: 1px; border-radius: 4px;
        }
        .btn-small:hover { background: #fff; color: #000; }
        
        /* WebM Overlay */
        #webm-overlay {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 45;
            pointer-events: none;
        }
        #webm-overlay video {
            width: 50vw; height: auto; display: block;
            pointer-events: none;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }
        .webm-nav {
            position: absolute; top: 50%; transform: translateY(-50%);
            z-index: 60;
            font-size: 56px; color: rgba(255,255,255,0.7);
            background: transparent; border: none; padding: 12px; cursor: pointer;
            transition: opacity 1s ease-in-out, transform 0.2s;
            opacity: 1;
        }
        .webm-nav:hover { color: #fff; text-shadow: 0 0 15px #fff; transform: translateY(-50%) scale(1.1); }
        #webm-prev { left: 14px; }
        #webm-next { right: 14px; }
        
        /* WebM Settings Panel (mirror of settings-panel) */
        #webm-settings-panel {
            position: absolute; bottom: 160px; left: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 0.3s ease-in-out;
        }
        #webm-settings-panel h3 {
            margin: 0; font-weight: 500; font-size: 14px;
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #webm-settings-panel .panel-head {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.12);
        }
        #webm-settings-content { padding: 12px; }
        .settings-row input[type="range"] { flex: 1; }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "butterchurn": "https://esm.sh/butterchurn@2.6.0",
                "butterchurn-presets": "https://esm.sh/butterchurn-presets@2.4.7",
                "lodash": "https://esm.sh/lodash@4.17.21"
            }
        }
    </script>
</head>
<body>

    <!-- START SCREEN -->
	<div id="overlay">
		<h1 id="logo-omni" data-text="OMNI"><span class="logo-letter">O</span><span class="logo-letter">M</span><span class="logo-letter">N</span><span class="logo-letter">I</span></h1>
        
        <div class="control-group">
            <!-- DEFAULT RADIO URL: BigFM Tomorrowland -->
            <input type="text" id="radio-url" class="radio-input interactive" value="https://stream.bigfm.de/tomorrowland/mp3-128/" placeholder="Paste Stream URL">
            <button class="btn-main interactive" id="btn-radio">‚ñ∂ Start Radio</button>
        </div>

        <div class="control-group">
			<button class="btn-main interactive" id="btn-mic">USE MIC / MIDI</button>
			<button class="btn-main interactive" id="btn-file" onclick="document.getElementById('file-input').click()">LOAD LOCAL AUDIO</button>
            <input type="file" id="file-input" accept="audio/*" style="display:none">
        </div>

        <div id="loading-status">Select a source to begin</div>
    </div>

    <!-- HUD (Fades out when idle) -->
    <div id="ui-layer" class="hidden">
        <div class="nav-btn interactive" id="btn-prev">‚ùÆ</div>

        <div class="center-controls">
            <!-- SKIP PRESET BUTTON (Only for ProjectM) -->
            <button class="icon-btn interactive display-none" id="btn-skip-preset" title="Next Visual Preset">‚è≠</button>
            <!-- WEBM TOGGLE -->
            <button class="icon-btn interactive" id="btn-webm" title="Toggle WebM Overlay">ü™©</button>

            <!-- TITLE INFO -->
            <div id="mode-info">
                <span id="mode-title">INIT</span>
                <span id="mode-sub">Engine Ready</span>
            </div>

            <!-- SETTINGS BUTTON -->
            <button class="icon-btn interactive" id="btn-settings" title="Visualizer Settings">‚öôÔ∏è</button>
            
            <!-- FULLSCREEN BUTTON -->
            <button class="icon-btn interactive" id="btn-fullscreen" title="Toggle Fullscreen">‚õ∂</button>
        </div>

        <div class="nav-btn interactive" id="btn-next">‚ùØ</div>
    </div>

    <div id="canvas-container"></div>
    <audio id="radio-element" crossorigin="anonymous"></audio>
	<!-- Top bar aligns shuffle, volume, and radio controls -->
	<div id="top-bar" class="display-none"></div>
	<!-- Volume Slider -->
	<div id="volume-slider-container" class="interactive">
		<input id="volume-slider" type="range" min="0" max="1" step="0.01" value="0.5">
	</div>
    <!-- Quick Radio Button and Panel -->
    <div id="radio-quick" class="interactive" role="button" aria-label="Radio control" title="Left-click: random station ‚Ä¢ Right-click: choose"></div>
    <div id="radio-panel" class="display-none">
        <h3>Radio Stations</h3>
        <div id="radio-list"></div>
    </div>
    <div id="station-banner" class="display-none"></div>
    
    <!-- WebM Overlay + Nav -->
    <div id="webm-overlay" class="display-none">
        <video id="webm-video" muted loop playsinline></video>
        <video id="webm-video-left" muted loop playsinline class="display-none"></video>
        <video id="webm-video-right" muted loop playsinline class="display-none"></video>
    </div>
    <button id="webm-prev" class="webm-nav display-none" title="Previous video">‚ùÆ</button>
    <button id="webm-next" class="webm-nav display-none" title="Next video">‚ùØ</button>
    
    <!-- Settings Panel -->
    <div id="settings-panel" class="display-none">
        <h3>Visualizer Settings</h3>
        <div id="settings-content">
            <div class="settings-row">
                <label for="inp-shuffle-min">Shuffle min (s)</label>
                <input id="inp-shuffle-min" type="range" min="3" max="120" step="1" value="30">
            </div>
            <div class="settings-row">
                <label for="inp-shuffle-max">Shuffle max (s)</label>
                <input id="inp-shuffle-max" type="range" min="5" max="180" step="1" value="60">
            </div>
            <div class="settings-row">
                <label for="inp-transition">Transition (s)</label>
                <input id="inp-transition" type="range" min="0" max="10" step="0.1" value="2.7">
            </div>
            <div class="settings-row">
                <label for="inp-pixelratio">Pixel Ratio</label>
                <input id="inp-pixelratio" type="range" min="0.5" max="3" step="0.1" value="1">
            </div>
            <div class="settings-note">Settings apply to ProjectM v2. Shuffle times are randomized between min and max. Transition affects preset morph duration. Pixel ratio applies on next init.</div>
            <div class="settings-actions">
                <button class="btn-small" id="btn-settings-apply">Apply</button>
                <button class="btn-small" id="btn-settings-close">Close</button>
            </div>
        </div>
    </div>
    
    <!-- WebM Settings Panel -->
    <div id="webm-settings-panel" class="display-none">
        <div class="panel-head">
            <h3>AVATAR SETTINGS</h3>
            <div style="display:flex; gap:8px; align-items:center">
                <button class="btn-small" id="btn-webm-auto" title="Toggle random WebM (30-60s)">Auto: Off</button>
                <button class="btn-small" id="btn-webm-reset" title="Reset to defaults">‚éã</button>
                <button class="icon-btn interactive" id="btn-webm-close" title="Close" aria-label="Close" onclick="hideWebmSettingsPanel && hideWebmSettingsPanel()">‚úï</button>
            </div>
        </div>
        <div id="webm-settings-content">
            <div class="settings-row">
                <label for="inp-webm-scale">Size (vw)</label>
                <input id="inp-webm-scale" type="range" min="10" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-x">X (vw)</label>
                <input id="inp-webm-x" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-y">Y (vh)</label>
                <input id="inp-webm-y" type="range" min="0" max="100" step="1" value="50">
            </div>
            <div class="settings-row">
                <label for="inp-webm-rot">Rotate (deg)</label>
                <input id="inp-webm-rot" type="range" min="-180" max="180" step="1" value="0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-speed">Speed</label>
                <input id="inp-webm-speed" type="range" min="0.1" max="4" step="0.1" value="1.0">
            </div>
            <div class="settings-row">
                <label for="inp-webm-opacity">Opacity</label>
                <input id="inp-webm-opacity" type="range" min="0" max="1" step="0.01" value="0.82">
            </div>
            <div class="settings-row">
                <label for="inp-webm-dup">Duplicates (0-2)</label>
                <input id="inp-webm-dup" type="range" min="0" max="2" step="1" value="0">
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        import butterchurn from 'butterchurn';
        import butterchurnPresets from 'butterchurn-presets';

        // --- GLOBAL STATE ---
        const state = {
            audioCtx: null,
            sourceNode: null,
            analyserNode: null,
            isPlaying: false,
            currentModeIdx: 0,
            activeVisualizer: null,
            idleTimer: null,
            mediaStream: null
        };

        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('loading-status');
        const uiLayer = document.getElementById('ui-layer');
        const radioQuickBtn = document.getElementById('radio-quick');
        const radioPanel = document.getElementById('radio-panel');
        const radioListEl = document.getElementById('radio-list');
        const radioInputEl = document.getElementById('radio-url');
        const audioEl = document.getElementById('radio-element');
        const stationBanner = document.getElementById('station-banner');
        const settingsPanel = document.getElementById('settings-panel');
        const settingsBtn = document.getElementById('btn-settings');
        const settingsApplyBtn = document.getElementById('btn-settings-apply');
        const settingsCloseBtn = document.getElementById('btn-settings-close');
        const inpShuffleMin = document.getElementById('inp-shuffle-min');
        const inpShuffleMax = document.getElementById('inp-shuffle-max');
        const inpTransition = document.getElementById('inp-transition');
        const inpPixelRatio = document.getElementById('inp-pixelratio');
        const webmOverlayEl = document.getElementById('webm-overlay');
        const webmVideoEl = document.getElementById('webm-video');
        const webmVideoLeftEl = document.getElementById('webm-video-left');
        const webmVideoRightEl = document.getElementById('webm-video-right');
        const webmBtn = document.getElementById('btn-webm');
        const webmPrevBtn = document.getElementById('webm-prev');
        const webmNextBtn = document.getElementById('webm-next');
        const webmSettingsPanel = document.getElementById('webm-settings-panel');
        const webmCloseBtn = document.getElementById('btn-webm-close');
        const inpWebmScale = document.getElementById('inp-webm-scale');
        const inpWebmX = document.getElementById('inp-webm-x');
        const inpWebmY = document.getElementById('inp-webm-y');
        const inpWebmRot = document.getElementById('inp-webm-rot');
        const inpWebmSpeed = document.getElementById('inp-webm-speed');
        const inpWebmOpacity = document.getElementById('inp-webm-opacity');
        const inpWebmDup = document.getElementById('inp-webm-dup');
        const stations = [];
        // Volume slider
        const volumeSlider = document.getElementById('volume-slider');
        const topBar = document.getElementById('top-bar');
        const shuffleToggle = document.getElementById('shuffle-toggle');
        let currentStationIndex = -1;
        let panelIdleTimer = null;
        let webmList = [];
        let webmIndex = 0;
        let webmOn = false;
        let radioPanelTimer = null;
        let settingsPanelTimer = null;
        let webmSettingsTimer = null;
        let stationBannerTimer = null;
        // Hold the radio button visible after right-click random selection
        let radioQuickHoldUntil = 0;
        let radioQuickHoldTimeout = null;
        const webmSettings = {
            scaleVw: 50,
            posXvw: 50,
            posYvh: 50,
            rotationDeg: 0,
            playbackRate: 1.0,
            opacity: 0.82,
            duplicates: 0
        };
        // Radio retry policy
        let radioRetryAttempts = 0;
        const MAX_RADIO_RETRIES = 6;
        // WebM auto-random toggle
        let webmAutoOn = false;
        let webmAutoTimer = null;
		// Bottom text color history (avoid immediate repeats)
		let recentBottomColors = [];
		// Overlay glow color cycler
		let overlayGlowCycleCount = 0;
		let overlayGlowListenerBound = false;
		let overlayGlowColorTimer = null;
		const overlayGlowDurationMs = 2400; // must match CSS animation duration
		function randomHexColor() {
			return '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
		}
		// Typed status text effect
		let statusTypeTimer = null;
		function typeStatus(text) {
			const el = document.getElementById('loading-status');
			if (!el) return;
			if (statusTypeTimer) { try { clearTimeout(statusTypeTimer); } catch(e) {} statusTypeTimer = null; }
			const full = String(text || '');
			el.innerText = '';
			let i = 0;
			const step = () => {
				el.innerText = full.slice(0, i);
				i++;
				if (i <= full.length) {
					statusTypeTimer = setTimeout(step, 60);
				}
			};
			step();
		}
		function setBottomTextRandomColor() {
			const titleEl = document.getElementById('mode-title');
			const subEl = document.getElementById('mode-sub');
			if(!titleEl && !subEl) return;
			let hex = '#ffffff';
			let attempts = 0;
			do {
				hex = '#' + Math.floor(Math.random()*0xFFFFFF).toString(16).padStart(6,'0');
				attempts++;
			} while (recentBottomColors.includes(hex) && attempts < 10);
			if (titleEl) titleEl.style.color = hex;
			if (subEl) subEl.style.color = hex;
			recentBottomColors.push(hex);
			if (recentBottomColors.length > 16) recentBottomColors.shift();
		}
        let modeShuffleOn = false;
        let modeShuffleTimer = null;
        
        // Settings state (for ProjectM v2)
        const visualSettings = {
            shuffleMinSec: 30,
            shuffleMaxSec: 60,
            transitionSec: 2.7,
            pixelRatio: 1
        };

        // --- UI UTILS ---
        function resetIdleTimer() {
            uiLayer.style.opacity = '1';
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            // Show volume slider on interaction
            const vs = document.getElementById('volume-slider-container');
            if (vs && state.isPlaying) { vs.style.opacity = '1'; vs.style.pointerEvents = 'auto'; }
            // Show top bar on interaction
            if (topBar && state.isPlaying) { topBar.style.opacity = '1'; topBar.style.pointerEvents = 'auto'; }
            if(!stationBanner.classList.contains('display-none')) {
                stationBanner.style.opacity = '1';
                stationBanner.style.pointerEvents = 'auto';
            }
            if(!radioPanel.classList.contains('display-none')) {
                radioPanel.style.opacity = '1';
                radioPanel.style.pointerEvents = 'auto';
            }
            // Show webm nav when overlay is active
            if(webmOn && !webmOverlayEl.classList.contains('display-none')) {
                webmPrevBtn.style.opacity = '1';
                webmNextBtn.style.opacity = '1';
                webmPrevBtn.style.pointerEvents = 'auto';
                webmNextBtn.style.pointerEvents = 'auto';
            }
            document.body.style.cursor = 'default';
            if (state.idleTimer) clearTimeout(state.idleTimer);
            if (panelIdleTimer) clearTimeout(panelIdleTimer);
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            if(state.isPlaying) {
                state.idleTimer = setTimeout(() => {
                    uiLayer.style.opacity = '0';
                    // Honor hold window after right-click
                    if (Date.now() >= radioQuickHoldUntil) {
                        radioQuickBtn.style.opacity = '0';
                        radioQuickBtn.style.pointerEvents = 'none';
                    }
                    // Hide volume slider on idle
                    const vs = document.getElementById('volume-slider-container');
                    if (vs) { vs.style.opacity = '0'; vs.style.pointerEvents = 'none'; }
                    // Hide top bar on idle
                    if (topBar) { topBar.style.opacity = '0'; topBar.style.pointerEvents = 'none'; }
                    if(!stationBanner.classList.contains('display-none')) {
                        stationBanner.style.opacity = '0';
                        stationBanner.style.pointerEvents = 'none';
                    }
                    // Hide webm nav
                    webmPrevBtn.style.opacity = '0';
                    webmNextBtn.style.opacity = '0';
                    webmPrevBtn.style.pointerEvents = 'none';
                    webmNextBtn.style.pointerEvents = 'none';
                    document.body.style.cursor = 'none';
                }, 3000);
                // Panels fade out and close after 30s if open
                if(!radioPanel.classList.contains('display-none')) scheduleRadioPanelClose();
                if(!settingsPanel.classList.contains('display-none')) scheduleSettingsPanelClose();
                if(!webmSettingsPanel.classList.contains('display-none')) scheduleWebmSettingsClose();
            }
        }
        window.addEventListener('mousemove', resetIdleTimer);
        window.addEventListener('click', resetIdleTimer);

        // Updated Fullscreen Logic with forced Resize Trigger
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => forceResize(), 200);
                }).catch(err => console.log(err));
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().then(() => {
                        setTimeout(() => forceResize(), 200);
                    });
                }
            }
        }

        function forceResize() {
            if(state.activeVisualizer && state.activeVisualizer.onResize) {
                state.activeVisualizer.onResize();
            }
        }
        
        // WebM speed helpers
        function setWebmSpeed(newRate) {
            const clamped = Math.max(0.1, Math.min(4, Number(newRate) || 1));
            webmSettings.playbackRate = clamped;
            if (typeof inpWebmSpeed !== 'undefined' && inpWebmSpeed) {
                inpWebmSpeed.value = String(clamped);
            }
            applyWebmSettings();
        }
        function adjustWebmSpeed(delta) {
            setWebmSpeed((Number(webmSettings.playbackRate) || 1) + (delta || 0));
        }
        // WebM position/size/opacity helpers
        function adjustWebmPosition(dxVw, dyVh) {
            if (!webmOn) return;
            var x = Number(webmSettings.posXvw) || 50;
            var y = Number(webmSettings.posYvh) || 50;
            var nx = Math.max(0, Math.min(100, x + (dxVw || 0)));
            var ny = Math.max(0, Math.min(100, y + (dyVh || 0)));
            webmSettings.posXvw = nx;
            webmSettings.posYvh = ny;
            if (typeof inpWebmX !== 'undefined' && inpWebmX) inpWebmX.value = String(nx);
            if (typeof inpWebmY !== 'undefined' && inpWebmY) inpWebmY.value = String(ny);
            applyWebmSettings();
        }
        function adjustWebmScale(deltaVw) {
            if (!webmOn) return;
            var min = Number((typeof inpWebmScale !== 'undefined' && inpWebmScale && inpWebmScale.min) ? inpWebmScale.min : 10);
            var max = Number((typeof inpWebmScale !== 'undefined' && inpWebmScale && inpWebmScale.max) ? inpWebmScale.max : 100);
            var cur = Number(webmSettings.scaleVw) || min;
            var nv = Math.max(min, Math.min(max, cur + (deltaVw || 0)));
            webmSettings.scaleVw = nv;
            if (typeof inpWebmScale !== 'undefined' && inpWebmScale) inpWebmScale.value = String(nv);
            applyWebmSettings();
        }
        function adjustWebmOpacity(delta) {
            if (!webmOn) return;
            var cur = Number(webmSettings.opacity) || 0;
            var nv = Math.max(0, Math.min(1, cur + (delta || 0)));
            webmSettings.opacity = nv;
            if (typeof inpWebmOpacity !== 'undefined' && inpWebmOpacity) inpWebmOpacity.value = String(nv);
            applyWebmSettings();
        }
        // Volume control handling (no boost above 1.0)
        function setVolume(value) {
            const v = Math.max(0, Math.min(1, Number(value) || 0));
            if (state && state.gainNode && state.gainNode.gain) {
                state.gainNode.gain.value = v;
                // Also toggle media element mute to guarantee silence at 0
                try {
                    const el = document.getElementById('radio-element');
                    if (el) el.muted = (v === 0);
                } catch(e) {}
            }
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyserNode = state.audioCtx.createAnalyser();
                state.analyserNode.fftSize = 2048; 
				// Master gain (no boost above 1.0 to avoid amplification)
				state.gainNode = state.audioCtx.createGain();
				state.gainNode.gain.value = 0.5;
				// Bind volume slider if present
				if (volumeSlider) {
					volumeSlider.value = String(state.gainNode.gain.value);
					volumeSlider.addEventListener('input', (e) => setVolume(volumeSlider.value));
				}
            }
            if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
        }
        
        // Enable/disable start controls (radio/mic/file/url)
        function setStartControlsEnabled(enabled) {
            const btnRadio = document.getElementById('btn-radio');
            const btnMic = document.getElementById('btn-mic');
            const btnFile = document.getElementById('btn-file');
            const urlInput = document.getElementById('radio-url');
            [btnRadio, btnMic, btnFile, urlInput].forEach(el => {
                if(!el) return;
                if(enabled) {
                    el.removeAttribute('disabled');
                    el.setAttribute('tabindex', '0');
                } else {
                    el.setAttribute('disabled', 'true');
                    el.setAttribute('tabindex', '-1');
                }
            });
        }
		function applyOverlayGlowAndLogo() {
            const overlay = document.getElementById('overlay');
			// Randomize overlay glow and OMNI shimmer color
			const glowHex = randomHexColor();
			overlay.style.setProperty('--glowColor', glowHex);
			overlay.classList.add('glow-on');
			// reset cycle counter so next change happens on next min pass
			overlayGlowCycleCount = 0;
			// Use a timer aligned to animation minima (every 2 cycles of the 2400ms animation)
			if (overlayGlowColorTimer) { clearInterval(overlayGlowColorTimer); overlayGlowColorTimer = null; }
			overlayGlowColorTimer = setInterval(() => {
				if (overlay.classList.contains('glow-on')) {
					overlay.style.setProperty('--glowColor', randomHexColor());
				}
			}, overlayGlowDurationMs * 2);
			const logo = document.getElementById('logo-omni');
			if (logo) {
				const omniHex = randomHexColor();
				logo.style.setProperty('--omniColor', omniHex);
				// retrigger animation
				logo.classList.remove('logo-animate');
				// force reflow
				void logo.offsetWidth;
				logo.classList.add('logo-animate');
				// ensure persistent glow pulse is active
				logo.classList.add('logo-glow');
			}
		}
		function showOverlay() {
			const overlay = document.getElementById('overlay');
			overlay.classList.remove('hidden');
			overlay.style.display = 'flex';
			applyOverlayGlowAndLogo();
			// Hide quick radio button on start page
			if (typeof radioQuickBtn !== 'undefined' && radioQuickBtn) {
				radioQuickBtn.style.display = 'none';
			}
			// Hide volume slider on start overlay
			(() => { const vs = document.getElementById('volume-slider-container'); if (vs) vs.style.display = 'none'; })();
			// Show full-screen border frame
			const border = document.getElementById('border-frame');
			if (border) border.classList.add('visible');
			// Type the current status line on start screen
			if (statusEl) {
				typeStatus(statusEl.innerText || 'Select a source to begin');
			}
            setStartControlsEnabled(true);
        }
        function hideOverlay() {
            const overlay = document.getElementById('overlay');
            overlay.classList.add('hidden');
            overlay.style.display = 'none';
			overlay.classList.remove('glow-on');
			if (overlayGlowColorTimer) { try { clearInterval(overlayGlowColorTimer); } catch(e) {} overlayGlowColorTimer = null; }
			// Hide full-screen border frame
			const border = document.getElementById('border-frame');
			if (border) border.classList.remove('visible');
            setStartControlsEnabled(false);
        }
		// Apply initial glow/shimmer on first startup if overlay is visible
		(() => {
			const overlay = document.getElementById('overlay');
			if (overlay && !overlay.classList.contains('hidden') && overlay.style.display !== 'none') {
				applyOverlayGlowAndLogo();
				// Ensure radio quick button is hidden on the start screen
				try {
					const rq = document.getElementById('radio-quick');
					if (rq) rq.style.display = 'none';
				} catch(e) {}
				// Show border frame on first load
				const border = document.getElementById('border-frame');
				if (border) border.classList.add('visible');
				// Type initial status if present
				const s = document.getElementById('loading-status');
				if (s && s.innerText && s.innerText.trim().length > 0) {
					typeStatus(s.innerText.trim());
				}
			}
			// Try to apply tiled background from pta.gif if available
			try {
				const testImg = new Image();
				testImg.onload = () => {
					document.body.style.backgroundImage = "url('pta.gif')";
					document.body.style.backgroundRepeat = "repeat";
					document.body.style.backgroundPosition = "top left";
					document.body.style.backgroundSize = "auto";
					// Ensure overlay doesn't blur the tiled background
					const ov = document.getElementById('overlay');
					if (ov) {
						ov.classList.add('no-blur');
						ov.classList.add('bg-lite'); // lighten overlay so GIF isn't overly darkened
					}
					// Hide quick radio button and volume on start overlay
					try {
						const rq = document.getElementById('radio-quick');
						if (rq) rq.style.display = 'none';
						const vs = document.getElementById('volume-slider-container');
						if (vs) vs.style.display = 'none';
					} catch(e) {}
				};
				testImg.onerror = () => { /* leave black background */ };
				testImg.src = 'pta.gif';
			} catch(e) { /* ignore */ }
		})();

        function playRadio() {
            initAudio();
            const url = radioInputEl.value;
            
            statusEl.innerText = "Connecting to Stream...";
            // Update banner title
            if(currentStationIndex >= 0 && stations[currentStationIndex] && stations[currentStationIndex].url === url) {
                showStationBanner(stations[currentStationIndex].name);
            } else {
                showStationBanner(deriveTitleFromUrl(url));
            }
            
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaElementSource(audioEl);
                state.sourceNode.connect(state.analyserNode);
                try { state.analyserNode.disconnect(); } catch(e) {}
                state.analyserNode.connect(state.gainNode);
                try { state.gainNode.disconnect(); } catch(e) {}
                state.gainNode.connect(state.audioCtx.destination);
                // Ensure active visualizer (e.g., ProjectM) is connected to the current analyser
                try {
                    if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                        state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                    }
                } catch(e) { /* ignore */ }
                if(!state.isPlaying) startGame();
                // success: reset retry attempts
                radioRetryAttempts = 0;
            }).catch(e => {
                // auto-retry with a new random station instead of alerting
                radioRetryAttempts = (radioRetryAttempts || 0) + 1;
                if (radioRetryAttempts <= MAX_RADIO_RETRIES && stations.length > 0) {
                    statusEl.innerText = "Stream failed. Trying another station...";
                    // If we don't have a current index, pick one; otherwise pick a different random
                    if (currentStationIndex < 0 || currentStationIndex >= stations.length) {
                        currentStationIndex = Math.floor(Math.random() * stations.length);
                        setStation(currentStationIndex);
                    } else {
                        pickRandomStation();
                    }
                } else {
                    statusEl.innerText = "No playable station found.";
                    // do not alert; user experience prefers silent retry
                }
            });
        }

        async function useMic() {
            initAudio();
            statusEl.innerText = "Requesting Mic Access...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaStreamSource(stream);
                state.mediaStream = stream;
                state.sourceNode.connect(state.analyserNode);
                try { state.analyserNode.disconnect(); } catch(e) {}
                state.analyserNode.connect(state.gainNode);
                try { state.gainNode.disconnect(); } catch(e) {}
                state.gainNode.connect(state.audioCtx.destination);
                // Ensure active visualizer (e.g., ProjectM) is connected to the current analyser
                try {
                    if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                        state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                    }
                } catch(e) { /* ignore */ }
                startGame();
            } catch(e) { statusEl.innerText = "Error: " + e.message; }
        }

        function useFile(e) {
            initAudio();
            const file = e.target.files[0];
            if(!file) return;
            statusEl.innerText = "Decoding...";
            const reader = new FileReader();
            reader.onload = (ev) => {
                state.audioCtx.decodeAudioData(ev.target.result, (buffer) => {
                    if(state.sourceNode) state.sourceNode.stop();
                    state.sourceNode = state.audioCtx.createBufferSource();
                    state.sourceNode.buffer = buffer;
                    state.sourceNode.loop = true;
                    state.sourceNode.connect(state.analyserNode);
                    try { state.analyserNode.disconnect(); } catch(e) {}
                    state.analyserNode.connect(state.gainNode);
                    try { state.gainNode.disconnect(); } catch(e) {}
                    state.gainNode.connect(state.audioCtx.destination);
                    state.sourceNode.start(0);
                    // Ensure active visualizer (e.g., ProjectM) is connected to the current analyser
                    try {
                        if (state.activeVisualizer && state.activeVisualizer.visualizer && typeof state.activeVisualizer.visualizer.connectAudio === 'function') {
                            state.activeVisualizer.visualizer.connectAudio(state.analyserNode);
                        }
                    } catch(e) { /* ignore */ }
                    startGame();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function startGame() {
            state.isPlaying = true;
            const overlay = document.getElementById('overlay');
            // Digital transition: animate overlay out, then start visuals
            overlay.classList.add('digital-out');
            document.getElementById('ui-layer').classList.remove('hidden');
            setTimeout(() => {
                hideOverlay();
                overlay.classList.remove('digital-out');
                loadMode(0); // Start with ProjectM
                // Show quick radio button once the app has started
                if (typeof radioQuickBtn !== 'undefined' && radioQuickBtn) {
                    radioQuickBtn.style.display = '';
                }
                // Show volume slider after starting
                (() => { const vs = document.getElementById('volume-slider-container'); if (vs) vs.style.display = 'flex'; })();
                // Build top bar: shuffle | volume | radio
                try {
                    if (topBar && shuffleToggle && volumeSlider && radioQuickBtn) {
                        topBar.innerHTML = '';
                        topBar.appendChild(shuffleToggle);
                        topBar.appendChild(document.getElementById('volume-slider-container'));
                        topBar.appendChild(radioQuickBtn);
                        topBar.style.display = 'flex';
                    }
                } catch(e) {}
                resetIdleTimer();
            }, 520);
        }

function stopAllAndShowStart() {
    // Stop active visualizer
    if (state.activeVisualizer && typeof state.activeVisualizer.destroy === 'function') {
        try { state.activeVisualizer.destroy(); } catch(e) {}
    }
    state.activeVisualizer = null;
    // Stop audio sources
    try {
        if (state.sourceNode) {
            try { state.sourceNode.disconnect(); } catch(e) {}
            try { if (typeof state.sourceNode.stop === 'function') state.sourceNode.stop(0); } catch(e) {}
            state.sourceNode = null;
        }
        if (state.mediaStream) {
            try { state.mediaStream.getTracks().forEach(t => t.stop()); } catch(e) {}
            state.mediaStream = null;
        }
        if (audioEl) {
            try { audioEl.pause(); } catch(e) {}
            try { audioEl.currentTime = 0; } catch(e) {}
            try { audioEl.src = ''; audioEl.load(); } catch(e) {}
        }
    } catch (err) { /* ignore */ }
    // Hide player UI and other overlays, show start overlay
    document.getElementById('ui-layer').classList.add('hidden');
    if (typeof hideRadioPanel === 'function') { try { hideRadioPanel(); } catch(e) {} }
    const sb = document.getElementById('station-banner');
    if (sb) { sb.classList.add('display-none'); }
    if (typeof hideWebm === 'function' && typeof webmOn !== 'undefined' && webmOn) {
        try { hideWebm(); } catch(e) {}
    }
	state.isPlaying = false;
	if (typeof statusEl !== 'undefined' && statusEl) {
		try { typeStatus("Not streaming ‚Äî choose a source to begin"); } catch(e) {}
	}
    showOverlay();
}
        // --- ENGINE: BUTTERCHURN ---
        class MilkdropEngine {
            constructor() {
                this.name = "ProjectM / Milkdrop";
                this.presets = butterchurnPresets.getPresets();
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null; // Track canvas reference
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                
                // FIX: Explicitly set canvas attributes to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                container.appendChild(this.canvas);

                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                const key = this.presetKeys[idx];
                this.visualizer.loadPreset(this.presets[key], 2.7); 
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
				// Change bottom HUD color on each preset load
				try { setBottomTextRandomColor(); } catch(e) {}
            }

            nextPreset() {
                // Pick a random preset different from current
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 30;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 60;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }
            
            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
					try { setBottomTextRandomColor(); } catch(e) {}
                } catch(e) { alert("Invalid JSON"); }
            }

            onResize() { 
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    // FIX: Update attributes AND renderer
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: BUTTERCHURN v2 (Enhanced) ---
        class MilkdropEngineV2 {
            constructor() {
                this.name = "ProjectM v2";
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null;
                this.transitionSec = visualSettings.transitionSec;
                // Use global preset map directly (largest available pack)
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                container.appendChild(this.canvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if(this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
				// Change bottom HUD color on each preset load
				try { setBottomTextRandomColor(); } catch(e) {}
            }

            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, Number(visualSettings.transitionSec) || 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
					try { setBottomTextRandomColor(); } catch(e) {}
                } catch(e) { alert("Invalid JSON"); }
            }

            nextPreset() {
                if(this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            applySettings() {
                // Restart scheduling with new shuffle window
                this.restartCycle();
                // Transition seconds will be used on next loadPreset call automatically
            }

            onResize() {
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }

        // --- ENGINE: ProjectM v3 with Bars Overlay ---
        class MilkdropEngineV3 {
            constructor() {
                this.name = "ProjectM v3 (Bars Overlay)";
                this.resizeHandler = this.onResize.bind(this);
                this.pmCanvas = null;
                this.overlayRenderer = null;
                this.overlayScene = null;
                this.overlayCamera = null;
                this.bars = [];
                this.dataArray = null;
                this.transitionSec = visualSettings.transitionSec;
                this.presets = butterchurnPresets.getPresets?.() || {};
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * Math.max(1, this.presetKeys.length));
            }

            init() {
                container.innerHTML = '';
                // ProjectM canvas (background)
                this.pmCanvas = document.createElement('canvas');
                this.pmCanvas.width = window.innerWidth;
                this.pmCanvas.height = window.innerHeight;
                container.appendChild(this.pmCanvas);

                const pxRatio = Number(visualSettings.pixelRatio) || (window.devicePixelRatio || 1);
                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.pmCanvas, {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    pixelRatio: pxRatio
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                // Overlay bars (transparent WebGL)
                this.overlayScene = new THREE.Scene();
                this.overlayCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.overlayCamera.position.z = 8;
                this.overlayRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.overlayRenderer.setSize(window.innerWidth, window.innerHeight);
                this.overlayRenderer.setPixelRatio(window.devicePixelRatio || 1);
                this.overlayRenderer.domElement.style.position = 'absolute';
                this.overlayRenderer.domElement.style.top = '0';
                this.overlayRenderer.domElement.style.left = '0';
                this.overlayRenderer.domElement.style.pointerEvents = 'none';
                container.appendChild(this.overlayRenderer.domElement);

                // Build bars similar to sceneBars
                const group = new THREE.Group();
                this.bars = [];
                const numBars = 64;
                const spacing = 0.25;
                for (let i = 0; i < numBars; i++) {
                    const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.x = (i - numBars / 2) * spacing;
                    group.add(mesh);
                    this.bars.push(mesh);
                }
                const ambient = new THREE.AmbientLight(0xffffff, 0.4);
                const point = new THREE.PointLight(0x00ffff, 1.2, 50);
                point.position.set(0, 5, 5);
                this.overlayScene.add(ambient, point, group);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);

                window.addEventListener('resize', this.resizeHandler);
                this.animate = this.animate.bind(this);
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                if (this.presetKeys.length === 0) return;
                const key = this.presetKeys[idx];
                const transition = Number(visualSettings.transitionSec) || this.transitionSec || 2.7;
                this.visualizer.loadPreset(this.presets[key], transition);
                if (state.activeVisualizer === this) {
                    document.getElementById('mode-sub').innerText = key;
                }
                try { setBottomTextRandomColor(); } catch (e) {}
            }

            nextPreset() {
                if (this.presetKeys.length === 0) return;
                let next = this.currentPresetIdx;
                if (this.presetKeys.length > 1) {
                    while (next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const minS = Number(visualSettings.shuffleMinSec) || 12;
                    const maxS = Number(visualSettings.shuffleMaxSec) || 25;
                    const lo = Math.min(minS, maxS);
                    const hi = Math.max(minS, maxS);
                    const delay = (lo + Math.random() * (hi - lo)) * 1000;
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }

            onResize() {
                // PM
                if (this.visualizer && this.pmCanvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    this.pmCanvas.width = w;
                    this.pmCanvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
                // Overlay
                if (this.overlayRenderer && this.overlayCamera) {
                    this.overlayCamera.aspect = window.innerWidth / window.innerHeight;
                    this.overlayCamera.updateProjectionMatrix();
                    this.overlayRenderer.setSize(window.innerWidth, window.innerHeight);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate);
                // Render ProjectM (background)
                try {
                    if (this.visualizer && typeof this.visualizer.render === 'function') {
                        this.visualizer.render();
                    }
                } catch(e) { /* ignore */ }
                // Update bars overlay
                if (state && state.analyserNode && this.dataArray) {
                    state.analyserNode.getByteFrequencyData(this.dataArray);
                    const step = Math.floor(this.dataArray.length / Math.max(1, this.bars.length));
                    const t = performance.now() * 0.0008;
                    for (let i = 0; i < this.bars.length; i++) {
                        const v = this.dataArray[i * step] / 255;
                        const h = 0.2 + v * 3.0;
                        this.bars[i].scale.y = h;
                        this.bars[i].position.y = h * 0.25;
                        const hue = (i / this.bars.length + t) % 1;
                        this.bars[i].material.color.setHSL(hue, 1, 0.5);
                        this.bars[i].material.emissive.setHSL(hue, 1, 0.2);
                    }
                }
                if (this.overlayRenderer && this.overlayScene && this.overlayCamera) {
                    this.overlayRenderer.render(this.overlayScene, this.overlayCamera);
                }
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if (this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                if (this.overlayRenderer) {
                    try { this.overlayRenderer.dispose(); } catch(e) {}
                }
                container.innerHTML = '';
            }
        }
        // --- ENGINE: THREE.JS ---
        class ThreeEngine {
            constructor(name, sceneFn) {
                this.name = name;
                this.sceneFn = sceneFn;
                this.resizeHandler = this.onResize.bind(this);
            }

            init() {
                container.innerHTML = '';
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 4;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio); // Sharpness
                container.appendChild(this.renderer.domElement);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);
                this.updateFn = this.sceneFn(this.scene, this.camera, this.composer);
                
                window.addEventListener('resize', this.resizeHandler);
                this.animate();
            }

            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                state.analyserNode.getByteFrequencyData(this.dataArray);
                if(this.updateFn) this.updateFn(this.dataArray, performance.now());
                this.composer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                window.removeEventListener('resize', this.resizeHandler);
                this.renderer.dispose();
                container.innerHTML = '';
            }
        }

        // --- SCENES ---
        const sceneSphere = (scene) => {
            // Use SphereGeometry for clean UVs and per-vertex coloring
            const geo = new THREE.SphereGeometry(0.9, 64, 64);
            const base = geo.attributes.position.array.slice();
            // Allocate vertex colors
            const colorAttr = new THREE.Float32BufferAttribute(geo.attributes.position.count * 3, 3);
            geo.setAttribute('color', colorAttr);
            const mat = new THREE.MeshBasicMaterial({ vertexColors: true });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            return (data, time) => {
                const bass = data[8] / 255;
                const mid = data[32] / 255;
                const tre = data[64] / 255;
                const t = time * 0.001;
                // Audio-driven subtle vertex displacement
                const arr = geo.attributes.position.array;
                for (let i = 0; i < arr.length; i += 3) {
                    const bx = base[i], by = base[i + 1], bz = base[i + 2];
                    const n = Math.sin(bx * 1.1 + t * 1.8) * 0.015 + Math.cos(by * 1.3 - t * 1.6) * 0.015;
                    const a = (i / 3) % data.length;
                    const v = data[a] / 255;
                    const push = 0.04 + bass * 0.22 + mid * 0.12 + v * 0.06;
                    const s = 1.0 + n + push * 0.02;
                    arr[i] = bx * s; arr[i + 1] = by * s; arr[i + 2] = bz * s;
                }
                geo.attributes.position.needsUpdate = true;
                // Radiating multi-colour effect based on spherical coords + time + audio
                const cols = colorAttr.array;
                for (let i = 0, vi = 0; i < arr.length; i += 3, vi += 3) {
                    const x = arr[i], y = arr[i + 1], z = arr[i + 2];
                    const ang = Math.atan2(y, x);              // [-PI, PI]
                    const r = Math.sqrt(x * x + y * y + z * z);
                    const hue = ((ang / (Math.PI * 2)) + 0.5 + t * 0.25 + bass * 0.15) % 1;
                    const sat = 0.9;
                    const lig = 0.45 + 0.25 * (mid + tre * 0.5);
                    const c = new THREE.Color().setHSL(hue, sat, lig);
                    cols[vi] = c.r; cols[vi + 1] = c.g; cols[vi + 2] = c.b;
                }
                colorAttr.needsUpdate = true;
                // Rotation and scale breathing
                mesh.rotation.y += 0.004 + mid * 0.02;
                mesh.rotation.x += 0.002 + tre * 0.01;
                mesh.scale.setScalar(1 + bass * 0.3 + mid * 0.12);
            };
        };

        const sceneTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const count = 40;
            const meshes = [];
            for(let i=0; i<count; i++){
                const geo = new THREE.TorusGeometry(1+(i*0.5), 0.05, 8, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);
                meshes.push(mesh);
            }
            scene.add(group);
            return (data, time) => {
                const step = Math.floor(data.length/count);
                for(let i=0; i<count; i++){
                    const val = data[i*step]/255;
                    meshes[i].scale.setScalar(1 + val);
                    meshes[i].material.color.setHSL(val + (time*0.0002), 1, 0.5);
                    meshes[i].rotation.z += 0.01 * (i%2?1:-1);
                }
                camera.position.z = 25 + Math.sin(time*0.001)*5;
                camera.rotation.z = time * 0.0005;
            };
        };

        const sceneBars = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const numBars = 64;
            const spacing = 0.25;
            for(let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = (i - numBars/2) * spacing;
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0x00ffff, 1.2, 50);
            point.position.set(0, 5, 5);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / numBars);
                const t = time * 0.0008;
                for(let i = 0; i < numBars; i++) {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 3.0;
                    bars[i].scale.y = h;
                    bars[i].position.y = h * 0.25;
                    const hue = (i / numBars + t) % 1;
                    bars[i].material.color.setHSL(hue, 1, 0.5);
                    bars[i].material.emissive.setHSL(hue, 1, 0.2);
                }
                group.rotation.y = Math.sin(t * 0.5) * 0.2;
            };
        };

        // Circular Audio Bars
        const sceneBarsCircle = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const num = 72;
            const radius = 3.0;
            for (let i = 0; i < num; i++) {
                const geo = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x101010, metalness: 0.2, roughness: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                const a = (i / num) * Math.PI * 2;
                m.position.set(Math.cos(a) * radius, Math.sin(a) * radius, 0);
                m.lookAt(0, 0, 0);
                group.add(m); bars.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const pl = new THREE.PointLight(0x88bbff, 1.2, 40); pl.position.set(0, 0, 6); scene.add(pl, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / bars.length);
                const t = time * 0.0005;
                bars.forEach((b, i) => {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 2.8;
                    b.scale.y = h;
                    const hue = (i / bars.length + t) % 1;
                    b.material.color.setHSL(hue, 1, 0.55);
                    b.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z += 0.002;
            };
        };

        // 3D Audio Bars (radial tiers)
        const sceneBars3D = (scene, camera) => {
            const group = new THREE.Group();
            const tiers = 4;
            const perTier = 48;
            const bars = [];
            for (let t = 0; t < tiers; t++) {
                const r = 1.5 + t * 0.9;
                for (let i = 0; i < perTier; i++) {
                    const a = (i / perTier) * Math.PI * 2;
                    const geo = new THREE.BoxGeometry(0.12 + t*0.02, 0.5, 0.12 + t*0.02);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.3, roughness: 0.5, emissive: 0x000000 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(Math.cos(a) * r, Math.sin(a) * r, -t * 0.6);
                    m.lookAt(0, 0, -t * 0.6 - 1);
                    group.add(m); bars.push(m);
                }
            }
            const amb = new THREE.AmbientLight(0xffffff, 0.35);
            const pl = new THREE.PointLight(0xff88cc, 1.4, 60); pl.position.set(0, 0, 8);
            scene.add(amb, pl, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / bars.length);
                const t = time * 0.0006;
                bars.forEach((b, i) => {
                    const v = data[(i * step) % data.length] / 255;
                    const h = 0.2 + v * 3.2;
                    b.scale.y = h;
                    b.position.z = -Math.floor(i / perTier) * 0.6 - v * 0.8;
                    const hue = (i / bars.length + t) % 1;
                    b.material.color.setHSL(hue, 1, 0.55);
                    b.material.emissive.setHSL(hue, 1, 0.15);
                });
                group.rotation.z = Math.sin(t * 0.8) * 0.2;
                group.rotation.x = Math.cos(t * 0.6) * 0.15;
            };
        };
        // High-energy neon sphere variants
        const sceneElectroSphere = (scene, camera) => {
            const geo = new THREE.IcosahedronGeometry(1.6, 64);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.8, roughness: 0.2, emissive: 0x000000 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            const base = geo.attributes.position.array.slice();
            const noise = new SimplexNoise();
            const light = new THREE.PointLight(0x66ccff, 2.2, 40);
            light.position.set(2, 2, 4);
            scene.add(new THREE.AmbientLight(0xffffff, 0.25), light);
            camera.position.z = 5;
            return (data, time) => {
                const t = time*0.0007;
                const arr = geo.attributes.position.array;
                const bass = data[8]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = base[i], y = base[i+1], z = base[i+2];
                    const n = noise.noise3d(x*0.8 + t*0.9, y*0.8 - t*0.7, z*0.8 + t*0.6);
                    const scale = 1.0 + n*(0.12 + bass*0.8);
                    arr[i] = x*scale; arr[i+1] = y*scale; arr[i+2] = z*scale;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.rotation.y += 0.01 + bass*0.06;
                mesh.rotation.x += 0.004;
                const hue = (t*0.3 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.55);
                light.intensity = 1.8 + bass*3.2;
            };
        };

        const scenePhotonShell = (scene, camera) => {
            // Points on a sphere shell
            const num = 4000;
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const u = Math.random();
                const v = Math.random();
                const theta = 2*Math.PI*u;
                const phi = Math.acos(2*v-1);
                const r = 1.8;
                positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
                positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
                positions[i*3+2] = r*Math.cos(phi);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.04, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            // Orbiting rings
            const rings = [];
            for(let i=0;i<3;i++){
                const ring = new THREE.TorusGeometry(2.0 + i*0.15, 0.03, 12, 200);
                const m = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.7 });
                const tor = new THREE.Mesh(ring, m);
                scene.add(tor);
                rings.push(tor);
            }
            camera.position.z = 6;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[10]/255;
                points.rotation.y = t*0.4 + bass*0.6;
                points.rotation.x = Math.sin(t*0.4)*0.2;
                const hue = (t*0.2 + bass*0.4) % 1;
                mat.color.setHSL(hue, 1, 0.6);
                mat.size = 0.03 + bass*0.15;
                rings.forEach((r, i) => {
                    r.rotation.x = t*(i+1);
                    r.rotation.y = t*(i+1)*0.6;
                    r.material.color.setHSL((hue + i*0.1)%1, 1, 0.6);
                    r.material.opacity = 0.4 + bass*0.5;
                });
            };
        };

        const scenePulseOrb = (scene, camera) => {
            const layers = [];
            const layerCount = 5;
            for(let i=0;i<layerCount;i++){
                const radius = 1.2 + i*0.22;
                const geo = new THREE.SphereGeometry(radius, 96, 96);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x55ccff,
                    metalness: 0.4,
                    roughness: 0.6,
                    transparent: true,
                    opacity: 0.18 + i*0.08,
                    emissive: new THREE.Color(0x113355),
                    emissiveIntensity: 0.25 + i*0.05
                });
                const mesh = new THREE.Mesh(geo, mat);
                layers.push(mesh);
                scene.add(mesh);
            }
            // Dimmer, colored lighting to reduce central white clipping
            const ambient = new THREE.AmbientLight(0x223344, 0.18);
            const light = new THREE.PointLight(0x66ccff, 0.7, 60);
            light.position.set(1.5, 2.0, 6.0);
            scene.add(ambient, light);
            camera.position.z = 7.5;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                const mid = data[24]/255;
                layers.forEach((m, i) => {
                    const hue = (0.55 + 0.08*i + t*0.06) % 1;
                    m.material.color.setHSL(hue, 0.85, 0.55 - i*0.04);
                    const s = 1.0 + bass*(0.35 + i*0.1) + Math.sin(t*1.6 + i)*0.03;
                    m.scale.setScalar(s);
                    m.rotation.y += 0.002 + mid*0.015 + i*0.0015;
                    m.rotation.x += 0.0015 + i*0.001;
                    m.material.opacity = 0.18 + i*0.08 + bass*0.08;
                });
                light.intensity = 0.6 + bass*1.2;
                light.position.x = 1.5 + Math.sin(t*0.7)*1.0;
                light.position.y = 2.0 + Math.cos(t*0.5)*0.6;
            };
        };

        // New scenes
        const sceneStarfield = (scene, camera) => {
            const stars = [];
            const geo = new THREE.SphereGeometry(0.02, 6, 6);
            for(let i=0;i<1200;i++){
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: Math.random()*0.8+0.2 });
                const m = new THREE.Mesh(geo, mat);
                m.position.set((Math.random()-0.5)*80, (Math.random()-0.5)*80, (Math.random()-0.5)*80);
                scene.add(m); stars.push(m);
            }
            camera.position.z = 6;
            return (data, time) => {
                const bass = data[8]/255;
                const t = time*0.0002;
                stars.forEach((s, i) => {
                    s.position.z += 0.02 + bass*0.3;
                    if(s.position.z > 40) s.position.z = -40;
                    const hue = (i/1200 + t) % 1;
                    s.material.color.setHSL(hue, 0.7, 0.6);
                });
                camera.rotation.z = Math.sin(t*2)*0.1;
            };
        };

        const sceneWaveGrid = (scene, camera) => {
            const gridSize = 64;
            const spacing = 0.2;
            const group = new THREE.Group();
            const planes = [];
            for(let x=0;x<gridSize;x++){
                for(let y=0;y<gridSize;y++){
                    const geo = new THREE.PlaneGeometry(0.18, 0.18);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set((x - gridSize/2)*spacing, (y - gridSize/2)*spacing, 0);
                    group.add(p);
                    planes.push(p);
                }
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / gridSize);
                const t = time * 0.0015;
                planes.forEach((p, idx) => {
                    const i = idx % gridSize;
                    const j = Math.floor(idx / gridSize);
                    const v = data[(i*step) % data.length]/255;
                    p.position.z = Math.sin(i*0.2 + j*0.25 + t*4) * (0.1 + v*0.8);
                    const hue = (v + (i+j)/ (gridSize*2) + t*0.2)%1;
                    p.material.color.setHSL(hue, 1, 0.5);
                    p.material.opacity = 0.35 + v*0.65;
                });
                group.rotation.x = Math.sin(t*0.2)*0.4;
                group.rotation.y = Math.cos(t*0.25)*0.4;
            };
        };

        const sceneParticles = (scene, camera) => {
            const num = 1500;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                positions[i*3+0] = (Math.random()-0.5)*40;
                positions[i*3+1] = (Math.random()-0.5)*40;
                positions[i*3+2] = (Math.random()-0.5)*40;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.08, transparent: true, opacity: 0.8 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 10;
            return (data, time) => {
                const bass = data[4]/255;
                points.rotation.y += 0.001 + bass*0.01;
                points.rotation.x += 0.0006;
                const hue = (time*0.0001)%1;
                points.material.color.setHSL(hue, 1, 0.6);
                points.material.size = 0.05 + bass*0.25;
            };
        };

        // --- Additional Tunnel Variants ---
        const sceneNeonTunnel = (scene, camera) => {
            const rings = [];
            const count = 36;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(2.5, 0.08, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.6 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.4;
                rings.push(m);
                scene.add(m);
            }
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[8]/255;
                rings.forEach((r, i) => {
                    r.position.z += 0.12 + bass*0.6;
                    if(r.position.z > 3.5) r.position.z -= count*1.4;
                    const hue = ((i/count) + time*0.0002) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.rotation.x = time*0.0006 + i*0.03;
                });
                camera.rotation.z = Math.sin(time*0.0006)*0.15;
            };
        };

        const sceneTwistTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const segs = [];
            for(let i=0;i<90;i++){
                const geo = new THREE.CylinderGeometry(2.2, 2.2, 0.4, 60, 1, true);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff66ff, wireframe: true, transparent: true, opacity: 0.5 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*0.9;
                m.rotation.z = i*0.1;
                group.add(m);
                segs.push(m);
            }
            scene.add(group);
            camera.position.z = 3.5;
            return (data, time) => {
                const mid = data[24]/255;
                segs.forEach((s, i) => {
                    s.position.z += 0.08 + mid*0.5;
                    if(s.position.z > 2.5) s.position.z -= 90*0.9;
                    s.rotation.z += 0.003 + mid*0.03;
                    const hue = ((i/90) + time*0.00015) % 1;
                    s.material.color.setHSL(hue, 1, 0.6);
                    s.material.opacity = 0.25 + mid*0.75;
                });
                group.rotation.y = Math.sin(time*0.0005)*0.3;
            };
        };

        const sceneParticleTunnel = (scene, camera) => {
            const num = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            for(let i=0;i<num;i++){
                const r = 2 + Math.random()*2.5;
                const a = Math.random()*Math.PI*2;
                const z = -Math.random()*60;
                positions[i*3+0] = Math.cos(a)*r;
                positions[i*3+1] = Math.sin(a)*r;
                positions[i*3+2] = z;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 3;
            return (data, time) => {
                const bass = data[6]/255;
                const arr = geo.attributes.position.array;
                for(let i=0;i<arr.length;i+=3){
                    arr[i+2] += 0.22 + bass*1.6;
                    if(arr[i+2] > 2.5) arr[i+2] -= 62.5;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0002)%1;
                mat.color.setHSL(hue, 1, 0.7);
                points.rotation.z += 0.001 + bass*0.02;
            };
        };

        const sceneGalaxy = (scene, camera) => {
            const count = 4000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(count*3);
            const colors = new Float32Array(count*3);
            for(let i=0;i<count;i++){
                const r = Math.random() * 20;
                const angle = Math.random()*Math.PI*2;
                const arm = ((i%2) * 2 - 1) * (r*0.1);
                const x = Math.cos(angle + arm) * r;
                const y = (Math.random()-0.5) * 2;
                const z = Math.sin(angle + arm) * r;
                positions[i*3+0] = x; positions[i*3+1] = y; positions[i*3+2] = z;
                const c = new THREE.Color().setHSL((r/20)*0.6 + 0.2, 1, 0.6);
                colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const mat = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 16;
            return (data, time) => {
                const bass = data[10]/255;
                points.rotation.z = time*0.0001 + bass*0.2;
                mat.size = 0.04 + bass*0.18;
            };
        };

        const sceneKaleidoRings = (scene, camera) => {
            const group = new THREE.Group();
            const rings = [];
            for(let i=0;i<14;i++){
                const geo = new THREE.TorusGeometry(0.8 + i*0.35, 0.04, 16, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const torus = new THREE.Mesh(geo, mat);
                group.add(torus);
                rings.push(torus);
            }
            scene.add(group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / rings.length);
                const t = time*0.0006;
                rings.forEach((r, i) => {
                    const v = data[i*step]/255;
                    r.rotation.x = t*(i%3+1);
                    r.rotation.y = -t*(i%2+1);
                    r.material.color.setHSL(((i/rings.length)+t)%1, 1, 0.55);
                    r.material.opacity = 0.3 + v*0.7;
                    r.scale.setScalar(1 + v*0.4);
                });
                group.rotation.z = Math.sin(t*2)*0.3;
            };
        };

        const sceneTerrain = (scene, camera) => {
            const size = 80;
            const segments = 120;
            const geo = new THREE.PlaneGeometry(size, size, segments, segments);
            const mat = new THREE.MeshStandardMaterial({ color: 0x4444ff, wireframe: false, metalness: 0.2, roughness: 0.9, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2.5;
            scene.add(mesh);
            const light = new THREE.PointLight(0x88ccff, 2, 120);
            light.position.set(0, 20, 20);
            scene.add(light, new THREE.AmbientLight(0xffffff, 0.35));
            const noise = new SimplexNoise();
            camera.position.set(0, 10, 22);
            return (data, time) => {
                const arr = geo.attributes.position.array;
                const t = time*0.0003;
                const bass = data[20]/255;
                for(let i=0;i<arr.length;i+=3){
                    const x = arr[i+0];
                    const y = arr[i+1];
                    const n = noise.noise3d(x*0.05, y*0.05, t)*2.0;
                    arr[i+2] = n + bass*3.0;
                }
                geo.attributes.position.needsUpdate = true;
                geo.computeVertexNormals();
                mesh.material.color.setHSL((t*0.2 + bass*0.3)%1, 0.8, 0.5);
                light.intensity = 1.5 + bass*2.5;
            };
        };

        const sceneHexGrid = (scene, camera) => {
            const group = new THREE.Group();
            const hexes = [];
            const radius = 0.25;
            const rows = 22, cols = 22;
            for(let r=0;r<rows;r++){
                for(let c=0;c<cols;c++){
                    const x = (c + (r%2?0.5:0)) * radius*1.8 - cols*radius*0.9;
                    const y = r * radius*1.6 - rows*radius*0.8;
                    const geo = new THREE.CylinderGeometry(radius, radius, 0.2, 6, 1);
                    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x000000, metalness: 0.1, roughness: 0.7 });
                    const m = new THREE.Mesh(geo, mat);
                    m.position.set(x, y, 0);
                    m.rotation.x = Math.PI/2;
                    group.add(m);
                    hexes.push(m);
                }
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xff66ff, 1.6, 60);
            light.position.set(0, 0, 10);
            scene.add(light, group);
            camera.position.z = 10;
            return (data, time) => {
                const step = Math.floor(data.length / hexes.length) || 1;
                const t = time*0.001;
                hexes.forEach((h, i) => {
                    const v = data[(i*step)%data.length]/255;
                    h.scale.z = 0.4 + v*2.8;
                    const hue = (v*0.6 + ((i%cols)/cols) + t*0.1)%1;
                    h.material.color.setHSL(hue, 1, 0.5);
                    h.material.emissive.setHSL(hue, 1, 0.2);
                });
                group.rotation.z = Math.sin(t*0.5)*0.2;
            };
        };

        const sceneRibbons = (scene, camera) => {
            const group = new THREE.Group();
            const ribbons = [];
            const createRibbon = (color) => {
                const points = [];
                for(let i=0;i<80;i++){
                    points.push(new THREE.Vector3(i*0.08, Math.sin(i*0.2)*0.4, 0));
                }
                const curve = new THREE.CatmullRomCurve3(points);
                const tube = new THREE.TubeGeometry(curve, 200, 0.03, 8, false);
                const mat = new THREE.MeshStandardMaterial({ color, metalness: 0.2, roughness: 0.2, emissive: 0x000000 });
                const mesh = new THREE.Mesh(tube, mat);
                return mesh;
            };
            for(let i=0;i<6;i++){
                const hue = i/6;
                const col = new THREE.Color().setHSL(hue, 1, 0.6);
                const m = createRibbon(col);
                m.position.y = (i-3)*0.4;
                m.position.x = -3;
                group.add(m);
                ribbons.push(m);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.6), group);
            const light = new THREE.PointLight(0x66ffff, 2, 40);
            light.position.set(0, 2, 8);
            scene.add(light);
            camera.position.set(0, 2, 10);
            return (data, time) => {
                const bass = data[12]/255;
                const t = time*0.0012;
                ribbons.forEach((m, i) => {
                    m.rotation.y = t*(i%3+1);
                    m.rotation.x = Math.sin(t + i)*0.3;
                    m.position.x = -3 + Math.sin(t*0.7 + i)*2.5 + bass*2.0;
                });
                group.rotation.z = Math.sin(t*0.6)*0.2;
                light.intensity = 1.2 + bass*2.0;
            };
        };

        // --- Infinity Pattern Tunnels ---
        const sceneInfinityTunnel = (scene, camera, composer) => {
            const rings = [];
            const count = 64;
            const baseRadius = 2.2;
            for(let i=0;i<count;i++){
                const geo = new THREE.TorusGeometry(baseRadius, 0.06, 12, 120);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });
                const m = new THREE.Mesh(geo, mat);
                m.position.z = -i*1.0;
                rings.push(m);
                scene.add(m);
            }
            const after = new AfterimagePass(0.88);
            composer.addPass(after);
            camera.position.z = 4;
            return (data, time) => {
                const t = time * 0.001;
                const bass = data[10]/255;
                rings.forEach((r, i) => {
                    // Figure-eight cross-section via Lissajous pattern
                    const phase = (i*0.22) + t*1.2;
                    r.position.x = Math.sin(phase) * (baseRadius * 0.6);
                    r.position.y = Math.sin(phase*2.0) * (baseRadius * 0.35);
                    r.position.z += 0.18 + bass*0.8;
                    if(r.position.z > 2.5) r.position.z -= count*1.0;
                    const hue = ((i/count) + t*0.05) % 1;
                    r.material.color.setHSL(hue, 1, 0.6);
                    r.material.opacity = 0.35 + bass*0.6;
                    r.rotation.x = phase*0.2;
                    r.rotation.y = -phase*0.15;
                });
                camera.rotation.z = Math.sin(t*0.8)*0.2;
            };
        };

        const sceneInfinityMirror = (scene, camera, composer) => {
            const frames = [];
            const count = 40;
            for(let i=0;i<count;i++){
                const geo = new THREE.RingGeometry(0.8, 3.0, 6, 1);
                const mat = new THREE.MeshBasicMaterial({ color: 0x88ccff, side: THREE.DoubleSide, transparent: true, opacity: 0.6 });
                const ring = new THREE.Mesh(geo, mat);
                ring.position.z = -i*1.4;
                frames.push(ring);
                scene.add(ring);
            }
            const after = new AfterimagePass(0.9);
            composer.addPass(after);
            camera.position.z = 3.8;
            return (data, time) => {
                const t = time*0.001;
                const mid = data[24]/255;
                frames.forEach((f, i) => {
                    f.position.z += 0.14 + mid*0.7;
                    if(f.position.z > 2.5) f.position.z -= count*1.4;
                    const s = 0.9 + Math.sin(i*0.2 + t*2.0)*0.08 + mid*0.2;
                    f.scale.set(s, s, s);
                    f.rotation.z = t*0.7 + i*0.05;
                    const hue = ((i/count) + t*0.1) % 1;
                    f.material.color.setHSL(hue, 1, 0.65);
                    f.material.opacity = 0.3 + mid*0.7;
                });
            };
        };
        // --- Kaleidoscope Shader ---
        const KaleidoShader = {
            uniforms: {
                tDiffuse: { value: null },
                sides: { value: 6.0 },
                angle: { value: 0.0 },
                rotation: { value: 0.0 },
                time: { value: 0.0 },
                gain: { value: 0.0 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float sides;
                uniform float angle;
                uniform float rotation;
                uniform float time;
                uniform float gain;
                varying vec2 vUv;
                
                float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453123); }
                float noise(vec2 p){
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float a = hash(i);
                    float b = hash(i + vec2(1.0, 0.0));
                    float c = hash(i + vec2(0.0, 1.0));
                    float d = hash(i + vec2(1.0, 1.0));
                    vec2 u = f*f*(3.0-2.0*f);
                    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
                }
                float fbm(vec2 p){
                    float v = 0.0;
                    float a = 0.5;
                    for(int i=0;i<5;i++){
                        v += a * noise(p);
                        p = p * 2.0 + vec2(23.1, 17.7);
                        a *= 0.5;
                    }
                    return v;
                }
                vec3 palette(float t){
                    return 0.5 + 0.5*cos(6.2831853*(vec3(0.0,0.33,0.67) + t));
                }
                vec4 fractalColor(vec2 uv){
                    // Centered uv for fractal evolution
                    vec2 q = uv - 0.5;
                    float r = length(q);
                    float ang = atan(q.y, q.x);
                    vec2 p = vec2(cos(ang), sin(ang)) * (r * 2.2);
                    float f = fbm(p * 1.8 + vec2(time*0.15, -time*0.11 + gain*0.3));
                    vec3 col = palette(f + r*0.25 + gain*0.2);
                    // Radial darkening to avoid bright center
                    float vign = smoothstep(0.95, 0.3, r);
                    return vec4(col * vign, 1.0);
                }
                void main() {
                    vec2 uv = vUv - 0.5;
                    float r = length(uv);
                    float a = atan(uv.y, uv.x) + rotation;
                    float sector = 6.28318530718 / max(1.0, sides);
                    a = mod(a, sector);
                    a = abs(a - sector * 0.5);
                    a += angle;
                    vec2 pos = vec2(cos(a), sin(a)) * r;
                    vec2 sampleUv = pos + 0.5;
                    bool inBounds = all(greaterThanEqual(sampleUv, vec2(0.0))) && all(lessThanEqual(sampleUv, vec2(1.0)));
                    vec4 src = texture2D(tDiffuse, clamp(sampleUv, 0.0, 1.0));
                    vec4 fractCol = fractalColor(sampleUv);
                    // Blend: use fractal when out-of-bounds, otherwise softly mix by radial factor to eliminate white cores
                    float mixAmt = smoothstep(0.0, 0.35, r) * 0.7 + gain*0.2;
                    vec4 col = mix(src, fractCol, mixAmt);
                    if(!inBounds){
                        col = fractCol;
                    }
                    gl_FragColor = col;
                }
            `
        };

        const RadialZoomShader = {
            uniforms: {
                tDiffuse: { value: null },
                center: { value: new THREE.Vector2(0.5, 0.5) },
                strength: { value: 0.2 }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform vec2 center;
                uniform float strength;
                varying vec2 vUv;
                void main() {
                    vec4 color = vec4(0.0);
                    float total = 0.0;
                    vec2 toCenter = center - vUv;
                    float offset = strength * 0.02;
                    for (float t = 0.0; t <= 1.0; t += 0.1) {
                        vec2 sampleUv = vUv + toCenter * t * offset;
                        color += texture2D(tDiffuse, sampleUv);
                        total += 1.0;
                    }
                    gl_FragColor = color / total;
                }
            `
        };

        // Helper: build a simple colorful source for kaleidoscope
        function buildKaleidoSource(scene) {
            const group = new THREE.Group();
            const num = 24;
            for(let i=0;i<num;i++){
                const hue = i/num;
                const mat = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(hue, 1, 0.6) });
                const geo = new THREE.TorusKnotGeometry(0.5 + (i%6)*0.05, 0.12, 90, 18, 2 + (i%3), 3 + (i%4));
                const m = new THREE.Mesh(geo, mat);
                m.position.set(Math.cos(i)*2.2, Math.sin(i*1.3)*1.2, -1 - (i%5)*0.2);
                m.rotation.x = i*0.2;
                m.rotation.y = i*0.15;
                group.add(m);
            }
            scene.add(group);
            return group;
        }

        const sceneKaleido = (sides) => (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            pass.uniforms.sides.value = sides;
            composer.addPass(pass);
            camera.position.z = 4;
            return (data, time) => {
                const bass = data[12]/255;
                group.rotation.y = time*0.0006 + bass*0.2;
                group.rotation.x = Math.sin(time*0.0004)*0.3;
                pass.uniforms.rotation.value = time*0.0002 + bass*0.6;
                pass.uniforms.angle.value = Math.sin(time*0.0005)*0.5;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = bass;
            };
        };

        const sceneKaleidoSpiral = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const pass = new ShaderPass(KaleidoShader);
            composer.addPass(pass);
            camera.position.z = 5;
            return (data, time) => {
                const bass = data[6]/255;
                pass.uniforms.sides.value = 5.0 + Math.floor((Math.sin(time*0.0007)+1.0)*3.5); // 5..12
                pass.uniforms.rotation.value = time*0.00035 + bass*0.8;
                pass.uniforms.angle.value = Math.cos(time*0.0006)*0.8;
                group.rotation.y += 0.002 + bass*0.02;
                group.rotation.z = Math.sin(time*0.0003)*0.4;
                pass.uniforms.time.value = time*0.001;
                pass.uniforms.gain.value = (data[12]+data[24])/(2.0*255.0);
            };
        };

        const sceneKaleidoLayered = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const k1 = new ShaderPass(KaleidoShader);
            const k2 = new ShaderPass(KaleidoShader);
            k1.uniforms.sides.value = 7.0;
            k2.uniforms.sides.value = 11.0;
            composer.addPass(k1);
            composer.addPass(k2);
            camera.position.z = 5;
            // Smoothed, time-integrated rotations to avoid jitter
            let rot1 = 0, rot2 = 0, rotY = 0, rotX = 0;
            let speed1 = 0.00022, speed2 = -0.00026, speedY = 0.00028, speedX = 0.00018;
            let gSmooth = 0;
            let lastTime = 0;
            return (data, time) => {
                const gRaw = (data[6] + data[10] + data[12] + data[24]) / (4.0 * 255.0);
                gSmooth = gSmooth + (gRaw - gSmooth) * 0.08; // low-pass filter
                const dt = lastTime ? (time - lastTime) : 16.0; // ms
                lastTime = time;
                // Gently modulate speeds with smoothed gain
                const target1 = 0.00022 + gSmooth * 0.00040;
                const target2 = -0.00026 - gSmooth * 0.00035;
                const targetY = 0.00028 + gSmooth * 0.00025;
                const targetX = 0.00018 + gSmooth * 0.00010;
                speed1 += (target1 - speed1) * 0.05;
                speed2 += (target2 - speed2) * 0.05;
                speedY += (targetY - speedY) * 0.05;
                speedX += (targetX - speedX) * 0.05;
                // Integrate rotations (smooth)
                rot1 += speed1 * dt;
                rot2 += speed2 * dt;
                rotY += speedY * dt;
                rotX += speedX * dt;
                group.rotation.x = rotX;
                group.rotation.y = rotY;
                k1.uniforms.rotation.value = rot1;
                k2.uniforms.rotation.value = rot2;
                // Slow, continuous angle sweep
                k1.uniforms.angle.value = Math.sin(time * 0.00025) * 0.55;
                k2.uniforms.angle.value = Math.cos(time * 0.00023) * 0.55;
                // Pass time/gain to shaders
                const tSec = time * 0.001;
                k1.uniforms.time.value = tSec;
                k2.uniforms.time.value = tSec;
                k1.uniforms.gain.value = gSmooth;
                k2.uniforms.gain.value = gSmooth * 0.85;
            };
        };

        const sceneKaleidoZoom = (scene, camera, composer) => {
            const group = buildKaleidoSource(scene);
            const kaleido = new ShaderPass(KaleidoShader);
            const zoom = new ShaderPass(RadialZoomShader);
            composer.addPass(kaleido);
            composer.addPass(zoom);
            camera.position.z = 4.5;
            return (data, time) => {
                const bass = data[14]/255;
                group.rotation.y = time*0.0005 + bass*0.3;
                kaleido.uniforms.sides.value = 10.0;
                kaleido.uniforms.rotation.value = time*0.00025;
                zoom.uniforms.center.value.set(0.5, 0.5);
                zoom.uniforms.strength.value = 0.1 + bass*0.6;
                kaleido.uniforms.time.value = time*0.001;
                kaleido.uniforms.gain.value = (data[10]+data[14]+data[18])/(3.0*255.0);
            };
        };

        // --- Self-Replicating / Fractal Scenes ---
        const sceneMengerSponge = (scene, camera) => {
            const depth = 2; // keep counts reasonable
            const positions = [];
            function addLevel(center, size, d){
                if(d === 0){
                    positions.push({ center, size });
                    return;
                }
                const step = size / 3;
                for(let x=0;x<3;x++){
                    for(let y=0;y<3;y++){
                        for(let z=0;z<3;z++){
                            // Skip the center cross sections
                            const mid = (x===1) + (y===1) + (z===1);
                            if(mid >= 2) continue;
                            const nx = center.x + (x-1)*step;
                            const ny = center.y + (y-1)*step;
                            const nz = center.z + (z-1)*step;
                            addLevel(new THREE.Vector3(nx, ny, nz), step, d-1);
                        }
                    }
                }
            }
            addLevel(new THREE.Vector3(0,0,0), 6, depth);
            const count = positions.length;
            const geo = new THREE.BoxGeometry(1,1,1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x66ccff, metalness: 0.3, roughness: 0.6, emissive: 0x000000 });
            const mesh = new THREE.InstancedMesh(geo, mat, count);
            const dummy = new THREE.Object3D();
            positions.forEach((p, i) => {
                dummy.position.copy(p.center);
                dummy.scale.setScalar(p.size * 0.95);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);
            });
            mesh.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            const light = new THREE.PointLight(0xffffff, 2, 100);
            light.position.set(6, 8, 10);
            scene.add(light, mesh);
            camera.position.set(0, 0, 14);
            return (data, time) => {
                const g = (data[6]+data[12]+data[24])/(3*255);
                mesh.rotation.x = time*0.0003 + g*0.4;
                mesh.rotation.y = time*0.0004 + g*0.5;
                mat.emissiveIntensity = 0.2 + g*2.0;
                const hue = (time*0.00008 + g*0.3) % 1;
                mat.color.setHSL(hue, 0.7, 0.6);
            };
        };

        const sceneSierpinskiTetra = (scene, camera) => {
            // Base tetra geometry
            const r = 1;
            const v = [
                new THREE.Vector3(1, 1, 1),
                new THREE.Vector3(-1, -1, 1),
                new THREE.Vector3(-1, 1, -1),
                new THREE.Vector3(1, -1, -1)
            ];
            const base = new THREE.TetrahedronGeometry(r, 0);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff88aa, metalness: 0.2, roughness: 0.7 });
            const depth = 4;
            const transforms = [];
            function add(level, center, scale){
                if(level === 0){
                    transforms.push({ center, scale });
                    return;
                }
                const s = scale * 0.5;
                for(let i=0;i<4;i++){
                    add(level-1, new THREE.Vector3(
                        center.x + v[i].x * s,
                        center.y + v[i].y * s,
                        center.z + v[i].z * s
                    ), s);
                }
            }
            add(depth, new THREE.Vector3(0,0,0), 3.0);
            const inst = new THREE.InstancedMesh(base, mat, transforms.length);
            const dummy = new THREE.Object3D();
            transforms.forEach((t, i) => {
                dummy.position.copy(t.center);
                dummy.scale.setScalar(t.scale);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const light = new THREE.PointLight(0xff66ff, 2.4, 100);
            light.position.set(6, 6, 12);
            scene.add(light, inst);
            camera.position.set(0, 0, 16);
            return (data, time) => {
                const bass = data[8]/255;
                inst.rotation.y = time*0.00035 + bass*0.6;
                inst.rotation.x = time*0.0002;
                const hue = (time*0.00012) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                light.intensity = 1.4 + bass*3.0;
            };
        };

        const sceneGameOfLife = (scene, camera) => {
            const W = 128, H = 128;
            const cells = new Uint8Array(W*H);
            const nextCells = new Uint8Array(W*H);
            // random init
            for(let i=0;i<W*H;i++){ cells[i] = Math.random() < 0.15 ? 1 : 0; }
            const data = new Uint8Array(W*H*3);
            const tex = new THREE.DataTexture(data, W, H, THREE.RGBFormat);
            tex.needsUpdate = true;
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.95 });
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), mat);
            scene.add(plane);
            camera.position.z = 10;
            function step() {
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        let n = 0;
                        for(let dy=-1;dy<=1;dy++){
                            for(let dx=-1;dx<=1;dx++){
                                if(dx===0 && dy===0) continue;
                                const nx = (x+dx+W)%W;
                                const ny = (y+dy+H)%H;
                                n += cells[ny*W + nx];
                            }
                        }
                        const c = cells[idx];
                        nextCells[idx] = (c===1 && (n===2 || n===3)) || (c===0 && n===3) ? 1 : 0;
                    }
                }
                cells.set(nextCells);
            }
            let acc = 0;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3*255);
                // step a few times per second + boost with audio
                acc += 0.016 + g*0.05;
                while(acc > 0.1){ step(); acc -= 0.1; }
                // write texture
                const t = time*0.0002;
                for(let y=0;y<H;y++){
                    for(let x=0;x<W;x++){
                        const idx = y*W + x;
                        const alive = cells[idx];
                        const i3 = idx*3;
                        const hue = (t + x/W*0.3 + y/H*0.2) % 1;
                        const c = alive ? hue : 0.0;
                        // hsv to rgb approx via palette
                        const r = 0.5 + 0.5*Math.cos(6.2831*(c + 0.0));
                        const gch = 0.5 + 0.5*Math.cos(6.2831*(c + 0.33));
                        const b = 0.5 + 0.5*Math.cos(6.2831*(c + 0.67));
                        data[i3+0] = Math.floor(r*255);
                        data[i3+1] = Math.floor(gch*255);
                        data[i3+2] = Math.floor(b*255);
                    }
                }
                tex.needsUpdate = true;
                plane.rotation.z = Math.sin(time*0.0003)*0.2;
                plane.scale.setScalar(1.0 + g*0.3);
            };
        };

        // Mandelbrot (shader)
        const sceneMandelbrot = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                center: { value: new THREE.Vector2(-0.5, 0.0) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 center;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 c = center + uv / zoom;
                        vec2 z = vec2(0.0);
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            float x = (z.x*z.x - z.y*z.y) + c.x;
                            float y = (2.0*z.x*z.y) + c.y;
                            z = vec2(x,y);
                            if(dot(z,z) > 4.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.5), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                const baseZoom = 0.85 + Math.sin(time*0.0001)*0.15;
                uni.zoom.value = 1.5 + baseZoom * (1.0 + g*4.0);
                uni.center.value.set(-0.5 + Math.sin(time*0.00008)*0.15, Math.cos(time*0.00006)*0.1);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Julia Set (shader)
        const sceneJulia = (scene, camera) => {
            const uni = {
                time: { value: 0.0 },
                c: { value: new THREE.Vector2(-0.70176, -0.3842) },
                zoom: { value: 1.0 },
                gain: { value: 0.0 },
                aspect: { value: window.innerWidth / window.innerHeight }
            };
            const mat = new THREE.ShaderMaterial({
                uniforms: uni,
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
                    }
                `,
                fragmentShader: `
                    precision highp float;
                    varying vec2 vUv;
                    uniform vec2 c;
                    uniform float zoom;
                    uniform float time;
                    uniform float gain;
                    uniform float aspect;
                    vec3 palette(float t){
                        return 0.5 + 0.5*cos(6.28318*(vec3(0.0,0.33,0.67) + t));
                    }
                    void main(){
                        vec2 uv = (vUv - 0.5);
                        uv.x *= aspect;
                        vec2 z = uv / zoom * 2.0;
                        float it = 0.0;
                        const int MAX_IT = 200;
                        float maxIter = 60.0 + gain*120.0;
                        for(int i=0; i<MAX_IT; i++){
                            if(it > maxIter) break;
                            z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;
                            if(dot(z,z) > 16.0) break;
                            it += 1.0;
                        }
                        float t = it / maxIter;
                        float sm = t + 1.0 - log2(log(length(z)))/log(2.0);
                        sm = clamp(sm, 0.0, 1.0);
                        vec3 col = palette(sm + time*0.02);
                        gl_FragColor = vec4(col * pow(t, 0.55), 1.0);
                    }
                `
            });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat);
            scene.add(mesh);
            camera.position.z = 1;
            return (audio, time) => {
                const g = (audio[8]+audio[16]+audio[24])/(3.0*255.0);
                uni.time.value = time*0.001;
                uni.gain.value = g;
                uni.zoom.value = 1.4 + 0.6*Math.sin(time*0.0002) + g*2.2;
                const ang = time*0.00015;
                uni.c.value.set(Math.cos(ang)*0.7, Math.sin(ang*1.3)*0.5);
                uni.aspect.value = window.innerWidth / window.innerHeight;
            };
        };

        // Barnsley Fern (points)
        const sceneBarnsleyFern = (scene, camera) => {
            const num = 30000;
            const geo = new THREE.BufferGeometry();
            const positions = new Float32Array(num*3);
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.PointsMaterial({ color: 0x66ff99, size: 0.03, transparent: true, opacity: 0.9 });
            const points = new THREE.Points(geo, mat);
            scene.add(points);
            camera.position.z = 8;
            let x = 0, y = 0;
            function step() {
                const r = Math.random();
                let nx, ny;
                if (r < 0.01) { nx = 0.0; ny = 0.16*y; }
                else if (r < 0.86) { nx = 0.85*x + 0.04*y; ny = -0.04*x + 0.85*y + 1.6; }
                else if (r < 0.93) { nx = 0.2*x - 0.26*y; ny = 0.23*x + 0.22*y + 1.6; }
                else { nx = -0.15*x + 0.28*y; ny = 0.26*x + 0.24*y + 0.44; }
                x = nx; y = ny;
            }
            return (audio, time) => {
                const g = (audio[6]+audio[12]+audio[24])/(3.0*255.0);
                for (let i=0;i<num;i++) {
                    step();
                    positions[i*3+0] = x*1.6 - 2.0;
                    positions[i*3+1] = y*1.6 - 3.0;
                    positions[i*3+2] = 0;
                }
                geo.attributes.position.needsUpdate = true;
                const hue = (time*0.0001 + g*0.5) % 1;
                mat.color.setHSL(hue, 0.8, 0.6);
                points.rotation.z = Math.sin(time*0.0003)*0.1;
                points.scale.setScalar(1.0 + g*0.2);
            };
        };

        // Lorenz Attractor (line)
        const sceneLorenz = (scene, camera) => {
            const maxPts = 6000;
            const positions = new Float32Array(maxPts*3);
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            const mat = new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 });
            const line = new THREE.Line(geo, mat);
            scene.add(line);
            camera.position.z = 30;
            let x = 0.01, y = 0.0, z = 0.0;
            const dt = 0.005;
            const sigma = 10.0, rho = 28.0, beta = 8.0/3.0;
            let idx = 0;
            return (audio, time) => {
                const g = (audio[10]+audio[18])/(2.0*255.0);
                for (let k=0;k<10;k++) {
                    const dx = sigma*(y - x);
                    const dy = x*(rho - z) - y;
                    const dz = x*y - beta*z;
                    x += dx*dt;
                    y += dy*dt;
                    z += dz*dt;
                    positions[idx*3+0] = x;
                    positions[idx*3+1] = y;
                    positions[idx*3+2] = z - 20.0;
                    idx = (idx + 1) % maxPts;
                }
                geo.attributes.position.needsUpdate = true;
                line.rotation.y = time*0.0002 + g*0.4;
                line.rotation.x = Math.sin(time*0.0003)*0.2;
                const hue = (time*0.00008 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
            };
        };

        // Sierpinski Carpet (instanced)
        const sceneSierpinskiCarpet = (scene, camera) => {
            const depth = 4;
            const squares = [];
            function add(level, cx, cy, size) {
                if (level === 0) { squares.push({ cx, cy, size }); return; }
                const s3 = size/3;
                for (let dx=-1; dx<=1; dx++){
                    for (let dy=-1; dy<=1; dy++){
                        if (dx === 0 && dy === 0) continue;
                        add(level-1, cx + dx*s3, cy + dy*s3, s3);
                    }
                }
            }
            add(depth, 0, 0, 6);
            const geo = new THREE.PlaneGeometry(1, 1);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const inst = new THREE.InstancedMesh(geo, mat, squares.length);
            const dummy = new THREE.Object3D();
            squares.forEach((s, i) => {
                dummy.position.set(s.cx, s.cy, 0);
                dummy.scale.set(s.size*0.95, s.size*0.95, 1);
                dummy.updateMatrix();
                inst.setMatrixAt(i, dummy.matrix);
            });
            inst.instanceMatrix.needsUpdate = true;
            scene.add(inst);
            camera.position.z = 10;
            return (audio, time) => {
                const g = (audio[4]+audio[12]+audio[28])/(3.0*255.0);
                const hue = (time*0.00015 + g*0.4) % 1.0;
                mat.color.setHSL(hue, 1, 0.6);
                inst.rotation.z = Math.sin(time*0.0003)*0.2;
                inst.scale.setScalar(1.0 + g*0.25);
            };
        };

        // --- Emoji Helpers and Scenes ---
        function createEmojiTexture(char) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = '200px Apple Color Emoji, Noto Color Emoji, Segoe UI Emoji, EmojiOne Mozilla, Twemoji Mozilla, Segoe UI Symbol, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(char, size/2, size/2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        const EMOJIS = ['üéµ','‚ú®','üî•','üí´','üåà','üí•','‚ù§Ô∏è','üåÄ','üåü','ü§ñ','üéß','üéâ','üéá','üõ∞Ô∏è','ü™ê','‚ö°Ô∏è'];

        const sceneEmojiSwarm = (scene, camera) => {
            const sprites = [];
            const velocities = [];
            const count = 240;
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            for(let i=0;i<count;i++){
                const tex = textures[i % textures.length];
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                const spr = new THREE.Sprite(mat);
                spr.position.set((Math.random()-0.5)*18, (Math.random()-0.5)*10, (Math.random()-0.5)*12);
                const s = Math.random()*0.7 + 0.3;
                spr.scale.set(s, s, 1);
                sprites.push(spr);
                velocities.push(new THREE.Vector3((Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03, (Math.random()-0.5)*0.03));
                scene.add(spr);
            }
            camera.position.z = 8;
            return (data, time) => {
                const t = time*0.001;
                const bass = data[6]/255;
                sprites.forEach((s, i) => {
                    const v = velocities[i];
                    // Simple cohesion toward origin + slight orbit
                    const toCenter = s.position.clone().multiplyScalar(-0.002);
                    v.add(toCenter);
                    v.x += Math.sin(t + i*0.1)*0.001;
                    v.y += Math.cos(t*0.8 + i*0.07)*0.001;
                    s.position.add(v);
                    // Wrap bounds
                    if(s.position.x > 10) s.position.x = -10;
                    if(s.position.x < -10) s.position.x = 10;
                    if(s.position.y > 6) s.position.y = -6;
                    if(s.position.y < -6) s.position.y = 6;
                    if(s.position.z > 8) s.position.z = -8;
                    if(s.position.z < -8) s.position.z = 8;
                    // Pulse size with bass
                    const base = 0.3 + (i%5)*0.04;
                    const pulse = base + bass*0.8;
                    s.scale.set(pulse, pulse, 1);
                    s.material.opacity = 0.6 + bass*0.4;
                });
                camera.rotation.z = Math.sin(t*0.4)*0.1;
            };
        };

        const sceneEmojiOrbits = (scene, camera) => {
            const group = new THREE.Group();
            scene.add(group);
            const textures = EMOJIS.map(e => createEmojiTexture(e));
            const rings = [];
            for(let r=0;r<5;r++){
                const ringGroup = new THREE.Group();
                const num = 14 + r*5;
                const radius = 2.2 + r*1.4;
                for(let i=0;i<num;i++){
                    const tex = textures[Math.floor(Math.random()*textures.length)];
                    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                    const spr = new THREE.Sprite(mat);
                    const a = (i/num)*Math.PI*2;
                    spr.position.set(Math.cos(a)*radius, Math.sin(a)*radius, -r*0.4);
                    const s = 0.22 + r*0.09;
                    spr.scale.set(s, s, 1);
                    ringGroup.add(spr);
                }
                group.add(ringGroup);
                rings.push({ group: ringGroup, radius });
            }
            camera.position.z = 8;
            let lastSwapMs = 0;
            return (data, time) => {
                const bass = data[8]/255;
                const mid = data[24]/255;
                rings.forEach((r, i) => {
                    r.group.rotation.z += 0.0006 + bass*0.006 + i*0.00025;
                    r.group.position.z = Math.sin(time*0.00025 + i)*0.8;
                    r.group.children.forEach((spr, j) => {
                        spr.material.rotation = time*0.0002 + j*0.03;
                        const s0 = spr.scale.x;
                        const pulse = s0 * (0.96 + mid*0.25*Math.sin(time*0.003 + j));
                        spr.scale.set(pulse, pulse, 1);
                    });
                });
                if (time - lastSwapMs > 4000) {
                    lastSwapMs = time;
                    const ring = rings[Math.floor(Math.random()*rings.length)];
                    if (ring && ring.group.children.length > 0) {
                        const idx = Math.floor(Math.random()*ring.group.children.length);
                        const spr = ring.group.children[idx];
                        const tex = textures[Math.floor(Math.random()*textures.length)];
                        spr.material.map = tex;
                        spr.material.needsUpdate = true;
                    }
                }
                group.rotation.x = Math.sin(time*0.0004)*0.2;
                group.rotation.y = Math.cos(time*0.0003)*0.2;
            };
        };

        // --- MASTER CONTROL ---
        const modes = [
            new MilkdropEngine(),
            new MilkdropEngineV2(),
            new MilkdropEngineV3(),
            new ThreeEngine("Audio Bars", sceneBars),
            new ThreeEngine("Audio Bars (Circle)", sceneBarsCircle),
            new ThreeEngine("Audio Bars 3D", sceneBars3D),
            new ThreeEngine("Neon Sphere", sceneSphere),
            new ThreeEngine("Electro Sphere", sceneElectroSphere),
            new ThreeEngine("Photon Shell", scenePhotonShell),
			new ThreeEngine("Pulse Orb", scenePulseOrb),
            new ThreeEngine("Cyber Tunnel", sceneTunnel),
            new ThreeEngine("Starfield", sceneStarfield),
            new ThreeEngine("Wave Grid", sceneWaveGrid),
            new ThreeEngine("Particles", sceneParticles),
            new ThreeEngine("Infinity Tunnel", sceneInfinityTunnel),
            new ThreeEngine("Infinity Mirror", sceneInfinityMirror),
            new ThreeEngine("Neon Tunnel", sceneNeonTunnel),
            new ThreeEngine("Twist Tunnel", sceneTwistTunnel),
            new ThreeEngine("Particle Tunnel", sceneParticleTunnel),
            new ThreeEngine("Galaxy", sceneGalaxy),
            new ThreeEngine("Terrain", sceneTerrain),
            new ThreeEngine("Hex Grid", sceneHexGrid),
            new ThreeEngine("Ribbons", sceneRibbons),
            new ThreeEngine("Mandelbrot", sceneMandelbrot),
            new ThreeEngine("Julia Set", sceneJulia),
            new ThreeEngine("Barnsley Fern", sceneBarnsleyFern),
            new ThreeEngine("Lorenz Attractor", sceneLorenz),
            new ThreeEngine("Sierpinski Carpet", sceneSierpinskiCarpet),
            new ThreeEngine("Emoji Swarm", sceneEmojiSwarm),
            new ThreeEngine("Emoji Orbits", sceneEmojiOrbits),
            new ThreeEngine("Kaleidoscope Layered", sceneKaleidoLayered),
			new ThreeEngine("Kaleidoscope Zoom", sceneKaleidoZoom)
        ];

        function loadMode(index) {
            if(state.activeVisualizer) state.activeVisualizer.destroy();
            let idx = index;
            if(idx < 0) idx = modes.length - 1;
            if(idx >= modes.length) idx = 0;
            state.currentModeIdx = idx;
            state.activeVisualizer = modes[idx];
            
            // UI Updates
            document.getElementById('mode-title').innerText = state.activeVisualizer.name;
            if(!(state.activeVisualizer && state.activeVisualizer.loadPreset)) {
                document.getElementById('mode-sub').innerText = "3D Interactive";
            }
            
            // Show/Hide Skip Button
            const skipBtn = document.getElementById('btn-skip-preset');
            if(state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') skipBtn.classList.remove('display-none');
            else skipBtn.classList.add('display-none');

            state.activeVisualizer.init();
            // Randomize bottom text color each time a mode loads
            setBottomTextRandomColor();
        }
        
        // Allow opening overlay by clicking the title area
        document.getElementById('mode-info').addEventListener('click', (e) => {
            e.stopPropagation();
            showOverlay();
        });

        // --- BINDINGS ---
        document.getElementById('btn-prev').addEventListener('click', () => { loadMode(state.currentModeIdx - 1); resetIdleTimer(); });
        document.getElementById('btn-next').addEventListener('click', () => { loadMode(state.currentModeIdx + 1); resetIdleTimer(); });
        document.getElementById('btn-radio').addEventListener('click', playRadio);
        document.getElementById('btn-mic').addEventListener('click', useMic);
        document.getElementById('file-input').addEventListener('change', useFile);
        document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
        // WebM toggle and nav
        webmBtn.addEventListener('click', () => {
            if(!webmOn) {
                if(webmList.length === 0) {
                    // Ensure list is loaded then show
                    loadWebmList().finally(() => {
                        if(webmList.length > 0) showWebm();
                        else alert('No WebM files found in webm/.');
                    });
                } else {
                    showWebm();
                }
            } else {
                hideWebm();
            }
        });
        webmBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleWebmSettingsPanel();
        });
        webmPrevBtn.addEventListener('click', () => { prevWebm(); resetIdleTimer(); });
        webmNextBtn.addEventListener('click', () => { nextWebm(); resetIdleTimer(); });
        settingsBtn.addEventListener('click', () => {
            if(settingsPanel.classList.contains('display-none')) {
                settingsPanel.classList.remove('display-none');
                settingsPanel.style.opacity = '1';
                settingsPanel.style.pointerEvents = 'auto';
                scheduleSettingsPanelClose();
            } else {
                if (settingsPanelTimer) { clearTimeout(settingsPanelTimer); settingsPanelTimer = null; }
                settingsPanel.classList.add('display-none');
                settingsPanel.style.opacity = '';
                settingsPanel.style.pointerEvents = '';
            }
        });
        settingsCloseBtn.addEventListener('click', () => { 
            if (settingsPanelTimer) { clearTimeout(settingsPanelTimer); settingsPanelTimer = null; }
            settingsPanel.classList.add('display-none');
            settingsPanel.style.opacity = '';
            settingsPanel.style.pointerEvents = '';
        });
        function scheduleSettingsPanelClose() {
            if (settingsPanelTimer) clearTimeout(settingsPanelTimer);
            settingsPanelTimer = setTimeout(() => {
                settingsPanel.style.opacity = '0';
                settingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { 
                    settingsPanel.classList.add('display-none'); 
                    settingsPanel.style.opacity = '';
                    settingsPanel.style.pointerEvents = '';
                }, 1200);
            }, 30000);
        }
        settingsApplyBtn.addEventListener('click', () => {
            // Read and clamp settings
            const minS = Math.max(3, Math.min(120, Number(inpShuffleMin.value) || 12));
            const maxS = Math.max(5, Math.min(180, Number(inpShuffleMax.value) || 25));
            const trans = Math.max(0, Math.min(10, Number(inpTransition.value) || 2.7));
            const px = Math.max(0.5, Math.min(3, Number(inpPixelRatio.value) || 1));
            visualSettings.shuffleMinSec = minS;
            visualSettings.shuffleMaxSec = maxS;
            visualSettings.transitionSec = trans;
            visualSettings.pixelRatio = px;
            // Apply if active is v2
            if(state.activeVisualizer && state.activeVisualizer instanceof MilkdropEngineV2) {
                state.activeVisualizer.applySettings?.();
            }
        });
        
        // Skip Preset Button Logic
        document.getElementById('btn-skip-preset').addEventListener('click', () => {
            if(state.activeVisualizer && state.activeVisualizer.nextPreset) {
                state.activeVisualizer.nextPreset();
            }
        });

        // --- RADIO: Load stations and UI ---
        async function loadStations() {
            try {
                const resp = await fetch('radio.txt');
                const txt = await resp.text();
                stations.length = 0;
                txt.split('\n').forEach((line) => {
                    const raw = line.trim();
                    if(!raw) return;
                    const parts = raw.split('|');
                    if(parts.length >= 2) {
                        const name = parts[0].trim();
                        const url = parts.slice(1).join('|').trim();
                        stations.push({ name, url });
                    }
                });
                renderStationList();
            } catch(e) {
                console.warn('Failed to load radio.txt', e);
            }
        }

        function renderStationList() {
            radioListEl.innerHTML = '';
            stations.forEach((s, i) => {
                const item = document.createElement('div');
                item.className = 'radio-item';
                item.dataset.index = String(i);
                if(i === currentStationIndex) item.classList.add('active');
                const nameEl = document.createElement('div');
                nameEl.textContent = s.name;
                const goEl = document.createElement('div');
                goEl.textContent = '‚û§';
                item.appendChild(nameEl);
                item.appendChild(goEl);
                item.addEventListener('click', () => {
                    setStation(i);
                });
                radioListEl.appendChild(item);
            });
        }

        function setStation(index) {
            if(index < 0 || index >= stations.length) return;
            currentStationIndex = index;
            const s = stations[index];
            radioInputEl.value = s.url;
            showStationBanner(s.name);
            updateStationActiveHighlight();
            playRadio();
        }

        function updateStationActiveHighlight() {
            const children = Array.from(radioListEl.children);
            children.forEach((el) => {
                const idx = Number(el.dataset.index || -1);
                if(idx === currentStationIndex) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function pickRandomStation() {
            if(stations.length === 0) return;
            let idx = currentStationIndex;
            if(stations.length === 1) idx = 0;
            else {
                while(idx === currentStationIndex) {
                    idx = Math.floor(Math.random() * stations.length);
                }
            }
            setStation(idx);
        }

        function showRadioPanel() { 
            radioPanel.classList.remove('display-none'); 
            radioPanel.style.opacity = '1';
            radioPanel.style.pointerEvents = 'auto';
            scheduleRadioPanelClose();
        }
        function hideRadioPanel() { 
            if (radioPanelTimer) { clearTimeout(radioPanelTimer); radioPanelTimer = null; }
            radioPanel.classList.add('display-none'); 
            radioPanel.style.opacity = '';
            radioPanel.style.pointerEvents = '';
        }
        function toggleRadioPanel() {
            if(radioPanel.classList.contains('display-none')) showRadioPanel();
            else hideRadioPanel();
        }
        function scheduleRadioPanelClose() {
            if (radioPanelTimer) clearTimeout(radioPanelTimer);
            radioPanelTimer = setTimeout(() => {
                radioPanel.style.opacity = '0';
                radioPanel.style.pointerEvents = 'none';
                setTimeout(() => { hideRadioPanel(); }, 1200);
            }, 30000);
        }

        function showStationBanner(text) {
            stationBanner.textContent = text || '';
            if(!text) return;
            stationBanner.classList.remove('display-none');
            stationBanner.style.opacity = '1';
            stationBanner.style.pointerEvents = 'auto';
            // Auto-hide after a short display even if no mouse movement occurs
            if (stationBannerTimer) { clearTimeout(stationBannerTimer); stationBannerTimer = null; }
            stationBannerTimer = setTimeout(() => {
                stationBanner.style.opacity = '0';
                stationBanner.style.pointerEvents = 'none';
                // Give CSS transition time to finish before hiding completely
                setTimeout(() => {
                    stationBanner.classList.add('display-none');
                }, 800);
            }, 3000);
        }

        function deriveTitleFromUrl(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch {
                return url;
            }
        }

        // Swap: left-click now opens panel; right-click picks random
        radioQuickBtn.title = "Left-click: choose ‚Ä¢ Right-click: random station";
        radioQuickBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleRadioPanel();
        });
        radioQuickBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            pickRandomStation();
            // Keep the radio button visible for 10s after right-click shuffle
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            radioQuickHoldUntil = Date.now() + 10000;
            if (radioQuickHoldTimeout) { clearTimeout(radioQuickHoldTimeout); radioQuickHoldTimeout = null; }
            radioQuickHoldTimeout = setTimeout(() => {
                radioQuickHoldUntil = 0;
                // Only hide if UI is idle (layer opacity is 0)
                if (uiLayer.style.opacity === '0') {
                    radioQuickBtn.style.opacity = '0';
                    radioQuickBtn.style.pointerEvents = 'none';
                }
            }, 10000);
        });
        // Station banner toggles shuffle
        stationBanner.title = "Click: toggle visual shuffle";
        stationBanner.addEventListener('click', (e) => {
            e.stopPropagation();
            setModeShuffle(!modeShuffleOn);
        });
        document.addEventListener('click', (e) => {
            if(!radioPanel.classList.contains('display-none')) {
                if(!radioPanel.contains(e.target) && e.target !== radioQuickBtn) {
                    hideRadioPanel();
                }
            }
        });

        // Drag Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            // Accept only for ProjectM (either version)
            const active = state.activeVisualizer;
            if(!(active instanceof MilkdropEngine) && !(active instanceof MilkdropEngineV2)) {
                return alert("Switch to ProjectM (v1 or v2) first");
            }
            const file = e.dataTransfer.files[0];
            if(!file) return;
            const lower = file.name.toLowerCase();
            if(lower.endsWith('.milk')) {
                alert("Raw .milk files are not directly supported. Please convert to butterchurn JSON first.");
                return;
            }
            const reader = new FileReader();
            reader.onload = (ev) => active.loadCustomMilk?.(ev.target.result);
            reader.readAsText(file);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            } else if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                var resetBtn = document.getElementById('btn-webm-reset');
                if (resetBtn) { resetBtn.click(); }
            } else if (e.key === 'c' || e.key === 'C') {
                // ProjectM: next visual preset
                if (state && state.activeVisualizer && typeof state.activeVisualizer.nextPreset === 'function') {
                    e.preventDefault();
                    state.activeVisualizer.nextPreset();
                }
            } else if (e.key === 'Escape') {
                stopAllAndShowStart();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                adjustWebmPosition(-2, 0);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                adjustWebmPosition(2, 0);
            } else if (e.key === 'r' || e.key === 'R') {
                e.preventDefault();
                if (stations && stations.length > 0) {
                    pickRandomStation();
                }
            } else if (e.key === 'w' || e.key === 'W') {
                e.preventDefault();
                if(!webmOn) {
                    if(webmList.length === 0) {
                        loadWebmList().finally(() => {
                            if(webmList.length > 0) showWebm();
                        });
                    } else {
                        showWebm();
                    }
                } else {
                    hideWebm();
                }
            } else if (e.key === 'q' || e.key === 'Q') {
                e.preventDefault();
                adjustWebmSpeed(-0.1);
            } else if (e.key === 'e' || e.key === 'E') {
                e.preventDefault();
                adjustWebmSpeed(+0.1);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                adjustWebmPosition(0, -2);
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                adjustWebmPosition(0, 2);
            } else if (e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                if (webmOn) prevWebm();
            } else if (e.key === 'd' || e.key === 'D') {
                e.preventDefault();
                if (webmOn) nextWebm();
            } else if (e.key === 'z' || e.key === 'Z') {
                e.preventDefault();
                adjustWebmOpacity(-0.05);
            } else if (e.key === 'x' || e.key === 'X') {
                e.preventDefault();
                adjustWebmOpacity(0.05);
            } else if (e.key === '=') {
                e.preventDefault();
                adjustWebmScale(2);
            } else if (e.key === '-' || e.key === '_') {
                e.preventDefault();
                adjustWebmScale(-2);
            }
        });

        // Bootstrap station list
        loadStations();
        // Preload webm list (best-effort)
        loadWebmList();

        // --- WEBM HELPERS ---
        async function loadWebmList() {
            try {
                // Try a manifest first
                const resp = await fetch('webm/webms.txt', { cache: 'no-store' });
                if(resp.ok) {
                    const txt = await resp.text();
                    const files = txt.split('\n').map(s => s.trim()).filter(Boolean);
                    webmList = files.map(f => f.startsWith('webm/') ? f : `webm/${f}`);
                    webmIndex = 0;
                    return;
                }
            } catch {}
            // Try directory listing parse (best-effort)
            try {
                const dirResp = await fetch('webm/', { cache: 'no-store' });
                if(dirResp.ok) {
                    const html = await dirResp.text();
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    const anchors = Array.from(doc.querySelectorAll('a,link'));
                    const found = anchors.map(a => a.getAttribute('href') || '').filter(href => /\.webm(\?.*)?$/i.test(href));
                    if(found.length > 0) {
                        const normalized = found.map(f => f.startsWith('webm/') ? f : `webm/${f.replace(/^\//,'')}`);
                        // Deduplicate
                        webmList = Array.from(new Set(normalized));
                        webmIndex = 0;
                        return;
                    }
                }
            } catch {}
            // Fallback to known files
            const defaults = ['webm/red.webm', 'webm/grn.webm'];
            webmList = defaults;
            webmIndex = 0;
        }

        function showWebm() {
            if(webmList.length === 0) return;
            webmOn = true;
            setWebm(webmIndex);
            webmOverlayEl.classList.remove('display-none');
            webmPrevBtn.classList.remove('display-none');
            webmNextBtn.classList.remove('display-none');
            applyWebmSettings();
            // resume auto if enabled
            if (webmAutoOn) scheduleWebmAuto();
        }

        function hideWebm() {
            webmOn = false;
            webmOverlayEl.classList.add('display-none');
            webmPrevBtn.classList.add('display-none');
            webmNextBtn.classList.add('display-none');
            try { webmVideoEl.pause(); } catch {}
            try { webmVideoLeftEl.pause(); } catch {}
            try { webmVideoRightEl.pause(); } catch {}
            webmVideoEl.src = '';
            webmVideoLeftEl.src = '';
            webmVideoRightEl.src = '';
            // stop auto when hidden
            cancelWebmAuto();
        }

        function setWebm(index) {
            if(webmList.length === 0) return;
            if(index < 0) index = webmList.length - 1;
            if(index >= webmList.length) index = 0;
            webmIndex = index;
            const src = webmList[webmIndex];
            if(webmVideoEl.src.endsWith(src)) return;
            webmVideoEl.src = src;
            webmVideoEl.muted = true;
            webmVideoEl.loop = true;
            webmVideoEl.playsInline = true;
            webmVideoEl.autoplay = true;
            webmVideoEl.play().catch(()=>{ /* ignore */ });
            // mirror to duplicates
            [webmVideoLeftEl, webmVideoRightEl].forEach(v => {
                v.src = src;
                v.muted = true; v.loop = true; v.playsInline = true; v.autoplay = true;
                v.playbackRate = webmSettings.playbackRate;
                v.style.opacity = String(webmSettings.opacity);
                v.play().catch(()=>{});
            });
            // Ensure current settings are applied consistently to the main video and duplicates
            applyWebmSettings();
        }

        function nextWebm() { setWebm(webmIndex + 1); }
        function prevWebm() { setWebm(webmIndex - 1); }
        // --- WebM Auto Random ---
        function scheduleWebmAuto() {
            cancelWebmAuto();
            const delay = (30 + Math.random() * 30) * 1000; // 30-60s
            webmAutoTimer = setTimeout(() => {
                if (webmOn && webmList.length > 0) {
                    nextWebm();
                }
                scheduleWebmAuto();
            }, delay);
        }
        function cancelWebmAuto() {
            if (webmAutoTimer) { clearTimeout(webmAutoTimer); webmAutoTimer = null; }
        }
        function setWebmAuto(on) {
            webmAutoOn = !!on;
            const autoBtn = document.getElementById('btn-webm-auto');
            if (autoBtn) autoBtn.textContent = webmAutoOn ? 'Auto: On' : 'Auto: Off';
            if (webmAutoOn) scheduleWebmAuto(); else cancelWebmAuto();
        }
        
        function toggleWebmSettingsPanel() {
            if(webmSettingsPanel.classList.contains('display-none')) {
                webmSettingsPanel.classList.remove('display-none');
                webmSettingsPanel.style.display = 'block';
                webmSettingsPanel.style.opacity = '1';
                webmSettingsPanel.style.pointerEvents = 'auto';
                scheduleWebmSettingsClose();
                // sync inputs
                inpWebmScale.value = String(webmSettings.scaleVw);
                inpWebmX.value = String(webmSettings.posXvw);
                inpWebmY.value = String(webmSettings.posYvh);
                inpWebmRot.value = String(webmSettings.rotationDeg);
                inpWebmSpeed.value = String(webmSettings.playbackRate);
                inpWebmOpacity.value = String(webmSettings.opacity);
                inpWebmDup.value = String(webmSettings.duplicates);
            } else {
                hideWebmSettingsPanel();
            }
        }
        function hideWebmSettingsPanel() {
            if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
            webmSettingsPanel.classList.add('display-none');
            webmSettingsPanel.style.display = 'none';
            webmSettingsPanel.style.opacity = '';
            webmSettingsPanel.style.pointerEvents = '';
        }
        // expose for inline handlers
        window.hideWebmSettingsPanel = hideWebmSettingsPanel;
        function scheduleWebmSettingsClose() {
            if (webmSettingsTimer) clearTimeout(webmSettingsTimer);
            webmSettingsTimer = setTimeout(() => {
                webmSettingsPanel.style.opacity = '0';
                webmSettingsPanel.style.pointerEvents = 'none';
                setTimeout(() => { hideWebmSettingsPanel(); }, 1200);
            }, 30000);
        }
        if (webmCloseBtn) {
            webmCloseBtn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
            // Support pointerdown for cases where click is swallowed by other handlers
            webmCloseBtn.addEventListener('pointerdown', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
            // Also close on right-click/contextmenu for consistency with toggle behavior
            webmCloseBtn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            });
        }
        // Event delegation fallback in case the button is replaced dynamically
        webmSettingsPanel.addEventListener('click', (e) => {
            const t = e.target;
            if (!t) return;
            const btn = (t.id === 'btn-webm-close') ? t : (t.closest ? t.closest('#btn-webm-close') : null);
            if (btn) {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            }
        });
        webmSettingsPanel.addEventListener('pointerdown', (e) => {
            const t = e.target;
            if (!t) return;
            const btn = (t.id === 'btn-webm-close') ? t : (t.closest ? t.closest('#btn-webm-close') : null);
            if (btn) {
                e.preventDefault();
                e.stopPropagation();
                if (webmSettingsTimer) { clearTimeout(webmSettingsTimer); webmSettingsTimer = null; }
                hideWebmSettingsPanel();
            }
        });
        // Allow closing the Avatar Settings with Escape for reliability
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && !webmSettingsPanel.classList.contains('display-none')) {
                hideWebmSettingsPanel();
            }
        });
        // Close when clicking outside the avatar settings panel
        document.addEventListener('click', (e) => {
            if (webmSettingsPanel.classList.contains('display-none')) return;
            const target = e.target;
            // If click is inside the panel, ignore
            if (webmSettingsPanel.contains(target)) return;
            // Otherwise, close
            hideWebmSettingsPanel();
        }, true);
        document.getElementById('btn-webm-reset').addEventListener('click', () => {
            webmSettings.scaleVw = 50;
            webmSettings.posXvw = 50;
            webmSettings.posYvh = 50;
            webmSettings.rotationDeg = 0;
            webmSettings.playbackRate = 1.0;
            webmSettings.opacity = 0.82;
            webmSettings.duplicates = 0;
            inpWebmScale.value = '50';
            inpWebmX.value = '50';
            inpWebmY.value = '50';
            inpWebmRot.value = '0';
            inpWebmSpeed.value = '1.0';
            inpWebmOpacity.value = '0.82';
            inpWebmDup.value = '0';
            applyWebmSettings();
        });
        // Live-change on input
        function updateWebmSettingsFromInputs() {
            webmSettings.scaleVw = Number(inpWebmScale.value) || 50;
            webmSettings.posXvw = Number(inpWebmX.value) || 50;
            webmSettings.posYvh = Number(inpWebmY.value) || 50;
            webmSettings.rotationDeg = Number(inpWebmRot.value) || 0;
            webmSettings.playbackRate = Math.max(0.1, Math.min(4, Number(inpWebmSpeed.value) || 1));
            webmSettings.opacity = Math.max(0, Math.min(1, Number(inpWebmOpacity.value) || 1));
            webmSettings.duplicates = Math.max(0, Math.min(2, Math.floor(Number(inpWebmDup.value) || 0)));
            applyWebmSettings();
            scheduleWebmSettingsClose();
        }
        [inpWebmScale, inpWebmX, inpWebmY, inpWebmRot, inpWebmSpeed, inpWebmOpacity, inpWebmDup].forEach(el => {
            el.addEventListener('input', updateWebmSettingsFromInputs);
        });
        // Bind auto toggle
        const btnWebmAuto = document.getElementById('btn-webm-auto');
        if (btnWebmAuto) {
            btnWebmAuto.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                setWebmAuto(!webmAutoOn);
            });
        }
        function applyWebmSettings() {
            // central
            webmVideoEl.style.width = `${webmSettings.scaleVw}vw`;
            webmOverlayEl.style.left = `${webmSettings.posXvw}vw`;
            webmOverlayEl.style.top = `${webmSettings.posYvh}vh`;
            webmOverlayEl.style.transform = `translate(-50%, -50%)`;
            webmVideoEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
            webmVideoEl.style.opacity = String(webmSettings.opacity);
            try { webmVideoEl.playbackRate = webmSettings.playbackRate; } catch {}
            // duplicates
            const dup = webmSettings.duplicates;
            const offsetVw = webmSettings.scaleVw * 0.6;
            if(dup >= 1) {
                webmVideoLeftEl.classList.remove('display-none');
                webmVideoLeftEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoLeftEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoLeftEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoLeftEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoLeftEl.classList.add('display-none');
            }
            if(dup >= 2) {
                webmVideoRightEl.classList.remove('display-none');
                webmVideoRightEl.style.width = `${webmSettings.scaleVw}vw`;
                webmVideoRightEl.style.transform = `rotate(${webmSettings.rotationDeg}deg)`;
                webmVideoRightEl.style.opacity = String(webmSettings.opacity);
                try { webmVideoRightEl.playbackRate = webmSettings.playbackRate; } catch {}
            } else {
                webmVideoRightEl.classList.add('display-none');
            }
            // Position duplicates relative to overlay center using absolute positioning containers
            // We'll position by setting margins on the left/right elements
            webmVideoEl.style.display = 'block';
            webmVideoLeftEl.style.display = dup >= 1 ? 'block' : 'none';
            webmVideoRightEl.style.display = dup >= 2 ? 'block' : 'none';
            // Reset any existing margins
            webmVideoEl.style.margin = '0';
            webmVideoLeftEl.style.margin = '0';
            webmVideoRightEl.style.margin = '0';
            // Arrange: left video shifted left by offset, right shifted right by offset, overlapping allowed
            webmVideoLeftEl.style.position = 'absolute';
            webmVideoRightEl.style.position = 'absolute';
            webmVideoEl.style.position = 'relative';
            webmVideoLeftEl.style.left = `-${offsetVw}vw`;
            webmVideoLeftEl.style.top = `0`;
            webmVideoRightEl.style.left = `${offsetVw}vw`;
            webmVideoRightEl.style.top = `0`;
        }
        // --- MODE SHUFFLE ---
        function setModeShuffle(on) {
            modeShuffleOn = on;
            if(modeShuffleTimer) { clearTimeout(modeShuffleTimer); modeShuffleTimer = null; }
            if(modeShuffleOn) {
                scheduleModeShuffle();
                stationBanner.classList.add('shuffle-on');
            }
            if(!modeShuffleOn) {
                stationBanner.classList.remove('shuffle-on');
            }
        }
        function scheduleModeShuffle() {
            if(!modeShuffleOn) return;
            modeShuffleTimer = setTimeout(() => {
                loadMode(state.currentModeIdx + 1);
                scheduleModeShuffle();
            }, 30000);
        }

	</script>
	<div id="border-frame"></div>
</body>
</html>