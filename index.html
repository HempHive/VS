<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OmnI: Tomorrow</title>
    <link href="favicon.ico" rel="icon" type="image/x-icon"/>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; color: white; cursor: none; }
        
        /* Layout */
        #canvas-container { 
            position: absolute; top: 0; left: 0;
            width: 100vw; height: 100vh; 
            overflow: hidden;
            z-index: 1;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* UI Overlays */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; transition: opacity 0.5s; backdrop-filter: blur(10px);
            cursor: default;
        }

        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 140px;
            display: flex; justify-content: space-between; align-items: center;
            padding: 0 40px; box-sizing: border-box;
            background: linear-gradient(to top, rgba(0,0,0,1), transparent);
            z-index: 50;
            transition: opacity 1s ease-in-out;
            opacity: 1;
        }

        /* Center Control Group */
        .center-controls {
            display: flex; align-items: center; justify-content: center; gap: 20px;
        }

        /* Interactive Elements */
        .interactive { pointer-events: auto; cursor: pointer; }

        h1 { font-weight: 200; letter-spacing: 8px; text-transform: uppercase; margin-bottom: 30px; text-shadow: 0 0 20px rgba(255,255,255,0.2); text-align: center; }

        .control-group {
            display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;
        }

        .btn-main {
            padding: 15px 30px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.05); color: #fff;
            font-size: 13px; text-transform: uppercase; letter-spacing: 2px; transition: 0.3s;
            border-radius: 4px; min-width: 150px;
        }
        .btn-main:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.4); border-color: #fff; }

        /* Secondary Icon Buttons (Fullscreen / Skip) */
        .icon-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.6);
            font-size: 24px; padding: 10px; transition: 0.2s; display: flex; align-items: center;
        }
        .icon-btn:hover { color: #fff; transform: scale(1.2); text-shadow: 0 0 10px #fff; }

        .radio-input {
            padding: 15px; background: rgba(0,0,0,0.5); border: 1px solid #444; color: #0f0; 
            width: 320px; font-family: monospace;
        }

        /* Navigation Arrows */
        .nav-btn {
            font-size: 50px; opacity: 0.3; transition: 0.3s; user-select: none; padding: 20px;
        }
        .nav-btn:hover { opacity: 1; text-shadow: 0 0 15px #fff; transform: scale(1.1); }

        #mode-info { text-align: center; min-width: 250px; }
        #mode-title { font-size: 24px; font-weight: 600; display: block; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 10px rgba(0,0,0,0.5); }
        #mode-sub { font-size: 12px; color: #aaa; font-family: monospace; letter-spacing: 1px; max-width: 400px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display: block; margin: 0 auto;}

        .hidden { opacity: 0 !important; pointer-events: none; }
        .display-none { display: none !important; }
        
        #loading-status { color: #0ff; margin-top: 20px; font-family: monospace; font-size: 12px; height: 20px; }

        /* Quick Radio Button (Top-right) */
        #radio-quick {
            position: absolute; top: 14px; right: 14px;
            z-index: 80;
            width: 40px; height: 40px;
            background: transparent url('radio.png') center center / contain no-repeat;
            border: none;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(6px);
            transition: opacity 1s ease-in-out;
        }
        #radio-quick:hover {
            filter: brightness(1.15);
        }

        /* Radio Panel */
        #radio-panel {
            position: absolute; top: 54px; right: 14px;
            width: 360px; max-height: 60vh; overflow: auto;
            z-index: 90;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            backdrop-filter: blur(8px);
            transition: opacity 1s ease-in-out;
        }
        #radio-panel h3 {
            margin: 0; padding: 12px 14px; font-weight: 500; font-size: 14px;
            border-bottom: 1px solid rgba(255,255,255,0.12);
            letter-spacing: 1px; text-transform: uppercase; color: #ddd;
        }
        #radio-list { padding: 8px; }
        .radio-item {
            padding: 10px 12px; margin: 6px 0; border-radius: 6px;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.12);
            cursor: pointer; transition: 0.15s;
            display: flex; align-items: center; justify-content: space-between;
            font-size: 13px;
        }
        .radio-item:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 20px rgba(255,255,255,0.08) inset;
        }
        .radio-item.active {
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212,175,55,0.3) inset, 0 0 16px rgba(212,175,55,0.15);
            background: rgba(212,175,55,0.08);
        }

        /* Station Banner (Top-left) */
        #station-banner {
            position: absolute; top: 14px; left: 14px;
            z-index: 80;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0,0,0,0.55);
            border: 1px solid rgba(255,255,255,0.18);
            color: #fff;
            font-size: 13px;
            letter-spacing: 0.5px;
            pointer-events: none;
            transition: opacity 1s ease-in-out;
            max-width: min(60vw, 720px);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
    </style>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/",
                "butterchurn": "https://esm.sh/butterchurn@2.6.0",
                "butterchurn-presets": "https://esm.sh/butterchurn-presets@2.4.7",
                "lodash": "https://esm.sh/lodash@4.17.21"
            }
        }
    </script>
</head>
<body>

    <!-- START SCREEN -->
    <div id="overlay">
        <h1>OmnI</h1>
        
        <div class="control-group">
            <!-- DEFAULT RADIO URL: BigFM Tomorrowland -->
            <input type="text" id="radio-url" class="radio-input interactive" value="https://stream.bigfm.de/tomorrowland/mp3-128/" placeholder="Paste Stream URL">
            <button class="btn-main interactive" id="btn-radio">▶ Start Radio</button>
        </div>

        <div class="control-group">
            <button class="btn-main interactive" id="btn-mic">Use Microphone</button>
            <button class="btn-main interactive" onclick="document.getElementById('file-input').click()">Load Local MP3</button>
            <input type="file" id="file-input" accept="audio/*" style="display:none">
        </div>

        <div id="loading-status">Select a source to begin</div>
    </div>

    <!-- HUD (Fades out when idle) -->
    <div id="ui-layer" class="hidden">
        <div class="nav-btn interactive" id="btn-prev">❮</div>

        <div class="center-controls">
            <!-- SKIP PRESET BUTTON (Only for ProjectM) -->
            <button class="icon-btn interactive display-none" id="btn-skip-preset" title="Next Visual Preset">⏭</button>

            <!-- TITLE INFO -->
            <div id="mode-info">
                <span id="mode-title">INIT</span>
                <span id="mode-sub">Engine Ready</span>
            </div>

            <!-- FULLSCREEN BUTTON -->
            <button class="icon-btn interactive" id="btn-fullscreen" title="Toggle Fullscreen">⛶</button>
        </div>

        <div class="nav-btn interactive" id="btn-next">❯</div>
    </div>

    <div id="canvas-container"></div>
    <audio id="radio-element" crossorigin="anonymous"></audio>
    <!-- Quick Radio Button and Panel -->
    <div id="radio-quick" class="interactive" role="button" aria-label="Radio control" title="Left-click: random station • Right-click: choose"></div>
    <div id="radio-panel" class="display-none">
        <h3>Radio Stations</h3>
        <div id="radio-list"></div>
    </div>
    <div id="station-banner" class="display-none"></div>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { SimplexNoise } from 'three/addons/math/SimplexNoise.js';
        import butterchurn from 'butterchurn';
        import butterchurnPresets from 'butterchurn-presets';

        // --- GLOBAL STATE ---
        const state = {
            audioCtx: null,
            sourceNode: null,
            analyserNode: null,
            isPlaying: false,
            currentModeIdx: 0,
            activeVisualizer: null,
            idleTimer: null
        };
        async function loadExternalMilkdropPresets() {
    try {
        const resp = await fetch("presets/milkdrop-presets.json");
        const json = await resp.json();
        return json;
    } catch (err) {
        console.error("Failed to load external Milkdrop preset pack:", err);
        return {};
    }
}
        const container = document.getElementById('canvas-container');
        const statusEl = document.getElementById('loading-status');
        const uiLayer = document.getElementById('ui-layer');
        const radioQuickBtn = document.getElementById('radio-quick');
        const radioPanel = document.getElementById('radio-panel');
        const radioListEl = document.getElementById('radio-list');
        const radioInputEl = document.getElementById('radio-url');
        const audioEl = document.getElementById('radio-element');
        const stationBanner = document.getElementById('station-banner');
        const stations = [];
        let currentStationIndex = -1;
        let panelIdleTimer = null;

        // --- UI UTILS ---
        function resetIdleTimer() {
            uiLayer.style.opacity = '1';
            radioQuickBtn.style.opacity = '1';
            radioQuickBtn.style.pointerEvents = 'auto';
            if(!stationBanner.classList.contains('display-none')) {
                stationBanner.style.opacity = '1';
            }
            if(!radioPanel.classList.contains('display-none')) {
                radioPanel.style.opacity = '1';
                radioPanel.style.pointerEvents = 'auto';
            }
            document.body.style.cursor = 'default';
            if (state.idleTimer) clearTimeout(state.idleTimer);
            if (panelIdleTimer) clearTimeout(panelIdleTimer);
            if(state.isPlaying) {
                state.idleTimer = setTimeout(() => {
                    uiLayer.style.opacity = '0';
                    radioQuickBtn.style.opacity = '0';
                    radioQuickBtn.style.pointerEvents = 'none';
                    if(!stationBanner.classList.contains('display-none')) {
                        stationBanner.style.opacity = '0';
                    }
                    document.body.style.cursor = 'none';
                }, 3000);
                // Radio panel fades out after double time (6s) if open
                if(!radioPanel.classList.contains('display-none')) {
                    panelIdleTimer = setTimeout(() => {
                        radioPanel.style.opacity = '0';
                        radioPanel.style.pointerEvents = 'none';
                    }, 6000);
                }
            }
        }
        window.addEventListener('mousemove', resetIdleTimer);
        window.addEventListener('click', resetIdleTimer);

        // Updated Fullscreen Logic with forced Resize Trigger
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().then(() => {
                    setTimeout(() => forceResize(), 200);
                }).catch(err => console.log(err));
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen().then(() => {
                        setTimeout(() => forceResize(), 200);
                    });
                }
            }
        }

        function forceResize() {
            if(state.activeVisualizer && state.activeVisualizer.onResize) {
                state.activeVisualizer.onResize();
            }
        }

        // --- AUDIO ENGINE ---
        function initAudio() {
            if(!state.audioCtx) {
                state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                state.analyserNode = state.audioCtx.createAnalyser();
                state.analyserNode.fftSize = 2048; 
            }
            if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
        }

        function playRadio() {
            initAudio();
            const url = radioInputEl.value;
            
            statusEl.innerText = "Connecting to Stream...";
            // Update banner title
            if(currentStationIndex >= 0 && stations[currentStationIndex] && stations[currentStationIndex].url === url) {
                showStationBanner(stations[currentStationIndex].name);
            } else {
                showStationBanner(deriveTitleFromUrl(url));
            }
            
            audioEl.crossOrigin = "anonymous"; 
            audioEl.src = url;
            
            audioEl.play().then(() => {
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaElementSource(audioEl);
                state.sourceNode.connect(state.analyserNode);
                state.analyserNode.connect(state.audioCtx.destination);
                if(!state.isPlaying) startGame();
            }).catch(e => {
                statusEl.innerText = "Stream Error: CORS or Format.";
                alert("Stream failed to play. The radio station might be blocking browser visualizers.");
            });
        }

        async function useMic() {
            initAudio();
            statusEl.innerText = "Requesting Mic Access...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                if(state.sourceNode) state.sourceNode.disconnect();
                state.sourceNode = state.audioCtx.createMediaStreamSource(stream);
                state.sourceNode.connect(state.analyserNode);
                startGame();
            } catch(e) { statusEl.innerText = "Error: " + e.message; }
        }

        function useFile(e) {
            initAudio();
            const file = e.target.files[0];
            if(!file) return;
            statusEl.innerText = "Decoding...";
            const reader = new FileReader();
            reader.onload = (ev) => {
                state.audioCtx.decodeAudioData(ev.target.result, (buffer) => {
                    if(state.sourceNode) state.sourceNode.stop();
                    state.sourceNode = state.audioCtx.createBufferSource();
                    state.sourceNode.buffer = buffer;
                    state.sourceNode.loop = true;
                    state.sourceNode.connect(state.analyserNode);
                    state.analyserNode.connect(state.audioCtx.destination);
                    state.sourceNode.start(0);
                    startGame();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function startGame() {
            state.isPlaying = true;
            document.getElementById('overlay').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            loadMode(0); // Start with ProjectM
            resetIdleTimer();
        }

        // --- ENGINE: BUTTERCHURN ---
        class MilkdropEngine {
            constructor() {
                this.name = "ProjectM / Milkdrop";
                this.presets = butterchurnPresets.getPresets();
                this.presetKeys = Object.keys(this.presets);
                this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
                this.resizeHandler = this.onResize.bind(this);
                this.canvas = null; // Track canvas reference
            }

            init() {
                container.innerHTML = '';
                this.canvas = document.createElement('canvas');
                
                // FIX: Explicitly set canvas attributes to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                container.appendChild(this.canvas);

                this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
                    width: window.innerWidth, 
                    height: window.innerHeight,
                    pixelRatio: window.devicePixelRatio || 1
                });
                this.visualizer.connectAudio(state.analyserNode);
                this.loadPreset(this.currentPresetIdx);

                window.addEventListener('resize', this.resizeHandler);
                
                this.animate();
                this.restartCycle();
            }

            loadPreset(idx) {
                const key = this.presetKeys[idx];
                this.visualizer.loadPreset(this.presets[key], 2.7); 
                document.getElementById('mode-sub').innerText = key;
            }

            nextPreset() {
                // Pick a random preset different from current
                let next = this.currentPresetIdx;
                if(this.presetKeys.length > 1) {
                    while(next === this.currentPresetIdx) {
                        next = Math.floor(Math.random() * this.presetKeys.length);
                    }
                }
                this.currentPresetIdx = next;
                this.loadPreset(this.currentPresetIdx);
                this.restartCycle();
            }

            restartCycle() {
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                const schedule = () => {
                    const delay = 12000 + Math.random() * 13000; // 12s - 25s
                    this.cycleTimeout = setTimeout(() => {
                        this.nextPreset();
                        schedule();
                    }, delay);
                };
                schedule();
            }
            
            loadCustomMilk(jsonTxt) {
                try {
                    const preset = JSON.parse(jsonTxt);
                    this.visualizer.loadPreset(preset, 1.0);
                    document.getElementById('mode-sub').innerText = "CUSTOM PRESET";
                    if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                } catch(e) { alert("Invalid JSON"); }
            }

            onResize() { 
                if(this.visualizer && this.canvas) {
                    const w = window.innerWidth;
                    const h = window.innerHeight;
                    // FIX: Update attributes AND renderer
                    this.canvas.width = w;
                    this.canvas.height = h;
                    this.visualizer.setRendererSize(w, h);
                }
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                this.visualizer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                if(this.cycleTimeout) clearTimeout(this.cycleTimeout);
                window.removeEventListener('resize', this.resizeHandler);
                container.innerHTML = '';
            }
        }
           class MilkdropMegaEngine {
    constructor() {
        this.name = "Milky";
        this.resizeHandler = this.onResize.bind(this);
        this.presets = null;
        this.presetKeys = [];
        this.currentPresetIdx = 0;
        this.canvas = null;
    }

    async init() {
        // Load container + canvas
        container.innerHTML = '';
        this.canvas = document.createElement('canvas');
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        container.appendChild(this.canvas);

        // Load presets JSON if not loaded yet
        if (!this.presets) {
            this.presets = await loadExternalMilkdropPresets();
            this.presetKeys = Object.keys(this.presets);
        }

        // Create visualizer
        this.visualizer = butterchurn.createVisualizer(state.audioCtx, this.canvas, {
            width: window.innerWidth,
            height: window.innerHeight,
            pixelRatio: window.devicePixelRatio || 1
        });

        this.visualizer.connectAudio(state.analyserNode);

        // Pick a random preset to start
        this.currentPresetIdx = Math.floor(Math.random() * this.presetKeys.length);
        this.loadPreset(this.currentPresetIdx);

        // Resize + animation
        window.addEventListener('resize', this.resizeHandler);
        this.animate();
        this.schedulePresetRotation();
    }

    loadPreset(idx) {
        const key = this.presetKeys[idx];
        const preset = this.presets[key];
        this.visualizer.loadPreset(preset, 2.5);
        document.getElementById('mode-sub').innerText = key;
    }

    nextPreset() {
        let next = this.currentPresetIdx;
        if (this.presetKeys.length > 1) {
            while (next === this.currentPresetIdx) {
                next = Math.floor(Math.random() * this.presetKeys.length);
            }
        }
        this.currentPresetIdx = next;
        this.loadPreset(next);
    }

    schedulePresetRotation() {
        if (this.rotationTimer) clearTimeout(this.rotationTimer);
        const delay = 8000 + Math.random() * 12000;
        this.rotationTimer = setTimeout(() => {
            this.nextPreset();
            this.schedulePresetRotation();
        }, delay);
    }

    animate() {
        this.animId = requestAnimationFrame(this.animate.bind(this));
        this.visualizer.render();
    }

    onResize() {
        if (this.visualizer && this.canvas) {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.visualizer.setRendererSize(window.innerWidth, window.innerHeight);
        }
    }

    destroy() {
        cancelAnimationFrame(this.animId);
        clearTimeout(this.rotationTimer);
        window.removeEventListener('resize', this.resizeHandler);
        container.innerHTML = '';
    }
}
        // --- ENGINE: THREE.JS ---
        class ThreeEngine {
            constructor(name, sceneFn) {
                this.name = name;
                this.sceneFn = sceneFn;
                this.resizeHandler = this.onResize.bind(this);
            }

            init() {
                container.innerHTML = '';
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                this.camera.position.z = 4;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio); // Sharpness
                container.appendChild(this.renderer.domElement);

                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                this.composer.addPass(bloom);

                this.dataArray = new Uint8Array(state.analyserNode.frequencyBinCount);
                this.updateFn = this.sceneFn(this.scene, this.camera);
                
                window.addEventListener('resize', this.resizeHandler);
                this.animate();
            }

            onResize() {
                if(!this.camera || !this.renderer) return;
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.composer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                this.animId = requestAnimationFrame(this.animate.bind(this));
                state.analyserNode.getByteFrequencyData(this.dataArray);
                if(this.updateFn) this.updateFn(this.dataArray, performance.now());
                this.composer.render();
            }

            destroy() {
                cancelAnimationFrame(this.animId);
                window.removeEventListener('resize', this.resizeHandler);
                this.renderer.dispose();
                container.innerHTML = '';
            }
        }

        // --- SCENES ---
        const sceneSphere = (scene) => {
            const geo = new THREE.IcosahedronGeometry(1.8, 30);
            const mat = new THREE.MeshPhysicalMaterial({ wireframe: true, color: 0x00ff00, emissive: 0x004400 });
            const mesh = new THREE.Mesh(geo, mat);
            scene.add(mesh);
            return (data, time) => {
                const bass = data[20]/255; 
                const t = time*0.0005;
                mesh.rotation.y += 0.005; 
                mesh.scale.setScalar(1 + bass*0.5); 
                mesh.material.color.setHSL(t%1, 1, 0.5);
            };
        };

        const sceneTunnel = (scene, camera) => {
            const group = new THREE.Group();
            const count = 40;
            const meshes = [];
            for(let i=0; i<count; i++){
                const geo = new THREE.TorusGeometry(1+(i*0.5), 0.05, 8, 50);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.2 });
                const mesh = new THREE.Mesh(geo, mat);
                group.add(mesh);
                meshes.push(mesh);
            }
            scene.add(group);
            return (data, time) => {
                const step = Math.floor(data.length/count);
                for(let i=0; i<count; i++){
                    const val = data[i*step]/255;
                    meshes[i].scale.setScalar(1 + val);
                    meshes[i].material.color.setHSL(val + (time*0.0002), 1, 0.5);
                    meshes[i].rotation.z += 0.01 * (i%2?1:-1);
                }
                camera.position.z = 25 + Math.sin(time*0.001)*5;
                camera.rotation.z = time * 0.0005;
            };
        };

        const sceneBars = (scene, camera) => {
            const group = new THREE.Group();
            const bars = [];
            const numBars = 64;
            const spacing = 0.25;
            for(let i = 0; i < numBars; i++) {
                const geo = new THREE.BoxGeometry(0.18, 0.5, 0.18);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x001f1f, metalness: 0.1, roughness: 0.6 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.x = (i - numBars/2) * spacing;
                group.add(mesh);
                bars.push(mesh);
            }
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            const point = new THREE.PointLight(0x00ffff, 1.2, 50);
            point.position.set(0, 5, 5);
            scene.add(ambient, point, group);
            camera.position.z = 8;
            return (data, time) => {
                const step = Math.floor(data.length / numBars);
                const t = time * 0.0008;
                for(let i = 0; i < numBars; i++) {
                    const v = data[i * step] / 255;
                    const h = 0.2 + v * 3.0;
                    bars[i].scale.y = h;
                    bars[i].position.y = h * 0.25;
                    const hue = (i / numBars + t) % 1;
                    bars[i].material.color.setHSL(hue, 1, 0.5);
                    bars[i].material.emissive.setHSL(hue, 1, 0.2);
                }
                group.rotation.y = Math.sin(t * 0.5) * 0.2;
            };
        };

        // --- MASTER CONTROL ---
        const modes = [
    new MilkdropEngine(),
    new ThreeEngine("Neon Sphere", sceneSphere),
    new ThreeEngine("Cyber Tunnel", sceneTunnel),
    new ThreeEngine("Audio Bars", sceneBars),
    new MilkdropMegaEngine()   // <-- NEW 5th MODE
];

        function loadMode(index) {
            if(state.activeVisualizer) state.activeVisualizer.destroy();
            let idx = index;
            if(idx < 0) idx = modes.length - 1;
            if(idx >= modes.length) idx = 0;
            state.currentModeIdx = idx;
            state.activeVisualizer = modes[idx];
            
            // UI Updates
            document.getElementById('mode-title').innerText = state.activeVisualizer.name;
            if (idx === 1 || idx === 2 || idx === 3) {
    document.getElementById('mode-sub').innerText = "3D Interactive";
}
            
            // Show/Hide Skip Button
            const skipBtn = document.getElementById('btn-skip-preset');
            if (idx === 0 || idx === 4) {
    skipBtn.classList.remove('display-none');
} else {
    skipBtn.classList.add('display-none');
}

            state.activeVisualizer.init();
        }

        // --- BINDINGS ---
        document.getElementById('btn-prev').addEventListener('click', () => { loadMode(state.currentModeIdx - 1); resetIdleTimer(); });
        document.getElementById('btn-next').addEventListener('click', () => { loadMode(state.currentModeIdx + 1); resetIdleTimer(); });
        document.getElementById('btn-radio').addEventListener('click', playRadio);
        document.getElementById('btn-mic').addEventListener('click', useMic);
        document.getElementById('file-input').addEventListener('change', useFile);
        document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
        
        // Skip Preset Button Logic
        document.getElementById('btn-skip-preset').addEventListener('click', () => {
            if ((state.currentModeIdx === 0 || state.currentModeIdx === 4) && state.activeVisualizer.nextPreset) {
    state.activeVisualizer.nextPreset();
}
        });

        // --- RADIO: Load stations and UI ---
        async function loadStations() {
            try {
                const resp = await fetch('radio.txt');
                const txt = await resp.text();
                stations.length = 0;
                txt.split('\n').forEach((line) => {
                    const raw = line.trim();
                    if(!raw) return;
                    const parts = raw.split('|');
                    if(parts.length >= 2) {
                        const name = parts[0].trim();
                        const url = parts.slice(1).join('|').trim();
                        stations.push({ name, url });
                    }
                });
                renderStationList();
            } catch(e) {
                console.warn('Failed to load radio.txt', e);
            }
        }

        function renderStationList() {
            radioListEl.innerHTML = '';
            stations.forEach((s, i) => {
                const item = document.createElement('div');
                item.className = 'radio-item';
                item.dataset.index = String(i);
                if(i === currentStationIndex) item.classList.add('active');
                const nameEl = document.createElement('div');
                nameEl.textContent = s.name;
                const goEl = document.createElement('div');
                goEl.textContent = '➤';
                item.appendChild(nameEl);
                item.appendChild(goEl);
                item.addEventListener('click', () => {
                    setStation(i);
                });
                radioListEl.appendChild(item);
            });
        }

        function setStation(index) {
            if(index < 0 || index >= stations.length) return;
            currentStationIndex = index;
            const s = stations[index];
            radioInputEl.value = s.url;
            showStationBanner(s.name);
            updateStationActiveHighlight();
            playRadio();
        }

        function updateStationActiveHighlight() {
            const children = Array.from(radioListEl.children);
            children.forEach((el) => {
                const idx = Number(el.dataset.index || -1);
                if(idx === currentStationIndex) el.classList.add('active');
                else el.classList.remove('active');
            });
        }

        function pickRandomStation() {
            if(stations.length === 0) return;
            let idx = currentStationIndex;
            if(stations.length === 1) idx = 0;
            else {
                while(idx === currentStationIndex) {
                    idx = Math.floor(Math.random() * stations.length);
                }
            }
            setStation(idx);
        }

        function showRadioPanel() { radioPanel.classList.remove('display-none'); }
        function hideRadioPanel() { radioPanel.classList.add('display-none'); }
        function toggleRadioPanel() {
            if(radioPanel.classList.contains('display-none')) showRadioPanel();
            else hideRadioPanel();
        }

        function showStationBanner(text) {
            stationBanner.textContent = text || '';
            if(!text) return;
            stationBanner.classList.remove('display-none');
            stationBanner.style.opacity = '1';
        }

        function deriveTitleFromUrl(url) {
            try {
                const u = new URL(url);
                return u.hostname.replace(/^www\./, '');
            } catch {
                return url;
            }
        }

        radioQuickBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            pickRandomStation();
        });
        radioQuickBtn.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleRadioPanel();
        });
        document.addEventListener('click', (e) => {
            if(!radioPanel.classList.contains('display-none')) {
                if(!radioPanel.contains(e.target) && e.target !== radioQuickBtn) {
                    hideRadioPanel();
                }
            }
        });

        // Drag Drop
        document.body.addEventListener('dragover', e => e.preventDefault());
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            if(state.currentModeIdx !== 0) return alert("Switch to ProjectM mode first");
            const file = e.dataTransfer.files[0];
            const reader = new FileReader();
            reader.onload = (ev) => state.activeVisualizer.loadCustomMilk(ev.target.result);
            reader.readAsText(file);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if(e.key === 'f' || e.key === 'F') {
                toggleFullscreen();
            } else if(e.key === 's' || e.key === 'S') {
                if ((state.currentModeIdx === 0 || state.currentModeIdx === 4) && state.activeVisualizer?.nextPreset) {
                    state.activeVisualizer.nextPreset();
                }
            }
        });

        // Bootstrap station list
        loadStations();

    </script>
</body>
</html>